{"version":3,"sources":["generic/preload_file.js"],"names":["define","buffers","file","Stats","api_error","fs","util","BaseFile","ApiError","ErrorCode","emptyBuffer","Buffer","PreloadFile","[object Object]","_fs","_path","_flag","_stat","contents","super","this","_pos","_dirty","_buffer","size","length","isReadable","Error","isAppendable","delta","newPos","cb","syncSync","e","ENOTSUP","closeSync","clone","len","truncateSync","isSynchronous","getRootFS","supportsSynch","sync","isWriteable","EPERM","mtimeMs","Date","now","buf","alloc","writeSync","newBuff","copy","buffer","offset","position","undefined","getPos","endFp","setPos","readSync","rv","atimeMs","mode","chmodSync","supportsProps","chmod","NoSyncFile"],"mappings":"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","file":"../../generic/preload_file.js","sourcesContent":["define([\n    '../libs/buffers',\n    '../core/file',\n    '../core/node_fs_stats',\n    '../core/api_error',\n    '../core/node_fs',\n    '../core/util'\n], function (buffers,file, Stats, api_error, fs, util) {\n    'use strict';\n\n    const { BaseFile } = file;\n    const { ApiError, ErrorCode } = api_error;\n    const { emptyBuffer } = util;\n    const { Buffer } = buffers;\n\n    /**\n     * An implementation of the File interface that operates on a file that is\n     * completely in-memory. PreloadFiles are backed by a Buffer.\n     *\n     * This is also an abstract class, as it lacks an implementation of 'sync' and\n     * 'close'. Each filesystem that wishes to use this file representation must\n     * extend this class and implement those two methods.\n     * @todo 'close' lever that disables functionality once closed.\n     */\n    class PreloadFile extends BaseFile {\n        /**\n         * Creates a file with the given path and, optionally, the given contents. Note\n         * that, if contents is specified, it will be mutated by the file!\n         * @param _fs The file system that created the file.\n         * @param _path\n         * @param _mode The mode that the file was opened using.\n         *   Dictates permissions and where the file pointer starts.\n         * @param _stat The stats object for the given file.\n         *   PreloadFile will mutate this object. Note that this object must contain\n         *   the appropriate mode that the file was opened as.\n         * @param contents A buffer containing the entire\n         *   contents of the file. PreloadFile will mutate this buffer. If not\n         *   specified, we assume it is a new file.\n         */\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super();\n            this._pos = 0;\n            this._dirty = false;\n            this._fs = _fs;\n            this._path = _path;\n            this._flag = _flag;\n            this._stat = _stat;\n            this._buffer = contents ? contents : emptyBuffer();\n            // Note: This invariant is *not* maintained once the file starts getting\n            // modified.\n            // Note: Only actually matters if file is readable, as writeable modes may\n            // truncate/append to file.\n            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\n                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\n            }\n        }\n        /**\n         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\n         */\n        getBuffer() {\n            return this._buffer;\n        }\n        /**\n         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\n         */\n        getStats() {\n            return this._stat;\n        }\n        getFlag() {\n            return this._flag;\n        }\n        /**\n         * Get the path to this file.\n         * @return [String] The path to the file.\n         */\n        getPath() {\n            return this._path;\n        }\n        /**\n         * Get the current file position.\n         *\n         * We emulate the following bug mentioned in the Node documentation:\n         * > On Linux, positional writes don't work when the file is opened in append\n         *   mode. The kernel ignores the position argument and always appends the data\n         *   to the end of the file.\n         * @return [Number] The current file position.\n         */\n        getPos() {\n            if (this._flag.isAppendable()) {\n                return this._stat.size;\n            }\n            return this._pos;\n        }\n        /**\n         * Advance the current file position by the indicated number of positions.\n         * @param [Number] delta\n         */\n        advancePos(delta) {\n            return this._pos += delta;\n        }\n        /**\n         * Set the file position.\n         * @param [Number] newPos\n         */\n        setPos(newPos) {\n            return this._pos = newPos;\n        }\n        /**\n         * **Core**: Asynchronous sync. Must be implemented by subclasses of this\n         * class.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        sync(cb) {\n            try {\n                this.syncSync();\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * **Core**: Synchronous sync.\n         */\n        syncSync() {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * **Core**: Asynchronous close. Must be implemented by subclasses of this\n         * class.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        close(cb) {\n            try {\n                this.closeSync();\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * **Core**: Synchronous close.\n         */\n        closeSync() {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Asynchronous `stat`.\n         * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb\n         */\n        stat(cb) {\n            try {\n                cb(null, Stats.clone(this._stat));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Synchronous `stat`.\n         */\n        statSync() {\n            return Stats.clone(this._stat);\n        }\n        /**\n         * Asynchronous truncate.\n         * @param [Number] len\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        truncate(len, cb) {\n            try {\n                this.truncateSync(len);\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\n                    this.sync(cb);\n                }\n                cb();\n            }\n            catch (e) {\n                return cb(e);\n            }\n        }\n        /**\n         * Synchronous truncate.\n         * @param [Number] len\n         */\n        truncateSync(len) {\n            this._dirty = true;\n            if (!this._flag.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n            }\n            this._stat.mtimeMs = Date.now();\n            if (len > this._buffer.length) {\n                const buf = Buffer.alloc(len - this._buffer.length, 0);\n                // Write will set @_stat.size for us.\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\n                    this.syncSync();\n                }\n                return;\n            }\n            this._stat.size = len;\n            // Truncate buffer to 'len'.\n            const newBuff = Buffer.alloc(len);\n            this._buffer.copy(newBuff, 0, 0, len);\n            this._buffer = newBuff;\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\n                this.syncSync();\n            }\n        }\n        /**\n         * Write buffer to the file.\n         * Note that it is unsafe to use fs.write multiple times on the same file\n         * without waiting for the callback.\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n         *  the file.\n         * @param [Number] offset Offset in the buffer to start reading data from.\n         * @param [Number] length The amount of bytes to write to the file.\n         * @param [Number] position Offset from the beginning of the file where this\n         *   data should be written. If position is null, the data will be written at\n         *   the current position.\n         * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]\n         *   cb The number specifies the number of bytes written into the file.\n         */\n        write(buffer, offset, length, position, cb) {\n            try {\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Write buffer to the file.\n         * Note that it is unsafe to use fs.writeSync multiple times on the same file\n         * without waiting for the callback.\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n         *  the file.\n         * @param [Number] offset Offset in the buffer to start reading data from.\n         * @param [Number] length The amount of bytes to write to the file.\n         * @param [Number] position Offset from the beginning of the file where this\n         *   data should be written. If position is null, the data will be written at\n         *   the current position.\n         * @return [Number]\n         */\n        writeSync(buffer, offset, length, position) {\n            this._dirty = true;\n            if (position === undefined || position === null) {\n                position = this.getPos();\n            }\n            if (!this._flag.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n            }\n            const endFp = position + length;\n            if (endFp > this._stat.size) {\n                this._stat.size = endFp;\n                if (endFp > this._buffer.length) {\n                    // Extend the buffer!\n                    const newBuff = Buffer.alloc(endFp);\n                    this._buffer.copy(newBuff);\n                    this._buffer = newBuff;\n                }\n            }\n            const len = buffer.copy(this._buffer, position, offset, offset + length);\n            this._stat.mtimeMs = Date.now();\n            if (this._flag.isSynchronous()) {\n                this.syncSync();\n                return len;\n            }\n            this.setPos(position + len);\n            return len;\n        }\n        /**\n         * Read data from the file.\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n         *   written to.\n         * @param [Number] offset The offset within the buffer where writing will\n         *   start.\n         * @param [Number] length An integer specifying the number of bytes to read.\n         * @param [Number] position An integer specifying where to begin reading from\n         *   in the file. If position is null, data will be read from the current file\n         *   position.\n         * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The\n         *   number is the number of bytes read\n         */\n        read(buffer, offset, length, position, cb) {\n            try {\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Read data from the file.\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n         *   written to.\n         * @param [Number] offset The offset within the buffer where writing will\n         *   start.\n         * @param [Number] length An integer specifying the number of bytes to read.\n         * @param [Number] position An integer specifying where to begin reading from\n         *   in the file. If position is null, data will be read from the current file\n         *   position.\n         * @return [Number]\n         */\n        readSync(buffer, offset, length, position) {\n            if (!this._flag.isReadable()) {\n                throw new ApiError(ErrorCode.EPERM, 'File not opened with a readable mode.');\n            }\n            if (position === undefined || position === null) {\n                position = this.getPos();\n            }\n            const endRead = position + length;\n            if (endRead > this._stat.size) {\n                length = this._stat.size - position;\n            }\n            const rv = this._buffer.copy(buffer, offset, position, position + length);\n            this._stat.atimeMs = Date.now();\n            this._pos = position + length;\n            return rv;\n        }\n        /**\n         * Asynchronous `fchmod`.\n         * @param [Number|String] mode\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        chmod(mode, cb) {\n            try {\n                this.chmodSync(mode);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Asynchronous `fchmod`.\n         * @param [Number] mode\n         */\n        chmodSync(mode) {\n            if (!this._fs.supportsProps()) {\n                throw new ApiError(ErrorCode.ENOTSUP);\n            }\n            this._dirty = true;\n            this._stat.chmod(mode);\n            this.syncSync();\n        }\n        isDirty() {\n            return this._dirty;\n        }\n        /**\n         * Resets the dirty bit. Should only be called after a sync has completed successfully.\n         */\n        resetDirty() {\n            this._dirty = false;\n        }\n    }\n    /**\n     * File class for the InMemory and XHR file systems.\n     * Doesn't sync to anything, so it works nicely for memory-only files.\n     */\n    class NoSyncFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        /**\n         * Asynchronous sync. Doesn't do anything, simply calls the cb.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        sync(cb) {\n            cb();\n        }\n        /**\n         * Synchronous sync. Doesn't do anything.\n         */\n        syncSync() {\n            // NOP.\n        }\n        /**\n         * Asynchronous close. Doesn't do anything, simply calls the cb.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        close(cb) {\n            cb();\n        }\n        /**\n         * Synchronous close. Doesn't do anything.\n         */\n        closeSync() {\n            // NOP.\n        }\n    }\n\n    return {\n        PreloadFile,\n        NoSyncFile\n    }\n});"]}