{"version":3,"sources":["generic/locked_fs.js"],"names":["define","Mutex","[object Object]","fs","this","_fs","_mu","getName","p","cb","diskSpace","isReadOnly","supportsLinks","supportsProps","supportsSynch","oldPath","newPath","lock","rename","err","unlock","isLocked","Error","renameSync","isLstat","stat","statSync","flag","mode","open","fd","openSync","unlink","unlinkSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","files","readdirSync","exists","existsSync","cache","realpath","resolvedPath","realpathSync","len","truncate","truncateSync","fname","encoding","readFile","data","readFileSync","writeFile","writeFileSync","appendFile","appendFileSync","isLchmod","chmod","chmodSync","isLchown","uid","gid","chown","chownSync","atime","mtime","utimes","utimesSync","srcpath","dstpath","link","linkSync","type","symlink","symlinkSync","readlink","linkString","readlinkSync"],"mappings":"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","file":"../../generic/locked_fs.js","sourcesContent":["define(['./mutex'], function (Mutex) {\n    'use strict';\n    /**\n     * This class serializes access to an underlying async filesystem.\n     * For example, on an OverlayFS instance with an async lower\n     * directory operations like rename and rmdir may involve multiple\n     * requests involving both the upper and lower filesystems -- they\n     * are not executed in a single atomic step.  OverlayFS uses this\n     * LockedFS to avoid having to reason about the correctness of\n     * multiple requests interleaving.\n     */\n    class LockedFS {\n        constructor(fs) {\n            this._fs = fs;\n            this._mu = new Mutex();\n        }\n        getName() {\n            return 'LockedFS<' + this._fs.getName() + '>';\n        }\n        getFSUnlocked() {\n            return this._fs;\n        }\n        diskSpace(p, cb) {\n            // FIXME: should this lock?\n            this._fs.diskSpace(p, cb);\n        }\n        isReadOnly() {\n            return this._fs.isReadOnly();\n        }\n        supportsLinks() {\n            return this._fs.supportsLinks();\n        }\n        supportsProps() {\n            return this._fs.supportsProps();\n        }\n        supportsSynch() {\n            return this._fs.supportsSynch();\n        }\n        rename(oldPath, newPath, cb) {\n            this._mu.lock(() => {\n                this._fs.rename(oldPath, newPath, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        renameSync(oldPath, newPath) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.renameSync(oldPath, newPath);\n        }\n        stat(p, isLstat, cb) {\n            this._mu.lock(() => {\n                this._fs.stat(p, isLstat, (err, stat) => {\n                    this._mu.unlock();\n                    cb(err, stat);\n                });\n            });\n        }\n        statSync(p, isLstat) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.statSync(p, isLstat);\n        }\n        open(p, flag, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.open(p, flag, mode, (err, fd) => {\n                    this._mu.unlock();\n                    cb(err, fd);\n                });\n            });\n        }\n        openSync(p, flag, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.openSync(p, flag, mode);\n        }\n        unlink(p, cb) {\n            this._mu.lock(() => {\n                this._fs.unlink(p, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        unlinkSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.unlinkSync(p);\n        }\n        rmdir(p, cb) {\n            this._mu.lock(() => {\n                this._fs.rmdir(p, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        rmdirSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.rmdirSync(p);\n        }\n        mkdir(p, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.mkdir(p, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        mkdirSync(p, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.mkdirSync(p, mode);\n        }\n        readdir(p, cb) {\n            this._mu.lock(() => {\n                this._fs.readdir(p, (err, files) => {\n                    this._mu.unlock();\n                    cb(err, files);\n                });\n            });\n        }\n        readdirSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.readdirSync(p);\n        }\n        exists(p, cb) {\n            this._mu.lock(() => {\n                this._fs.exists(p, (exists) => {\n                    this._mu.unlock();\n                    cb(exists);\n                });\n            });\n        }\n        existsSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.existsSync(p);\n        }\n        realpath(p, cache, cb) {\n            this._mu.lock(() => {\n                this._fs.realpath(p, cache, (err, resolvedPath) => {\n                    this._mu.unlock();\n                    cb(err, resolvedPath);\n                });\n            });\n        }\n        realpathSync(p, cache) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.realpathSync(p, cache);\n        }\n        truncate(p, len, cb) {\n            this._mu.lock(() => {\n                this._fs.truncate(p, len, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        truncateSync(p, len) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.truncateSync(p, len);\n        }\n        readFile(fname, encoding, flag, cb) {\n            this._mu.lock(() => {\n                this._fs.readFile(fname, encoding, flag, (err, data) => {\n                    this._mu.unlock();\n                    cb(err, data);\n                });\n            });\n        }\n        readFileSync(fname, encoding, flag) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.readFileSync(fname, encoding, flag);\n        }\n        writeFile(fname, data, encoding, flag, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.writeFile(fname, data, encoding, flag, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        writeFileSync(fname, data, encoding, flag, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.writeFileSync(fname, data, encoding, flag, mode);\n        }\n        appendFile(fname, data, encoding, flag, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.appendFile(fname, data, encoding, flag, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        appendFileSync(fname, data, encoding, flag, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.appendFileSync(fname, data, encoding, flag, mode);\n        }\n        chmod(p, isLchmod, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.chmod(p, isLchmod, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        chmodSync(p, isLchmod, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.chmodSync(p, isLchmod, mode);\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            this._mu.lock(() => {\n                this._fs.chown(p, isLchown, uid, gid, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        chownSync(p, isLchown, uid, gid) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.chownSync(p, isLchown, uid, gid);\n        }\n        utimes(p, atime, mtime, cb) {\n            this._mu.lock(() => {\n                this._fs.utimes(p, atime, mtime, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        utimesSync(p, atime, mtime) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.utimesSync(p, atime, mtime);\n        }\n        link(srcpath, dstpath, cb) {\n            this._mu.lock(() => {\n                this._fs.link(srcpath, dstpath, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        linkSync(srcpath, dstpath) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.linkSync(srcpath, dstpath);\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            this._mu.lock(() => {\n                this._fs.symlink(srcpath, dstpath, type, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        symlinkSync(srcpath, dstpath, type) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.symlinkSync(srcpath, dstpath, type);\n        }\n        readlink(p, cb) {\n            this._mu.lock(() => {\n                this._fs.readlink(p, (err, linkString) => {\n                    this._mu.unlock();\n                    cb(err, linkString);\n                });\n            });\n        }\n        readlinkSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.readlinkSync(p);\n        }\n    }\n\n    return LockedFS;\n});"]}