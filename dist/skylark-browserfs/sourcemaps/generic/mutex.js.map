{"version":3,"sources":["generic/mutex.js"],"names":["define","setImmediate","[object Object]","this","_locked","_waiters","cb","push","Error","next","shift"],"mappings":";;;;;;;AAAAA,QAAQ,2BAA4B,SAAUC,GAC1C,aA+CA,aAzCIC,cACIC,KAAKC,SAAU,EACfD,KAAKE,YAETH,KAAKI,GACGH,KAAKC,QACLD,KAAKE,SAASE,KAAKD,IAGvBH,KAAKC,SAAU,EACfE,KAEJJ,SACI,IAAKC,KAAKC,QACN,MAAM,IAAII,MAAM,gCAEpB,MAAMC,EAAON,KAAKE,SAASK,QAOvBD,EACAR,EAAaQ,GAGjBN,KAAKC,SAAU,EAEnBF,UACI,OAAIC,KAAKC,UAGTD,KAAKC,SAAU,GACR,GAEXF,WACI,OAAOC,KAAKC","file":"../../generic/mutex.js","sourcesContent":["define(['../generic/setImmediate'], function (setImmediate) {\n    'use strict';\n    /**\n     * Non-recursive mutex\n     * @hidden\n     */\n    class Mutex {\n        constructor() {\n            this._locked = false;\n            this._waiters = [];\n        }\n        lock(cb) {\n            if (this._locked) {\n                this._waiters.push(cb);\n                return;\n            }\n            this._locked = true;\n            cb();\n        }\n        unlock() {\n            if (!this._locked) {\n                throw new Error('unlock of a non-locked mutex');\n            }\n            const next = this._waiters.shift();\n            // don't unlock - we want to queue up next for the\n            // _end_ of the current task execution, but we don't\n            // want it to be called inline with whatever the\n            // current stack is.  This way we still get the nice\n            // behavior that an unlock immediately followed by a\n            // lock won't cause starvation.\n            if (next) {\n                setImmediate(next);\n                return;\n            }\n            this._locked = false;\n        }\n        tryLock() {\n            if (this._locked) {\n                return false;\n            }\n            this._locked = true;\n            return true;\n        }\n        isLocked() {\n            return this._locked;\n        }\n    }\n\n    return Mutex;\n});"]}