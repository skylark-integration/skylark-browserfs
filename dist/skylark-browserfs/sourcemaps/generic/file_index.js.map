{"version":3,"sources":["generic/file_index.js"],"names":["define","node_fs_stats","path","Stats","FileType","FileIndex","[object Object]","this","_index","addPath","DirInode","listing","idx","rootInode","queue","length","inode","next","pop","pwd","tree","parent","node","hasOwnProperty","children","name","push","FileInode","FILE","_ls","cb","dir","files","getListing","file","item","getItem","isFileInode","getData","Error","splitPath","_split_path","dirpath","itemname","undefined","addItem","isDirInode","itemNameMark","lastIndexOf","parentPath","substring","itemName","addPathFast","isDir","remItem","child","removePath","p","dirname","substr","data","DIRECTORY","Object","keys","isFile"],"mappings":"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","file":"../../generic/file_index.js","sourcesContent":["define([\n    '../core/node_fs_stats',\n    '../libs/path'\n], function (node_fs_stats, path) {\n    'use strict';\n\n    const {Stats, FileType }  = node_fs_stats;\n\n    /**\n     * A simple class for storing a filesystem index. Assumes that all paths passed\n     * to it are *absolute* paths.\n     *\n     * Can be used as a partial or a full index, although care must be taken if used\n     * for the former purpose, especially when directories are concerned.\n     */\n    class FileIndex {\n        /**\n         * Constructs a new FileIndex.\n         */\n        constructor() {\n            // _index is a single-level key,value store that maps *directory* paths to\n            // DirInodes. File information is only contained in DirInodes themselves.\n            this._index = {};\n            // Create the root directory.\n            this.addPath('/', new DirInode());\n        }\n        /**\n         * Static method for constructing indices from a JSON listing.\n         * @param listing Directory listing generated by tools/XHRIndexer.coffee\n         * @return A new FileIndex object.\n         */\n        static fromListing(listing) {\n            const idx = new FileIndex();\n            // Add a root DirNode.\n            const rootInode = new DirInode();\n            idx._index['/'] = rootInode;\n            const queue = [['', listing, rootInode]];\n            while (queue.length > 0) {\n                let inode;\n                const next = queue.pop();\n                const pwd = next[0];\n                const tree = next[1];\n                const parent = next[2];\n                for (const node in tree) {\n                    if (tree.hasOwnProperty(node)) {\n                        const children = tree[node];\n                        const name = `${pwd}/${node}`;\n                        if (children) {\n                            idx._index[name] = inode = new DirInode();\n                            queue.push([name, children, inode]);\n                        }\n                        else {\n                            // This inode doesn't have correct size information, noted with -1.\n                            inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));\n                        }\n                        if (parent) {\n                            parent._ls[node] = inode;\n                        }\n                    }\n                }\n            }\n            return idx;\n        }\n        /**\n         * Runs the given function over all files in the index.\n         */\n        fileIterator(cb) {\n            for (const path in this._index) {\n                if (this._index.hasOwnProperty(path)) {\n                    const dir = this._index[path];\n                    const files = dir.getListing();\n                    for (const file of files) {\n                        const item = dir.getItem(file);\n                        if (isFileInode(item)) {\n                            cb(item.getData());\n                        }\n                    }\n                }\n            }\n        }\n        /**\n         * Adds the given absolute path to the index if it is not already in the index.\n         * Creates any needed parent directories.\n         * @param path The path to add to the index.\n         * @param inode The inode for the\n         *   path to add.\n         * @return 'True' if it was added or already exists, 'false' if there\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\n         *   different).\n         * @todo If adding fails and implicitly creates directories, we do not clean up\n         *   the new empty directories.\n         */\n        addPath(path, inode) {\n            if (!inode) {\n                throw new Error('Inode must be specified');\n            }\n            if (path[0] !== '/') {\n                throw new Error('Path must be absolute, got: ' + path);\n            }\n            // Check if it already exists.\n            if (this._index.hasOwnProperty(path)) {\n                return this._index[path] === inode;\n            }\n            const splitPath = this._split_path(path);\n            const dirpath = splitPath[0];\n            const itemname = splitPath[1];\n            // Try to add to its parent directory first.\n            let parent = this._index[dirpath];\n            if (parent === undefined && path !== '/') {\n                // Create parent.\n                parent = new DirInode();\n                if (!this.addPath(dirpath, parent)) {\n                    return false;\n                }\n            }\n            // Add myself to my parent.\n            if (path !== '/') {\n                if (!parent.addItem(itemname, inode)) {\n                    return false;\n                }\n            }\n            // If I'm a directory, add myself to the index.\n            if (isDirInode(inode)) {\n                this._index[path] = inode;\n            }\n            return true;\n        }\n        /**\n         * Adds the given absolute path to the index if it is not already in the index.\n         * The path is added without special treatment (no joining of adjacent separators, etc).\n         * Creates any needed parent directories.\n         * @param path The path to add to the index.\n         * @param inode The inode for the\n         *   path to add.\n         * @return 'True' if it was added or already exists, 'false' if there\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\n         *   different).\n         * @todo If adding fails and implicitly creates directories, we do not clean up\n         *   the new empty directories.\n         */\n        addPathFast(path, inode) {\n            const itemNameMark = path.lastIndexOf('/');\n            const parentPath = itemNameMark === 0 ? \"/\" : path.substring(0, itemNameMark);\n            const itemName = path.substring(itemNameMark + 1);\n            // Try to add to its parent directory first.\n            let parent = this._index[parentPath];\n            if (parent === undefined) {\n                // Create parent.\n                parent = new DirInode();\n                this.addPathFast(parentPath, parent);\n            }\n            if (!parent.addItem(itemName, inode)) {\n                return false;\n            }\n            // If adding a directory, add to the index as well.\n            if (inode.isDir()) {\n                this._index[path] = inode;\n            }\n            return true;\n        }\n        /**\n         * Removes the given path. Can be a file or a directory.\n         * @return The removed item,\n         *   or null if it did not exist.\n         */\n        removePath(path) {\n            const splitPath = this._split_path(path);\n            const dirpath = splitPath[0];\n            const itemname = splitPath[1];\n            // Try to remove it from its parent directory first.\n            const parent = this._index[dirpath];\n            if (parent === undefined) {\n                return null;\n            }\n            // Remove myself from my parent.\n            const inode = parent.remItem(itemname);\n            if (inode === null) {\n                return null;\n            }\n            // If I'm a directory, remove myself from the index, and remove my children.\n            if (isDirInode(inode)) {\n                const children = inode.getListing();\n                for (const child of children) {\n                    this.removePath(path + '/' + child);\n                }\n                // Remove the directory from the index, unless it's the root.\n                if (path !== '/') {\n                    delete this._index[path];\n                }\n            }\n            return inode;\n        }\n        /**\n         * Retrieves the directory listing of the given path.\n         * @return An array of files in the given path, or 'null' if it does not exist.\n         */\n        ls(path) {\n            const item = this._index[path];\n            if (item === undefined) {\n                return null;\n            }\n            return item.getListing();\n        }\n        /**\n         * Returns the inode of the given item.\n         * @return Returns null if the item does not exist.\n         */\n        getInode(path) {\n            const splitPath = this._split_path(path);\n            const dirpath = splitPath[0];\n            const itemname = splitPath[1];\n            // Retrieve from its parent directory.\n            const parent = this._index[dirpath];\n            if (parent === undefined) {\n                return null;\n            }\n            // Root case\n            if (dirpath === path) {\n                return parent;\n            }\n            return parent.getItem(itemname);\n        }\n        /**\n         * Split into a (directory path, item name) pair\n         */\n        _split_path(p) {\n            const dirpath = path.dirname(p);\n            const itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\n            return [dirpath, itemname];\n        }\n    }\n    \n    /**\n     * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.\n     */\n    class FileInode {\n        constructor(data) {\n            this.data = data;\n        }\n        isFile() { return true; }\n        isDir() { return false; }\n        getData() { return this.data; }\n        setData(data) { this.data = data; }\n    }\n    /**\n     * Inode for a directory. Currently only contains the directory listing.\n     */\n    class DirInode {\n        /**\n         * Constructs an inode for a directory.\n         */\n        constructor(data = null) {\n            this.data = data;\n            this._ls = {};\n        }\n        isFile() {\n            return false;\n        }\n        isDir() {\n            return true;\n        }\n        getData() { return this.data; }\n        /**\n         * Return a Stats object for this inode.\n         * @todo Should probably remove this at some point. This isn't the\n         *       responsibility of the FileIndex.\n         */\n        getStats() {\n            return new Stats(FileType.DIRECTORY, 4096, 0x16D);\n        }\n        /**\n         * Returns the directory listing for this directory. Paths in the directory are\n         * relative to the directory's path.\n         * @return The directory listing for this directory.\n         */\n        getListing() {\n            return Object.keys(this._ls);\n        }\n        /**\n         * Returns the inode for the indicated item, or null if it does not exist.\n         * @param p Name of item in this directory.\n         */\n        getItem(p) {\n            const item = this._ls[p];\n            return item ? item : null;\n        }\n        /**\n         * Add the given item to the directory listing. Note that the given inode is\n         * not copied, and will be mutated by the DirInode if it is a DirInode.\n         * @param p Item name to add to the directory listing.\n         * @param inode The inode for the\n         *   item to add to the directory inode.\n         * @return True if it was added, false if it already existed.\n         */\n        addItem(p, inode) {\n            if (p in this._ls) {\n                return false;\n            }\n            this._ls[p] = inode;\n            return true;\n        }\n        /**\n         * Removes the given item from the directory listing.\n         * @param p Name of item to remove from the directory listing.\n         * @return Returns the item\n         *   removed, or null if the item did not exist.\n         */\n        remItem(p) {\n            const item = this._ls[p];\n            if (item === undefined) {\n                return null;\n            }\n            delete this._ls[p];\n            return item;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function isFileInode(inode) {\n        return !!inode && inode.isFile();\n    }\n    /**\n     * @hidden\n     */\n    function isDirInode(inode) {\n        return !!inode && inode.isDir();\n    }\n\n\n    return {\n        FileIndex: FileIndex,\n        FileInode: FileInode,\n        DirInode: DirInode,\n        isFileInode: isFileInode,\n        isDirInode: isDirInode\n    };\n});"]}