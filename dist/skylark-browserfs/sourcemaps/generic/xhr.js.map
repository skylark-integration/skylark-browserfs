{"version":3,"sources":["generic/xhr.js"],"names":["define","util","api_error","isIE","emptyBuffer","ApiError","ErrorCode","getFileSize","async","p","cb","req","XMLHttpRequest","open","onreadystatechange","e","readyState","status","EIO","parseInt","getResponseHeader","send","xhrIsAvailable","asyncDownloadFile","type","jsonSupported","responseType","EINVAL","response","Buffer","from","JSON","parse","responseText","syncDownloadFile","Blob","data","err","overrideMimeType","text","alloc","length","i","charCodeAt","getFileSizeSync","rv","size","getFileSizeAsync"],"mappings":"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","file":"../../generic/xhr.js","sourcesContent":["define([\n    '../core/util',\n    '../core/api_error'\n], function (util, api_error) {\n    'use strict';\n    /**\n     * Contains utility methods for performing a variety of tasks with\n     * XmlHttpRequest across browsers.\n     */\n    const { isIE, emptyBuffer } = util;\n    const { ApiError, ErrorCode } = api_error;\n\n    const xhrIsAvailable = (typeof (XMLHttpRequest) !== \"undefined\" && XMLHttpRequest !== null);\n    function asyncDownloadFileModern(p, type, cb) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, true);\n        let jsonSupported = true;\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // Some browsers don't support the JSON response type.\n                // They either reset responseType, or throw an exception.\n                // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js\n                try {\n                    req.responseType = 'json';\n                    jsonSupported = req.responseType === 'json';\n                }\n                catch (e) {\n                    jsonSupported = false;\n                }\n                break;\n            default:\n                return cb(new ApiError(ErrorCode.EINVAL, \"Invalid download type: \" + type));\n        }\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // XXX: WebKit-based browsers return *null* when XHRing an empty file.\n                            return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());\n                        case 'json':\n                            if (jsonSupported) {\n                                return cb(null, req.response);\n                            }\n                            else {\n                                return cb(null, JSON.parse(req.responseText));\n                            }\n                    }\n                }\n                else {\n                    return cb(new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    function syncDownloadFileModern(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        // On most platforms, we cannot set the responseType of synchronous downloads.\n        // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.\n        let data = null;\n        let err = null;\n        // Classic hack to download binary data as a string.\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // Convert the text into a buffer.\n                            const text = req.responseText;\n                            data = Buffer.alloc(text.length);\n                            // Throw away the upper bits of each character.\n                            for (let i = 0; i < text.length; i++) {\n                                // This will automatically throw away the upper bit of each\n                                // character for us.\n                                data[i] = text.charCodeAt(i);\n                            }\n                            return;\n                        case 'json':\n                            data = JSON.parse(req.responseText);\n                            return;\n                    }\n                }\n                else {\n                    err = new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`);\n                    return;\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    function syncDownloadFileIE10(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // IE10 does not support the JSON type.\n                break;\n            default:\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid download type: \" + type);\n        }\n        let data;\n        let err;\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            data = Buffer.from(req.response);\n                            break;\n                        case 'json':\n                            data = JSON.parse(req.response);\n                            break;\n                    }\n                }\n                else {\n                    err = new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`);\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    /**\n     * @hidden\n     */\n    function getFileSize(async, p, cb) {\n        const req = new XMLHttpRequest();\n        req.open('HEAD', p, async);\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    try {\n                        return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));\n                    }\n                    catch (e) {\n                        // In the event that the header isn't present or there is an error...\n                        return cb(new ApiError(ErrorCode.EIO, \"XHR HEAD error: Could not read content-length.\"));\n                    }\n                }\n                else {\n                    return cb(new ApiError(ErrorCode.EIO, `XHR HEAD error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    /**\n     * Asynchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let asyncDownloadFile = asyncDownloadFileModern;\n    /**\n     * Synchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;\n    /**\n     * Synchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeSync(p) {\n        let rv = -1;\n        getFileSize(false, p, function (err, size) {\n            if (err) {\n                throw err;\n            }\n            rv = size;\n        });\n        return rv;\n    }\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeAsync(p, cb) {\n        getFileSize(true, p, cb);\n    }\n\n\n\n    return {\n        xhrIsAvailable: xhrIsAvailable,\n        asyncDownloadFile: asyncDownloadFile,\n        syncDownloadFile: syncDownloadFile,\n        getFileSizeSync: getFileSizeSync,\n        getFileSizeAsync: getFileSizeAsync\n    };\n});"]}