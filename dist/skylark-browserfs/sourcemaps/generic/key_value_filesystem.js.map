{"version":3,"sources":["generic/key_value_filesystem.js"],"names":["define","file_system","api_error","node_fs_stats","path","Inode","preload_file","util","BaseFileSystem","SynchronousFileSystem","ApiError","ErrorCode","FileType","emptyBuffer","PreloadFile","ROOT_NODE_ID","emptyDirNode","getEmptyDirNode","Buffer","from","GenerateRandomID","replace","c","r","Math","random","toString","noError","e","cb","noErrorTx","tx","abort","LRUNode","[object Object]","key","value","this","prev","next","LRUCache","limit","size","map","head","tail","node","remove","setHead","SyncKeyValueFile","_fs","_path","_flag","_stat","contents","super","isDirty","_syncSync","getPath","getBuffer","getStats","resetDirty","syncSync","AsyncKeyValueFile","_sync","sync","SimpleSyncRWTransaction","store","originalData","modifiedKeys","val","get","stashOldValue","data","overwrite","markModified","put","del","hasOwnProperty","indexOf","push","SyncKeyValueFileSystem","options","makeRootDirectory","name","clear","oldPath","newPath","beginTransaction","oldParent","dirname","oldName","basename","newParent","newName","oldDirNode","findINode","oldDirList","getDirListing","ENOENT","nodeId","EBUSY","newDirNode","newDirList","newNameNode","getINode","isFile","EPERM","id","JSON","stringify","commit","p","isLstat","toStats","flag","mode","newFile","commitNewFile","FILE","undefined","removeEntry","readdirSync","length","ENOTEMPTY","DIRECTORY","Object","keys","stats","fileInodeId","_findINode","fileInode","inodeChanged","update","toBuffer","currTime","Date","getTime","dirInode","parent","filename","readDirectory","inode","dirList","resolve","sep","fromBuffer","isDirectory","ENOTDIR","parse","currId","EIO","type","parentDir","fname","parentNode","dirListing","EEXIST","fileNode","dataId","addNewNode","fileNodeId","isDir","parentListing","fileName","EISDIR","AsyncKeyValueFileSystem","cacheSize","_cache","removeAll","oldCb","inodes","lists","errorOccurred","theOleSwitcharoo","oldParentList","oldParentINode","newParentList","newParentINode","fileId","completeRename","processInodeAndListings","findINodeAndDirListing","readdir","err","files","join","handleDirectoryListings","set","listing","retries","reroll","committed"],"mappings":"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","file":"../../generic/key_value_filesystem.js","sourcesContent":["define([\n    '../core/file_system',\n    '../core/api_error',\n    '../core/node_fs_stats',\n    '../libs/path',\n    '../generic/inode',\n    '../generic/preload_file',\n    '../core/util'\n], function (file_system, api_error, node_fs_stats, path, Inode, preload_file, util) {\n    'use strict';\n\n    const { BaseFileSystem, SynchronousFileSystem } = file_system;\n    const { ApiError, ErrorCode } = api_error;\n    const { FileType } = node_fs_stats;\n    const { emptyBuffer } = util;\n    const { PreloadFile} = preload_file;\n\n\n    /**\n     * @hidden\n     */\n    const ROOT_NODE_ID = \"/\";\n    /**\n     * @hidden\n     */\n    let emptyDirNode = null;\n    /**\n     * Returns an empty directory node.\n     * @hidden\n     */\n    function getEmptyDirNode() {\n        if (emptyDirNode) {\n            return emptyDirNode;\n        }\n        return emptyDirNode = Buffer.from(\"{}\");\n    }\n    /**\n     * Generates a random ID.\n     * @hidden\n     */\n    function GenerateRandomID() {\n        // From http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n    /**\n     * Helper function. Checks if 'e' is defined. If so, it triggers the callback\n     * with 'e' and returns false. Otherwise, returns true.\n     * @hidden\n     */\n    function noError(e, cb) {\n        if (e) {\n            cb(e);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,\n     * triggers the callback with 'e', and returns false. Otherwise, returns true.\n     * @hidden\n     */\n    function noErrorTx(e, tx, cb) {\n        if (e) {\n            tx.abort(() => {\n                cb(e);\n            });\n            return false;\n        }\n        return true;\n    }\n    class LRUNode {\n        constructor(key, value) {\n            this.key = key;\n            this.value = value;\n            this.prev = null;\n            this.next = null;\n        }\n    }\n    // Adapted from https://chrisrng.svbtle.com/lru-cache-in-javascript\n    class LRUCache {\n        constructor(limit) {\n            this.limit = limit;\n            this.size = 0;\n            this.map = {};\n            this.head = null;\n            this.tail = null;\n        }\n        /**\n         * Change or add a new value in the cache\n         * We overwrite the entry if it already exists\n         */\n        set(key, value) {\n            const node = new LRUNode(key, value);\n            if (this.map[key]) {\n                this.map[key].value = node.value;\n                this.remove(node.key);\n            }\n            else {\n                if (this.size >= this.limit) {\n                    delete this.map[this.tail.key];\n                    this.size--;\n                    this.tail = this.tail.prev;\n                    this.tail.next = null;\n                }\n            }\n            this.setHead(node);\n        }\n        /* Retrieve a single entry from the cache */\n        get(key) {\n            if (this.map[key]) {\n                const value = this.map[key].value;\n                const node = new LRUNode(key, value);\n                this.remove(key);\n                this.setHead(node);\n                return value;\n            }\n            else {\n                return null;\n            }\n        }\n        /* Remove a single entry from the cache */\n        remove(key) {\n            const node = this.map[key];\n            if (!node) {\n                return;\n            }\n            if (node.prev !== null) {\n                node.prev.next = node.next;\n            }\n            else {\n                this.head = node.next;\n            }\n            if (node.next !== null) {\n                node.next.prev = node.prev;\n            }\n            else {\n                this.tail = node.prev;\n            }\n            delete this.map[key];\n            this.size--;\n        }\n        /* Resets the entire cache - Argument limit is optional to be reset */\n        removeAll() {\n            this.size = 0;\n            this.map = {};\n            this.head = null;\n            this.tail = null;\n        }\n        setHead(node) {\n            node.next = this.head;\n            node.prev = null;\n            if (this.head !== null) {\n                this.head.prev = node;\n            }\n            this.head = node;\n            if (this.tail === null) {\n                this.tail = node;\n            }\n            this.size++;\n            this.map[node.key] = node;\n        }\n    }\n    /**\n     * A simple RW transaction for simple synchronous key-value stores.\n     */\n    class SimpleSyncRWTransaction {\n        constructor(store) {\n            this.store = store;\n            /**\n             * Stores data in the keys we modify prior to modifying them.\n             * Allows us to roll back commits.\n             */\n            this.originalData = {};\n            /**\n             * List of keys modified in this transaction, if any.\n             */\n            this.modifiedKeys = [];\n        }\n        get(key) {\n            const val = this.store.get(key);\n            this.stashOldValue(key, val);\n            return val;\n        }\n        put(key, data, overwrite) {\n            this.markModified(key);\n            return this.store.put(key, data, overwrite);\n        }\n        del(key) {\n            this.markModified(key);\n            this.store.del(key);\n        }\n        commit() { }\n        abort() {\n            // Rollback old values.\n            for (const key of this.modifiedKeys) {\n                const value = this.originalData[key];\n                if (!value) {\n                    // Key didn't exist.\n                    this.store.del(key);\n                }\n                else {\n                    // Key existed. Store old value.\n                    this.store.put(key, value, true);\n                }\n            }\n        }\n        /**\n         * Stashes given key value pair into `originalData` if it doesn't already\n         * exist. Allows us to stash values the program is requesting anyway to\n         * prevent needless `get` requests if the program modifies the data later\n         * on during the transaction.\n         */\n        stashOldValue(key, value) {\n            // Keep only the earliest value in the transaction.\n            if (!this.originalData.hasOwnProperty(key)) {\n                this.originalData[key] = value;\n            }\n        }\n        /**\n         * Marks the given key as modified, and stashes its value if it has not been\n         * stashed already.\n         */\n        markModified(key) {\n            if (this.modifiedKeys.indexOf(key) === -1) {\n                this.modifiedKeys.push(key);\n                if (!this.originalData.hasOwnProperty(key)) {\n                    this.originalData[key] = this.store.get(key);\n                }\n            }\n        }\n    }\n    class SyncKeyValueFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        syncSync() {\n            if (this.isDirty()) {\n                this._fs._syncSync(this.getPath(), this.getBuffer(), this.getStats());\n                this.resetDirty();\n            }\n        }\n        closeSync() {\n            this.syncSync();\n        }\n    }\n    /**\n     * A \"Synchronous key-value file system\". Stores data to/retrieves data from an\n     * underlying key-value store.\n     *\n     * We use a unique ID for each node in the file system. The root node has a\n     * fixed ID.\n     * @todo Introduce Node ID caching.\n     * @todo Check modes.\n     */\n    class SyncKeyValueFileSystem extends SynchronousFileSystem {\n        static isAvailable() { return true; }\n        constructor(options) {\n            super();\n            this.store = options.store;\n            // INVARIANT: Ensure that the root exists.\n            this.makeRootDirectory();\n        }\n        getName() { return this.store.name(); }\n        isReadOnly() { return false; }\n        supportsSymlinks() { return false; }\n        supportsProps() { return false; }\n        supportsSynch() { return true; }\n        /**\n         * Delete all contents stored in the file system.\n         */\n        empty() {\n            this.store.clear();\n            // INVARIANT: Root always exists.\n            this.makeRootDirectory();\n        }\n        renameSync(oldPath, newPath) {\n            const tx = this.store.beginTransaction('readwrite'), oldParent = path.dirname(oldPath), oldName = path.basename(oldPath), newParent = path.dirname(newPath), newName = path.basename(newPath), \n            // Remove oldPath from parent's directory listing.\n            oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);\n            if (!oldDirList[oldName]) {\n                throw ApiError.ENOENT(oldPath);\n            }\n            const nodeId = oldDirList[oldName];\n            delete oldDirList[oldName];\n            // Invariant: Can't move a folder inside itself.\n            // This funny little hack ensures that the check passes only if oldPath\n            // is a subpath of newParent. We append '/' to avoid matching folders that\n            // are a substring of the bottom-most folder in the path.\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\n                throw new ApiError(ErrorCode.EBUSY, oldParent);\n            }\n            // Add newPath to parent's directory listing.\n            let newDirNode, newDirList;\n            if (newParent === oldParent) {\n                // Prevent us from re-grabbing the same directory listing, which still\n                // contains oldName.\n                newDirNode = oldDirNode;\n                newDirList = oldDirList;\n            }\n            else {\n                newDirNode = this.findINode(tx, newParent);\n                newDirList = this.getDirListing(tx, newParent, newDirNode);\n            }\n            if (newDirList[newName]) {\n                // If it's a file, delete it.\n                const newNameNode = this.getINode(tx, newPath, newDirList[newName]);\n                if (newNameNode.isFile()) {\n                    try {\n                        tx.del(newNameNode.id);\n                        tx.del(newDirList[newName]);\n                    }\n                    catch (e) {\n                        tx.abort();\n                        throw e;\n                    }\n                }\n                else {\n                    // If it's a directory, throw a permissions error.\n                    throw ApiError.EPERM(newPath);\n                }\n            }\n            newDirList[newName] = nodeId;\n            // Commit the two changed directory listings.\n            try {\n                tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);\n                tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n        }\n        statSync(p, isLstat) {\n            // Get the inode to the item, convert it into a Stats object.\n            return this.findINode(this.store.beginTransaction('readonly'), p).toStats();\n        }\n        createFileSync(p, flag, mode) {\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);\n            // Open the file.\n            return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);\n        }\n        openFileSync(p, flag) {\n            const tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);\n            if (data === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return new SyncKeyValueFile(this, p, flag, node.toStats(), data);\n        }\n        unlinkSync(p) {\n            this.removeEntry(p, false);\n        }\n        rmdirSync(p) {\n            // Check first if directory is empty.\n            if (this.readdirSync(p).length > 0) {\n                throw ApiError.ENOTEMPTY(p);\n            }\n            else {\n                this.removeEntry(p, true);\n            }\n        }\n        mkdirSync(p, mode) {\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);\n        }\n        readdirSync(p) {\n            const tx = this.store.beginTransaction('readonly');\n            return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));\n        }\n        _syncSync(p, data, stats) {\n            // @todo Ensure mtime updates properly, and use that to determine if a data\n            //       update is required.\n            const tx = this.store.beginTransaction('readwrite'), \n            // We use the _findInode helper because we actually need the INode id.\n            fileInodeId = this._findINode(tx, path.dirname(p), path.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);\n            try {\n                // Sync data.\n                tx.put(fileInode.id, data, true);\n                // Sync metadata.\n                if (inodeChanged) {\n                    tx.put(fileInodeId, fileInode.toBuffer(), true);\n                }\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n        }\n        /**\n         * Checks if the root directory exists. Creates it if it doesn't.\n         */\n        makeRootDirectory() {\n            const tx = this.store.beginTransaction('readwrite');\n            if (tx.get(ROOT_NODE_ID) === undefined) {\n                // Create new inode.\n                const currTime = (new Date()).getTime(), \n                // Mode 0666\n                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\n                // If the root doesn't exist, the first random ID shouldn't exist,\n                // either.\n                tx.put(dirInode.id, getEmptyDirNode(), false);\n                tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);\n                tx.commit();\n            }\n        }\n        /**\n         * Helper function for findINode.\n         * @param parent The parent directory of the file we are attempting to find.\n         * @param filename The filename of the inode we are attempting to find, minus\n         *   the parent.\n         * @return string The ID of the file's inode in the file system.\n         */\n        _findINode(tx, parent, filename) {\n            const readDirectory = (inode) => {\n                // Get the root's directory listing.\n                const dirList = this.getDirListing(tx, parent, inode);\n                // Get the file's ID.\n                if (dirList[filename]) {\n                    return dirList[filename];\n                }\n                else {\n                    throw ApiError.ENOENT(path.resolve(parent, filename));\n                }\n            };\n            if (parent === '/') {\n                if (filename === '') {\n                    // BASE CASE #1: Return the root's ID.\n                    return ROOT_NODE_ID;\n                }\n                else {\n                    // BASE CASE #2: Find the item in the root ndoe.\n                    return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));\n                }\n            }\n            else {\n                return readDirectory(this.getINode(tx, parent + path.sep + filename, this._findINode(tx, path.dirname(parent), path.basename(parent))));\n            }\n        }\n        /**\n         * Finds the Inode of the given path.\n         * @param p The path to look up.\n         * @return The Inode of the path p.\n         * @todo memoize/cache\n         */\n        findINode(tx, p) {\n            return this.getINode(tx, p, this._findINode(tx, path.dirname(p), path.basename(p)));\n        }\n        /**\n         * Given the ID of a node, retrieves the corresponding Inode.\n         * @param tx The transaction to use.\n         * @param p The corresponding path to the file (used for error messages).\n         * @param id The ID to look up.\n         */\n        getINode(tx, p, id) {\n            const inode = tx.get(id);\n            if (inode === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return Inode.fromBuffer(inode);\n        }\n        /**\n         * Given the Inode of a directory, retrieves the corresponding directory\n         * listing.\n         */\n        getDirListing(tx, p, inode) {\n            if (!inode.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n            const data = tx.get(inode.id);\n            if (data === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return JSON.parse(data.toString());\n        }\n        /**\n         * Creates a new node under a random ID. Retries 5 times before giving up in\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\n         * @return The GUID that the data was stored under.\n         */\n        addNewNode(tx, data) {\n            const retries = 0;\n            let currId;\n            while (retries < 5) {\n                try {\n                    currId = GenerateRandomID();\n                    tx.put(currId, data, false);\n                    return currId;\n                }\n                catch (e) {\n                    // Ignore and reroll.\n                }\n            }\n            throw new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.');\n        }\n        /**\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\n         * the given mode.\n         * Note: This will commit the transaction.\n         * @param p The path to the new file.\n         * @param type The type of the new file.\n         * @param mode The mode to create the new file with.\n         * @param data The data to store at the file's data node.\n         * @return The Inode for the new file.\n         */\n        commitNewFile(tx, p, type, mode, data) {\n            const parentDir = path.dirname(p), fname = path.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();\n            // Invariant: The root always exists.\n            // If we don't check this prior to taking steps below, we will create a\n            // file with name '' in root should p == '/'.\n            if (p === '/') {\n                throw ApiError.EEXIST(p);\n            }\n            // Check if file already exists.\n            if (dirListing[fname]) {\n                throw ApiError.EEXIST(p);\n            }\n            let fileNode;\n            try {\n                // Commit data.\n                const dataId = this.addNewNode(tx, data);\n                fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\n                // Commit file node.\n                const fileNodeId = this.addNewNode(tx, fileNode.toBuffer());\n                // Update and commit parent directory listing.\n                dirListing[fname] = fileNodeId;\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n            return fileNode;\n        }\n        /**\n         * Remove all traces of the given path from the file system.\n         * @param p The path to remove from the file system.\n         * @param isDir Does the path belong to a directory, or a file?\n         * @todo Update mtime.\n         */\n        removeEntry(p, isDir) {\n            const tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = path.basename(p);\n            if (!parentListing[fileName]) {\n                throw ApiError.ENOENT(p);\n            }\n            // Remove from directory listing of parent.\n            const fileNodeId = parentListing[fileName];\n            delete parentListing[fileName];\n            // Get file inode.\n            const fileNode = this.getINode(tx, p, fileNodeId);\n            if (!isDir && fileNode.isDirectory()) {\n                throw ApiError.EISDIR(p);\n            }\n            else if (isDir && !fileNode.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n            try {\n                // Delete data.\n                tx.del(fileNode.id);\n                // Delete node.\n                tx.del(fileNodeId);\n                // Update directory listing.\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            // Success.\n            tx.commit();\n        }\n    }\n    class AsyncKeyValueFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        sync(cb) {\n            if (this.isDirty()) {\n                this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), (e) => {\n                    if (!e) {\n                        this.resetDirty();\n                    }\n                    cb(e);\n                });\n            }\n            else {\n                cb();\n            }\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n    }\n    /**\n     * An \"Asynchronous key-value file system\". Stores data to/retrieves data from\n     * an underlying asynchronous key-value store.\n     */\n    class AsyncKeyValueFileSystem extends BaseFileSystem {\n        constructor(cacheSize) {\n            super();\n            this._cache = null;\n            if (cacheSize > 0) {\n                this._cache = new LRUCache(cacheSize);\n            }\n        }\n        static isAvailable() { return true; }\n        /**\n         * Initializes the file system. Typically called by subclasses' async\n         * constructors.\n         */\n        init(store, cb) {\n            this.store = store;\n            // INVARIANT: Ensure that the root exists.\n            this.makeRootDirectory(cb);\n        }\n        getName() { return this.store.name(); }\n        isReadOnly() { return false; }\n        supportsSymlinks() { return false; }\n        supportsProps() { return false; }\n        supportsSynch() { return false; }\n        /**\n         * Delete all contents stored in the file system.\n         */\n        empty(cb) {\n            if (this._cache) {\n                this._cache.removeAll();\n            }\n            this.store.clear((e) => {\n                if (noError(e, cb)) {\n                    // INVARIANT: Root always exists.\n                    this.makeRootDirectory(cb);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            // TODO: Make rename compatible with the cache.\n            if (this._cache) {\n                // Clear and disable cache during renaming process.\n                const c = this._cache;\n                this._cache = null;\n                c.removeAll();\n                const oldCb = cb;\n                cb = (e) => {\n                    // Restore empty cache.\n                    this._cache = c;\n                    oldCb(e);\n                };\n            }\n            const tx = this.store.beginTransaction('readwrite');\n            const oldParent = path.dirname(oldPath), oldName = path.basename(oldPath);\n            const newParent = path.dirname(newPath), newName = path.basename(newPath);\n            const inodes = {};\n            const lists = {};\n            let errorOccurred = false;\n            // Invariant: Can't move a folder inside itself.\n            // This funny little hack ensures that the check passes only if oldPath\n            // is a subpath of newParent. We append '/' to avoid matching folders that\n            // are a substring of the bottom-most folder in the path.\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\n                return cb(new ApiError(ErrorCode.EBUSY, oldParent));\n            }\n            /**\n             * Responsible for Phase 2 of the rename operation: Modifying and\n             * committing the directory listings. Called once we have successfully\n             * retrieved both the old and new parent's inodes and listings.\n             */\n            const theOleSwitcharoo = () => {\n                // Sanity check: Ensure both paths are present, and no error has occurred.\n                if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {\n                    return;\n                }\n                const oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];\n                // Delete file from old parent.\n                if (!oldParentList[oldName]) {\n                    cb(ApiError.ENOENT(oldPath));\n                }\n                else {\n                    const fileId = oldParentList[oldName];\n                    delete oldParentList[oldName];\n                    // Finishes off the renaming process by adding the file to the new\n                    // parent.\n                    const completeRename = () => {\n                        newParentList[newName] = fileId;\n                        // Commit old parent's list.\n                        tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, (e) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (oldParent === newParent) {\n                                    // DONE!\n                                    tx.commit(cb);\n                                }\n                                else {\n                                    // Commit new parent's list.\n                                    tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, (e) => {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            tx.commit(cb);\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    };\n                    if (newParentList[newName]) {\n                        // 'newPath' already exists. Check if it's a file or a directory, and\n                        // act accordingly.\n                        this.getINode(tx, newPath, newParentList[newName], (e, inode) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (inode.isFile()) {\n                                    // Delete the file and continue.\n                                    tx.del(inode.id, (e) => {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            tx.del(newParentList[newName], (e) => {\n                                                if (noErrorTx(e, tx, cb)) {\n                                                    completeRename();\n                                                }\n                                            });\n                                        }\n                                    });\n                                }\n                                else {\n                                    // Can't overwrite a directory using rename.\n                                    tx.abort((e) => {\n                                        cb(ApiError.EPERM(newPath));\n                                    });\n                                }\n                            }\n                        });\n                    }\n                    else {\n                        completeRename();\n                    }\n                }\n            };\n            /**\n             * Grabs a path's inode and directory listing, and shoves it into the\n             * inodes and lists hashes.\n             */\n            const processInodeAndListings = (p) => {\n                this.findINodeAndDirListing(tx, p, (e, node, dirList) => {\n                    if (e) {\n                        if (!errorOccurred) {\n                            errorOccurred = true;\n                            tx.abort(() => {\n                                cb(e);\n                            });\n                        }\n                        // If error has occurred already, just stop here.\n                    }\n                    else {\n                        inodes[p] = node;\n                        lists[p] = dirList;\n                        theOleSwitcharoo();\n                    }\n                });\n            };\n            processInodeAndListings(oldParent);\n            if (oldParent !== newParent) {\n                processInodeAndListings(newParent);\n            }\n        }\n        stat(p, isLstat, cb) {\n            const tx = this.store.beginTransaction('readonly');\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    cb(null, inode.toStats());\n                }\n            });\n        }\n        createFile(p, flag, mode, cb) {\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();\n            this.commitNewFile(tx, p, FileType.FILE, mode, data, (e, newFile) => {\n                if (noError(e, cb)) {\n                    cb(null, new AsyncKeyValueFile(this, p, flag, newFile.toStats(), data));\n                }\n            });\n        }\n        openFile(p, flag, cb) {\n            const tx = this.store.beginTransaction('readonly');\n            // Step 1: Grab the file's inode.\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    // Step 2: Grab the file's data.\n                    tx.get(inode.id, (e, data) => {\n                        if (noError(e, cb)) {\n                            if (data === undefined) {\n                                cb(ApiError.ENOENT(p));\n                            }\n                            else {\n                                cb(null, new AsyncKeyValueFile(this, p, flag, inode.toStats(), data));\n                            }\n                        }\n                    });\n                }\n            });\n        }\n        unlink(p, cb) {\n            this.removeEntry(p, false, cb);\n        }\n        rmdir(p, cb) {\n            // Check first if directory is empty.\n            this.readdir(p, (err, files) => {\n                if (err) {\n                    cb(err);\n                }\n                else if (files.length > 0) {\n                    cb(ApiError.ENOTEMPTY(p));\n                }\n                else {\n                    this.removeEntry(p, true, cb);\n                }\n            });\n        }\n        mkdir(p, mode, cb) {\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);\n        }\n        readdir(p, cb) {\n            const tx = this.store.beginTransaction('readonly');\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    this.getDirListing(tx, p, inode, (e, dirListing) => {\n                        if (noError(e, cb)) {\n                            cb(null, Object.keys(dirListing));\n                        }\n                    });\n                }\n            });\n        }\n        _sync(p, data, stats, cb) {\n            // @todo Ensure mtime updates properly, and use that to determine if a data\n            //       update is required.\n            const tx = this.store.beginTransaction('readwrite');\n            // Step 1: Get the file node's ID.\n            this._findINode(tx, path.dirname(p), path.basename(p), (e, fileInodeId) => {\n                if (noErrorTx(e, tx, cb)) {\n                    // Step 2: Get the file inode.\n                    this.getINode(tx, p, fileInodeId, (e, fileInode) => {\n                        if (noErrorTx(e, tx, cb)) {\n                            const inodeChanged = fileInode.update(stats);\n                            // Step 3: Sync the data.\n                            tx.put(fileInode.id, data, true, (e) => {\n                                if (noErrorTx(e, tx, cb)) {\n                                    // Step 4: Sync the metadata (if it changed)!\n                                    if (inodeChanged) {\n                                        tx.put(fileInodeId, fileInode.toBuffer(), true, (e) => {\n                                            if (noErrorTx(e, tx, cb)) {\n                                                tx.commit(cb);\n                                            }\n                                        });\n                                    }\n                                    else {\n                                        // No need to sync metadata; return.\n                                        tx.commit(cb);\n                                    }\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Checks if the root directory exists. Creates it if it doesn't.\n         */\n        makeRootDirectory(cb) {\n            const tx = this.store.beginTransaction('readwrite');\n            tx.get(ROOT_NODE_ID, (e, data) => {\n                if (e || data === undefined) {\n                    // Create new inode.\n                    const currTime = (new Date()).getTime(), \n                    // Mode 0666\n                    dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\n                    // If the root doesn't exist, the first random ID shouldn't exist,\n                    // either.\n                    tx.put(dirInode.id, getEmptyDirNode(), false, (e) => {\n                        if (noErrorTx(e, tx, cb)) {\n                            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, (e) => {\n                                if (e) {\n                                    tx.abort(() => { cb(e); });\n                                }\n                                else {\n                                    tx.commit(cb);\n                                }\n                            });\n                        }\n                    });\n                }\n                else {\n                    // We're good.\n                    tx.commit(cb);\n                }\n            });\n        }\n        /**\n         * Helper function for findINode.\n         * @param parent The parent directory of the file we are attempting to find.\n         * @param filename The filename of the inode we are attempting to find, minus\n         *   the parent.\n         * @param cb Passed an error or the ID of the file's inode in the file system.\n         */\n        _findINode(tx, parent, filename, cb) {\n            if (this._cache) {\n                const id = this._cache.get(path.join(parent, filename));\n                if (id) {\n                    return cb(null, id);\n                }\n            }\n            const handleDirectoryListings = (e, inode, dirList) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (dirList[filename]) {\n                    const id = dirList[filename];\n                    if (this._cache) {\n                        this._cache.set(path.join(parent, filename), id);\n                    }\n                    cb(null, id);\n                }\n                else {\n                    cb(ApiError.ENOENT(path.resolve(parent, filename)));\n                }\n            };\n            if (parent === '/') {\n                if (filename === '') {\n                    // BASE CASE #1: Return the root's ID.\n                    if (this._cache) {\n                        this._cache.set(path.join(parent, filename), ROOT_NODE_ID);\n                    }\n                    cb(null, ROOT_NODE_ID);\n                }\n                else {\n                    // BASE CASE #2: Find the item in the root node.\n                    this.getINode(tx, parent, ROOT_NODE_ID, (e, inode) => {\n                        if (noError(e, cb)) {\n                            this.getDirListing(tx, parent, inode, (e, dirList) => {\n                                // handle_directory_listings will handle e for us.\n                                handleDirectoryListings(e, inode, dirList);\n                            });\n                        }\n                    });\n                }\n            }\n            else {\n                // Get the parent directory's INode, and find the file in its directory\n                // listing.\n                this.findINodeAndDirListing(tx, parent, handleDirectoryListings);\n            }\n        }\n        /**\n         * Finds the Inode of the given path.\n         * @param p The path to look up.\n         * @param cb Passed an error or the Inode of the path p.\n         * @todo memoize/cache\n         */\n        findINode(tx, p, cb) {\n            this._findINode(tx, path.dirname(p), path.basename(p), (e, id) => {\n                if (noError(e, cb)) {\n                    this.getINode(tx, p, id, cb);\n                }\n            });\n        }\n        /**\n         * Given the ID of a node, retrieves the corresponding Inode.\n         * @param tx The transaction to use.\n         * @param p The corresponding path to the file (used for error messages).\n         * @param id The ID to look up.\n         * @param cb Passed an error or the inode under the given id.\n         */\n        getINode(tx, p, id, cb) {\n            tx.get(id, (e, data) => {\n                if (noError(e, cb)) {\n                    if (data === undefined) {\n                        cb(ApiError.ENOENT(p));\n                    }\n                    else {\n                        cb(null, Inode.fromBuffer(data));\n                    }\n                }\n            });\n        }\n        /**\n         * Given the Inode of a directory, retrieves the corresponding directory\n         * listing.\n         */\n        getDirListing(tx, p, inode, cb) {\n            if (!inode.isDirectory()) {\n                cb(ApiError.ENOTDIR(p));\n            }\n            else {\n                tx.get(inode.id, (e, data) => {\n                    if (noError(e, cb)) {\n                        try {\n                            cb(null, JSON.parse(data.toString()));\n                        }\n                        catch (e) {\n                            // Occurs when data is undefined, or corresponds to something other\n                            // than a directory listing. The latter should never occur unless\n                            // the file system is corrupted.\n                            cb(ApiError.ENOENT(p));\n                        }\n                    }\n                });\n            }\n        }\n        /**\n         * Given a path to a directory, retrieves the corresponding INode and\n         * directory listing.\n         */\n        findINodeAndDirListing(tx, p, cb) {\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    this.getDirListing(tx, p, inode, (e, listing) => {\n                        if (noError(e, cb)) {\n                            cb(null, inode, listing);\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Adds a new node under a random ID. Retries 5 times before giving up in\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\n         * @param cb Passed an error or the GUID that the data was stored under.\n         */\n        addNewNode(tx, data, cb) {\n            let retries = 0, currId;\n            const reroll = () => {\n                if (++retries === 5) {\n                    // Max retries hit. Return with an error.\n                    cb(new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.'));\n                }\n                else {\n                    // Try again.\n                    currId = GenerateRandomID();\n                    tx.put(currId, data, false, (e, committed) => {\n                        if (e || !committed) {\n                            reroll();\n                        }\n                        else {\n                            // Successfully stored under 'currId'.\n                            cb(null, currId);\n                        }\n                    });\n                }\n            };\n            reroll();\n        }\n        /**\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\n         * the given mode.\n         * Note: This will commit the transaction.\n         * @param p The path to the new file.\n         * @param type The type of the new file.\n         * @param mode The mode to create the new file with.\n         * @param data The data to store at the file's data node.\n         * @param cb Passed an error or the Inode for the new file.\n         */\n        commitNewFile(tx, p, type, mode, data, cb) {\n            const parentDir = path.dirname(p), fname = path.basename(p), currTime = (new Date()).getTime();\n            // Invariant: The root always exists.\n            // If we don't check this prior to taking steps below, we will create a\n            // file with name '' in root should p == '/'.\n            if (p === '/') {\n                return cb(ApiError.EEXIST(p));\n            }\n            // Let's build a pyramid of code!\n            // Step 1: Get the parent directory's inode and directory listing\n            this.findINodeAndDirListing(tx, parentDir, (e, parentNode, dirListing) => {\n                if (noErrorTx(e, tx, cb)) {\n                    if (dirListing[fname]) {\n                        // File already exists.\n                        tx.abort(() => {\n                            cb(ApiError.EEXIST(p));\n                        });\n                    }\n                    else {\n                        // Step 2: Commit data to store.\n                        this.addNewNode(tx, data, (e, dataId) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                // Step 3: Commit the file's inode to the store.\n                                const fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\n                                this.addNewNode(tx, fileInode.toBuffer(), (e, fileInodeId) => {\n                                    if (noErrorTx(e, tx, cb)) {\n                                        // Step 4: Update parent directory's listing.\n                                        dirListing[fname] = fileInodeId;\n                                        tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, (e) => {\n                                            if (noErrorTx(e, tx, cb)) {\n                                                // Step 5: Commit and return the new inode.\n                                                tx.commit((e) => {\n                                                    if (noErrorTx(e, tx, cb)) {\n                                                        cb(null, fileInode);\n                                                    }\n                                                });\n                                            }\n                                        });\n                                    }\n                                });\n                            }\n                        });\n                    }\n                }\n            });\n        }\n        /**\n         * Remove all traces of the given path from the file system.\n         * @param p The path to remove from the file system.\n         * @param isDir Does the path belong to a directory, or a file?\n         * @todo Update mtime.\n         */\n        removeEntry(p, isDir, cb) {\n            // Eagerly delete from cache (harmless even if removal fails)\n            if (this._cache) {\n                this._cache.remove(p);\n            }\n            const tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), fileName = path.basename(p);\n            // Step 1: Get parent directory's node and directory listing.\n            this.findINodeAndDirListing(tx, parent, (e, parentNode, parentListing) => {\n                if (noErrorTx(e, tx, cb)) {\n                    if (!parentListing[fileName]) {\n                        tx.abort(() => {\n                            cb(ApiError.ENOENT(p));\n                        });\n                    }\n                    else {\n                        // Remove from directory listing of parent.\n                        const fileNodeId = parentListing[fileName];\n                        delete parentListing[fileName];\n                        // Step 2: Get file inode.\n                        this.getINode(tx, p, fileNodeId, (e, fileNode) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (!isDir && fileNode.isDirectory()) {\n                                    tx.abort(() => {\n                                        cb(ApiError.EISDIR(p));\n                                    });\n                                }\n                                else if (isDir && !fileNode.isDirectory()) {\n                                    tx.abort(() => {\n                                        cb(ApiError.ENOTDIR(p));\n                                    });\n                                }\n                                else {\n                                    // Step 3: Delete data.\n                                    tx.del(fileNode.id, (e) => {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            // Step 4: Delete node.\n                                            tx.del(fileNodeId, (e) => {\n                                                if (noErrorTx(e, tx, cb)) {\n                                                    // Step 5: Update directory listing.\n                                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, (e) => {\n                                                        if (noErrorTx(e, tx, cb)) {\n                                                            tx.commit(cb);\n                                                        }\n                                                    });\n                                                }\n                                            });\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    }\n\n\n    return {\n        SimpleSyncRWTransaction: SimpleSyncRWTransaction,\n        SyncKeyValueFile: SyncKeyValueFile,\n        SyncKeyValueFileSystem: SyncKeyValueFileSystem,\n        AsyncKeyValueFile: AsyncKeyValueFile,\n        AsyncKeyValueFileSystem: AsyncKeyValueFileSystem\n    };\n});"]}