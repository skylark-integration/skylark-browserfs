{"version":3,"sources":["core/file_system.js"],"names":["define","api_error","file_flag","path","util","ApiError","ErrorCode","FileFlag","ActionType","fail","BaseFileSystem","[object Object]","p","cb","flag","ENOTSUP","mode","this","stat","e","stats","pathNotExistsAction","CREATE_FILE","dirname","parentStats","isDirectory","ENOTDIR","createFile","THROW_EXCEPTION","ENOENT","EINVAL","EISDIR","pathExistsAction","EEXIST","TRUNCATE_FILE","openFile","fd","truncate","sync","NOP","oldPath","newPath","isLstat","statSync","createFileSync","unlinkSync","openFileSync","err","cache","supportsLinks","splitPath","split","sep","i","length","addPaths","slice","join","apply","exists","doesExist","existsSync","len","open","getFileFlag","er","close","er2","openSync","truncateSync","closeSync","fname","encoding","oldCb","arg","err2","buf","Buffer","alloc","size","read","toString","readSync","data","from","write","writeSync","isLchmod","isLchown","uid","gid","atime","mtime","srcpath","dstpath","type","SynchronousFileSystem","renameSync","flags","rmdirSync","mkdirSync","readdirSync","chmodSync","chownSync","utimesSync","linkSync","symlinkSync","readlinkSync"],"mappings":"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","file":"../../core/file_system.js","sourcesContent":["define([\n    './api_error',\n    './file_flag',\n    '../libs/path',\n    './util'\n], function (api_error, file_flag, path, util) {\n    'use strict';\n\n    const { ApiError, ErrorCode } = api_error;\n    const { FileFlag, ActionType } = file_flag;\n    const { fail } = util;\n\n    /**\n     * Basic filesystem class. Most filesystems should extend this class, as it\n     * provides default implementations for a handful of methods.\n     */\n    class BaseFileSystem {\n        supportsLinks() {\n            return false;\n        }\n        diskSpace(p, cb) {\n            cb(0, 0);\n        }\n        /**\n         * Opens the file at path p with the given flag. The file must exist.\n         * @param p The path to open.\n         * @param flag The flag to use when opening the file.\n         */\n        openFile(p, flag, cb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Create the file at path p with the given mode. Then, open it with the given\n         * flag.\n         */\n        createFile(p, flag, mode, cb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        open(p, flag, mode, cb) {\n            const mustBeFile = (e, stats) => {\n                if (e) {\n                    // File does not exist.\n                    switch (flag.pathNotExistsAction()) {\n                        case ActionType.CREATE_FILE:\n                            // Ensure parent exists.\n                            return this.stat(path.dirname(p), false, (e, parentStats) => {\n                                if (e) {\n                                    cb(e);\n                                }\n                                else if (parentStats && !parentStats.isDirectory()) {\n                                    cb(ApiError.ENOTDIR(path.dirname(p)));\n                                }\n                                else {\n                                    this.createFile(p, flag, mode, cb);\n                                }\n                            });\n                        case ActionType.THROW_EXCEPTION:\n                            return cb(ApiError.ENOENT(p));\n                        default:\n                            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n                    }\n                }\n                else {\n                    // File exists.\n                    if (stats && stats.isDirectory()) {\n                        return cb(ApiError.EISDIR(p));\n                    }\n                    switch (flag.pathExistsAction()) {\n                        case ActionType.THROW_EXCEPTION:\n                            return cb(ApiError.EEXIST(p));\n                        case ActionType.TRUNCATE_FILE:\n                            // NOTE: In a previous implementation, we deleted the file and\n                            // re-created it. However, this created a race condition if another\n                            // asynchronous request was trying to read the file, as the file\n                            // would not exist for a small period of time.\n                            return this.openFile(p, flag, (e, fd) => {\n                                if (e) {\n                                    cb(e);\n                                }\n                                else if (fd) {\n                                    fd.truncate(0, () => {\n                                        fd.sync(() => {\n                                            cb(null, fd);\n                                        });\n                                    });\n                                }\n                                else {\n                                    fail();\n                                }\n                            });\n                        case ActionType.NOP:\n                            return this.openFile(p, flag, cb);\n                        default:\n                            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n                    }\n                }\n            };\n            this.stat(p, false, mustBeFile);\n        }\n        rename(oldPath, newPath, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        renameSync(oldPath, newPath) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        stat(p, isLstat, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        statSync(p, isLstat) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Opens the file at path p with the given flag. The file must exist.\n         * @param p The path to open.\n         * @param flag The flag to use when opening the file.\n         * @return A File object corresponding to the opened file.\n         */\n        openFileSync(p, flag, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Create the file at path p with the given mode. Then, open it with the given\n         * flag.\n         */\n        createFileSync(p, flag, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        openSync(p, flag, mode) {\n            // Check if the path exists, and is a file.\n            let stats;\n            try {\n                stats = this.statSync(p, false);\n            }\n            catch (e) {\n                // File does not exist.\n                switch (flag.pathNotExistsAction()) {\n                    case ActionType.CREATE_FILE:\n                        // Ensure parent exists.\n                        const parentStats = this.statSync(path.dirname(p), false);\n                        if (!parentStats.isDirectory()) {\n                            throw ApiError.ENOTDIR(path.dirname(p));\n                        }\n                        return this.createFileSync(p, flag, mode);\n                    case ActionType.THROW_EXCEPTION:\n                        throw ApiError.ENOENT(p);\n                    default:\n                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n                }\n            }\n            // File exists.\n            if (stats.isDirectory()) {\n                throw ApiError.EISDIR(p);\n            }\n            switch (flag.pathExistsAction()) {\n                case ActionType.THROW_EXCEPTION:\n                    throw ApiError.EEXIST(p);\n                case ActionType.TRUNCATE_FILE:\n                    // Delete file.\n                    this.unlinkSync(p);\n                    // Create file. Use the same mode as the old file.\n                    // Node itself modifies the ctime when this occurs, so this action\n                    // will preserve that behavior if the underlying file system\n                    // supports those properties.\n                    return this.createFileSync(p, flag, stats.mode);\n                case ActionType.NOP:\n                    return this.openFileSync(p, flag, mode);\n                default:\n                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n            }\n        }\n        unlink(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        unlinkSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        rmdir(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        rmdirSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        mkdir(p, mode, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        mkdirSync(p, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        readdir(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        readdirSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        exists(p, cb) {\n            this.stat(p, null, function (err) {\n                cb(!err);\n            });\n        }\n        existsSync(p) {\n            try {\n                this.statSync(p, true);\n                return true;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        realpath(p, cache, cb) {\n            if (this.supportsLinks()) {\n                // The path could contain symlinks. Split up the path,\n                // resolve any symlinks, return the resolved string.\n                const splitPath = p.split(path.sep);\n                // TODO: Simpler to just pass through file, find sep and such.\n                for (let i = 0; i < splitPath.length; i++) {\n                    const addPaths = splitPath.slice(0, i + 1);\n                    splitPath[i] = path.join.apply(null, addPaths);\n                }\n            }\n            else {\n                // No symlinks. We just need to verify that it exists.\n                this.exists(p, function (doesExist) {\n                    if (doesExist) {\n                        cb(null, p);\n                    }\n                    else {\n                        cb(ApiError.ENOENT(p));\n                    }\n                });\n            }\n        }\n        realpathSync(p, cache) {\n            if (this.supportsLinks()) {\n                // The path could contain symlinks. Split up the path,\n                // resolve any symlinks, return the resolved string.\n                const splitPath = p.split(path.sep);\n                // TODO: Simpler to just pass through file, find sep and such.\n                for (let i = 0; i < splitPath.length; i++) {\n                    const addPaths = splitPath.slice(0, i + 1);\n                    splitPath[i] = path.join.apply(path, addPaths);\n                }\n                return splitPath.join(path.sep);\n            }\n            else {\n                // No symlinks. We just need to verify that it exists.\n                if (this.existsSync(p)) {\n                    return p;\n                }\n                else {\n                    throw ApiError.ENOENT(p);\n                }\n            }\n        }\n        truncate(p, len, cb) {\n            this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {\n                if (er) {\n                    return cb(er);\n                }\n                fd.truncate(len, (function (er) {\n                    fd.close((function (er2) {\n                        cb(er || er2);\n                    }));\n                }));\n            }));\n        }\n        truncateSync(p, len) {\n            const fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\n            // Need to safely close FD, regardless of whether or not truncate succeeds.\n            try {\n                fd.truncateSync(len);\n            }\n            catch (e) {\n                throw e;\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        readFile(fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, (err, fd) => {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (!err) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                fd.stat((err, stat) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    // Allocate buffer.\n                    const buf = Buffer.alloc(stat.size);\n                    fd.read(buf, 0, stat.size, 0, (err) => {\n                        if (err) {\n                            return cb(err);\n                        }\n                        else if (encoding === null) {\n                            return cb(err, buf);\n                        }\n                        try {\n                            cb(null, buf.toString(encoding));\n                        }\n                        catch (e) {\n                            cb(e);\n                        }\n                    });\n                });\n            });\n        }\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const stat = fd.statSync();\n                // Allocate buffer.\n                const buf = Buffer.alloc(stat.size);\n                fd.readSync(buf, 0, stat.size, 0);\n                fd.closeSync();\n                if (encoding === null) {\n                    return buf;\n                }\n                return buf.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        writeFile(fname, data, encoding, flag, mode, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err) {\n                    fd.close(function (err2) {\n                        oldCb(err ? err : err2);\n                    });\n                };\n                try {\n                    if (typeof data === 'string') {\n                        data = Buffer.from(data, encoding);\n                    }\n                }\n                catch (e) {\n                    return cb(e);\n                }\n                // Write into file.\n                fd.write(data, 0, data.length, 0, cb);\n            });\n        }\n        writeFileSync(fname, data, encoding, flag, mode) {\n            // Get file.\n            const fd = this.openSync(fname, flag, mode);\n            try {\n                if (typeof data === 'string') {\n                    data = Buffer.from(data, encoding);\n                }\n                // Write into file.\n                fd.writeSync(data, 0, data.length, 0);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        appendFile(fname, data, encoding, flag, mode, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            this.open(fname, flag, mode, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err) {\n                    fd.close(function (err2) {\n                        oldCb(err ? err : err2);\n                    });\n                };\n                if (typeof data === 'string') {\n                    data = Buffer.from(data, encoding);\n                }\n                fd.write(data, 0, data.length, null, cb);\n            });\n        }\n        appendFileSync(fname, data, encoding, flag, mode) {\n            const fd = this.openSync(fname, flag, mode);\n            try {\n                if (typeof data === 'string') {\n                    data = Buffer.from(data, encoding);\n                }\n                fd.writeSync(data, 0, data.length, null);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        chmod(p, isLchmod, mode, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        chmodSync(p, isLchmod, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        chownSync(p, isLchown, uid, gid) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        utimes(p, atime, mtime, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        utimesSync(p, atime, mtime) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        link(srcpath, dstpath, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        linkSync(srcpath, dstpath) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        symlinkSync(srcpath, dstpath, type) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        readlink(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        readlinkSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n    }\n    /**\n     * Implements the asynchronous API in terms of the synchronous API.\n     * @class SynchronousFileSystem\n     */\n    class SynchronousFileSystem extends BaseFileSystem {\n        supportsSynch() {\n            return true;\n        }\n        rename(oldPath, newPath, cb) {\n            try {\n                this.renameSync(oldPath, newPath);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        stat(p, isLstat, cb) {\n            try {\n                cb(null, this.statSync(p, isLstat));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        open(p, flags, mode, cb) {\n            try {\n                cb(null, this.openSync(p, flags, mode));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        unlink(p, cb) {\n            try {\n                this.unlinkSync(p);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        rmdir(p, cb) {\n            try {\n                this.rmdirSync(p);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        mkdir(p, mode, cb) {\n            try {\n                this.mkdirSync(p, mode);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readdir(p, cb) {\n            try {\n                cb(null, this.readdirSync(p));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        chmod(p, isLchmod, mode, cb) {\n            try {\n                this.chmodSync(p, isLchmod, mode);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            try {\n                this.chownSync(p, isLchown, uid, gid);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        utimes(p, atime, mtime, cb) {\n            try {\n                this.utimesSync(p, atime, mtime);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        link(srcpath, dstpath, cb) {\n            try {\n                this.linkSync(srcpath, dstpath);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            try {\n                this.symlinkSync(srcpath, dstpath, type);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readlink(p, cb) {\n            try {\n                cb(null, this.readlinkSync(p));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n    }\n\n\n    return {\n        BaseFileSystem: BaseFileSystem,\n        SynchronousFileSystem: SynchronousFileSystem\n    };\n});"]}