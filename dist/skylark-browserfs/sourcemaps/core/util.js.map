{"version":3,"sources":["core/util.js"],"names":["define","buffer","api_error","levenshtein","path","ErrorCode","ApiError","Buffer","buffer2Uint8array","buff","Uint8Array","uint8Array2Buffer","u8","byteOffset","byteLength","arrayBuffer2Buffer","from","ab","emptyBuff","emptyBuffer","alloc","deprecationMessage","print","fsName","opts","console","warn","JSON","stringify","isIE","navigator","exec","userAgent","toLowerCase","indexOf","isWebWorker","window","fail","Error","mkdirpSync","p","mode","fs","existsSync","dirname","mkdirSync","buffer2ArrayBuffer","u8offset","u8Len","slice","arrayish2Buffer","arr","copyingSlice","start","end","length","TypeError","s0","newS0","subarray","bufferValidator","v","cb","isBuffer","EINVAL","checkOptions","fsType","optsInfo","Options","Name","pendingValidators","callbackCalled","loopEnded","validatorCallback","e","optName","hasOwnProperty","opt","providedValue","undefined","optional","incorrectOptions","Object","keys","filter","o","map","a","str","distance","sort","b","description","typeMatches","Array","isArray","type","join","validator"],"mappings":"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","file":"../../core/util.js","sourcesContent":["define([\n    '../libs/buffer',\n    './api_error',\n    './levenshtein',\n    '../libs/path'\n], function (buffer,api_error, levenshtein, path) {\n    'use strict';\n\n    const { ErrorCode, ApiError } = api_error;\n    const {Buffer} = buffer;\n\n    function deprecationMessage(print, fsName, opts) {\n        if (print) {\n            // tslint:disable-next-line:no-console\n            console.warn(`[${fsName}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${fsName}.Create(${JSON.stringify(opts)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`);\n            // tslint:enable-next-line:no-console\n        }\n    }\n    /**\n     * Checks for any IE version, including IE11 which removed MSIE from the\n     * userAgent string.\n     * @hidden\n     */\n    const isIE = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\n    /**\n     * Check if we're in a web worker.\n     * @hidden\n     */\n    const isWebWorker = typeof window === \"undefined\";\n    /**\n     * Throws an exception. Called on code paths that should be impossible.\n     * @hidden\n     */\n    function fail() {\n        throw new Error(\"BFS has reached an impossible code path; please file a bug.\");\n    }\n    /**\n     * Synchronous recursive makedir.\n     * @hidden\n     */\n    function mkdirpSync(p, mode, fs) {\n        if (!fs.existsSync(p)) {\n            mkdirpSync(path.dirname(p), mode, fs);\n            fs.mkdirSync(p, mode);\n        }\n    }\n    /**\n     * Converts a buffer into an array buffer. Attempts to do so in a\n     * zero-copy manner, e.g. the array references the same memory.\n     * @hidden\n     */\n    function buffer2ArrayBuffer(buff) {\n        const u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;\n        if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\n            return u8.buffer;\n        }\n        else {\n            return u8.buffer.slice(u8offset, u8offset + u8Len);\n        }\n    }\n    /**\n     * Converts a buffer into a Uint8Array. Attempts to do so in a\n     * zero-copy manner, e.g. the array references the same memory.\n     * @hidden\n     */\n    function buffer2Uint8array(buff) {\n        if (buff instanceof Uint8Array) {\n            // BFS & Node v4.0 buffers *are* Uint8Arrays.\n            return buff;\n        }\n        else {\n            // Uint8Arrays can be constructed from arrayish numbers.\n            // At this point, we assume this isn't a BFS array.\n            return new Uint8Array(buff);\n        }\n    }\n    /**\n     * Converts the given arrayish object into a Buffer. Attempts to\n     * be zero-copy.\n     * @hidden\n     */\n    function arrayish2Buffer(arr) {\n        if (arr instanceof Buffer) {\n            return arr;\n        }\n        else if (arr instanceof Uint8Array) {\n            return uint8Array2Buffer(arr);\n        }\n        else {\n            return Buffer.from(arr);\n        }\n    }\n    /**\n     * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\n     * @hidden\n     */\n    function uint8Array2Buffer(u8) {\n        if (u8 instanceof Buffer) {\n            return u8;\n        }\n        else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\n            return arrayBuffer2Buffer(u8.buffer);\n        }\n        else {\n            return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);\n        }\n    }\n    /**\n     * Converts the given array buffer into a Buffer. Attempts to be\n     * zero-copy.\n     * @hidden\n     */\n    function arrayBuffer2Buffer(ab) {\n        return Buffer.from(ab);\n    }\n    /**\n     * Copies a slice of the given buffer\n     * @hidden\n     */\n    function copyingSlice(buff, start = 0, end = buff.length) {\n        if (start < 0 || end < 0 || end > buff.length || start > end) {\n            throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);\n        }\n        if (buff.length === 0) {\n            // Avoid s0 corner case in ArrayBuffer case.\n            return emptyBuffer();\n        }\n        else {\n            const u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;\n            buff[0] = newS0;\n            if (u8[0] === newS0) {\n                // Same memory. Revert & copy.\n                u8[0] = s0;\n                return uint8Array2Buffer(u8.slice(start, end));\n            }\n            else {\n                // Revert.\n                buff[0] = s0;\n                return uint8Array2Buffer(u8.subarray(start, end));\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    let emptyBuff = null;\n    /**\n     * Returns an empty buffer.\n     * @hidden\n     */\n    function emptyBuffer() {\n        if (emptyBuff) {\n            return emptyBuff;\n        }\n        return emptyBuff = Buffer.alloc(0);\n    }\n    /**\n     * Option validator for a Buffer file system option.\n     * @hidden\n     */\n    function bufferValidator(v, cb) {\n        if (Buffer.isBuffer(v)) {\n            cb();\n        }\n        else {\n            cb(new ApiError(ErrorCode.EINVAL, `option must be a Buffer.`));\n        }\n    }\n    /**\n     * Checks that the given options object is valid for the file system options.\n     * @hidden\n     */\n    function checkOptions(fsType, opts, cb) {\n        const optsInfo = fsType.Options;\n        const fsName = fsType.Name;\n        let pendingValidators = 0;\n        let callbackCalled = false;\n        let loopEnded = false;\n        function validatorCallback(e) {\n            if (!callbackCalled) {\n                if (e) {\n                    callbackCalled = true;\n                    cb(e);\n                }\n                pendingValidators--;\n                if (pendingValidators === 0 && loopEnded) {\n                    cb();\n                }\n            }\n        }\n        // Check for required options.\n        for (const optName in optsInfo) {\n            if (optsInfo.hasOwnProperty(optName)) {\n                const opt = optsInfo[optName];\n                const providedValue = opts[optName];\n                if (providedValue === undefined || providedValue === null) {\n                    if (!opt.optional) {\n                        // Required option, not provided.\n                        // Any incorrect options provided? Which ones are close to the provided one?\n                        // (edit distance 5 === close)\n                        const incorrectOptions = Object.keys(opts).filter((o) => !(o in optsInfo)).map((a) => {\n                            return { str: a, distance: levenshtein(optName, a) };\n                        }).filter((o) => o.distance < 5).sort((a, b) => a.distance - b.distance);\n                        // Validators may be synchronous.\n                        if (callbackCalled) {\n                            return;\n                        }\n                        callbackCalled = true;\n                        return cb(new ApiError(ErrorCode.EINVAL, `[${fsName}] Required option '${optName}' not provided.${incorrectOptions.length > 0 ? ` You provided unrecognized option '${incorrectOptions[0].str}'; perhaps you meant to type '${optName}'.` : ''}\\nOption description: ${opt.description}`));\n                    }\n                    // Else: Optional option, not provided. That is OK.\n                }\n                else {\n                    // Option provided! Check type.\n                    let typeMatches = false;\n                    if (Array.isArray(opt.type)) {\n                        typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;\n                    }\n                    else {\n                        typeMatches = typeof (providedValue) === opt.type;\n                    }\n                    if (!typeMatches) {\n                        // Validators may be synchronous.\n                        if (callbackCalled) {\n                            return;\n                        }\n                        callbackCalled = true;\n                        return cb(new ApiError(ErrorCode.EINVAL, `[${fsName}] Value provided for option ${optName} is not the proper type. Expected ${Array.isArray(opt.type) ? `one of {${opt.type.join(\", \")}}` : opt.type}, but received ${typeof (providedValue)}\\nOption description: ${opt.description}`));\n                    }\n                    else if (opt.validator) {\n                        pendingValidators++;\n                        opt.validator(providedValue, validatorCallback);\n                    }\n                    // Otherwise: All good!\n                }\n            }\n        }\n        loopEnded = true;\n        if (pendingValidators === 0 && !callbackCalled) {\n            cb();\n        }\n    }\n\n    return {\n        deprecationMessage: deprecationMessage,\n        isIE: isIE,\n        isWebWorker: isWebWorker,\n        fail: fail,\n        mkdirpSync: mkdirpSync,\n        buffer2ArrayBuffer: buffer2ArrayBuffer,\n        buffer2Uint8array: buffer2Uint8array,\n        arrayish2Buffer: arrayish2Buffer,\n        uint8Array2Buffer: uint8Array2Buffer,\n        arrayBuffer2Buffer: arrayBuffer2Buffer,\n        copyingSlice: copyingSlice,\n        emptyBuffer: emptyBuffer,\n        bufferValidator: bufferValidator,\n        checkOptions: checkOptions\n    };\n});"]}