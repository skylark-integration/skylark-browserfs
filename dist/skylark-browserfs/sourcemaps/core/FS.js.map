{"version":3,"sources":["core/FS.js"],"names":["define","api_error","file_flag","path","node_fs_stats","setImmediate","ApiError","ErrorCode","FileFlag","Stats","wrapCbHook","cb","numArgs","wrapCb","Error","hookedCb","arg1","arg2","arg3","assertRoot","fs","EIO","normalizeMode","mode","def","trueMode","parseInt","isNaN","normalizeTime","time","Date","EINVAL","normalizePath","p","indexOf","resolve","normalizeOptions","options","defEnc","defFlag","defMode","encoding","flag","TypeError","nopCb","FS","[object Object]","this","F_OK","R_OK","W_OK","X_OK","root","fdMap","nextFd","rootFS","constructor","isAvailable","getTime","oldPath","newPath","newCb","rename","e","renameSync","exists","existsSync","stat","statSync","len","truncate","truncateSync","unlink","unlinkSync","open","getFileFlag","file","getFdForFile","openSync","filename","isReadable","readFile","readFileSync","data","isWriteable","writeFile","writeFileSync","isAppendable","appendFile","appendFileSync","fd","fd2file","close","closeFd","closeSync","length","sync","syncSync","datasync","datasyncSync","arg4","arg5","buffer","offset","position","Buffer","from","undefined","getPos","write","writeSync","alloc","err","bytesRead","buf","toString","read","shenanigans","rv","readSync","uid","gid","callback","chown","chownSync","numMode","chmod","chmodSync","atime","mtime","utimes","utimesSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","readdirSync","srcpath","dstpath","link","linkSync","type","symlink","symlinkSync","readlink","readlinkSync","cache","realpath","realpathSync","listener","ENOTSUP","cbWrapper","EBADF"],"mappings":"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","file":"../../core/FS.js","sourcesContent":["define([\n    './api_error',\n    './file_flag',\n    '../libs/path',\n    './node_fs_stats',\n    '../generic/setImmediate'\n], function (api_error, file_flag, path, node_fs_stats, setImmediate) {\n    'use strict';\n\n    const { ApiError, ErrorCode } = api_error;\n    const { FileFlag } = file_flag;\n    const {Stats} = node_fs_stats;\n\n    /** Used for unit testing. Defaults to a NOP. */\n    let wrapCbHook = function (cb, numArgs) {\n        return cb;\n    };\n    /**\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\n     * @hidden\n     */\n    function wrapCb(cb, numArgs) {\n        if (typeof cb !== 'function') {\n            throw new Error('Callback must be a function.');\n        }\n        const hookedCb = wrapCbHook(cb, numArgs);\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\n        // need to handle 1-3 arguments\n        switch (numArgs) {\n            case 1:\n                return function (arg1) {\n                    setImmediate(function () {\n                        return hookedCb(arg1);\n                    });\n                };\n            case 2:\n                return function (arg1, arg2) {\n                    setImmediate(function () {\n                        return hookedCb(arg1, arg2);\n                    });\n                };\n            case 3:\n                return function (arg1, arg2, arg3) {\n                    setImmediate(function () {\n                        return hookedCb(arg1, arg2, arg3);\n                    });\n                };\n            default:\n                throw new Error('Invalid invocation of wrapCb.');\n        }\n    }\n    /**\n     * @hidden\n     */\n    function assertRoot(fs) {\n        if (fs) {\n            return fs;\n        }\n        throw new ApiError(ErrorCode.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\n    }\n    /**\n     * @hidden\n     */\n    function normalizeMode(mode, def) {\n        switch (typeof mode) {\n            case 'number':\n                // (path, flag, mode, cb?)\n                return mode;\n            case 'string':\n                // (path, flag, modeString, cb?)\n                const trueMode = parseInt(mode, 8);\n                if (!isNaN(trueMode)) {\n                    return trueMode;\n                }\n                // Invalid string.\n                return def;\n            default:\n                return def;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function normalizeTime(time) {\n        if (time instanceof Date) {\n            return time;\n        }\n        else if (typeof time === 'number') {\n            return new Date(time * 1000);\n        }\n        else {\n            throw new ApiError(ErrorCode.EINVAL, `Invalid time.`);\n        }\n    }\n    /**\n     * @hidden\n     */\n    function normalizePath(p) {\n        // Node doesn't allow null characters in paths.\n        if (p.indexOf('\\u0000') >= 0) {\n            throw new ApiError(ErrorCode.EINVAL, 'Path must be a string without null bytes.');\n        }\n        else if (p === '') {\n            throw new ApiError(ErrorCode.EINVAL, 'Path must not be empty.');\n        }\n        return path.resolve(p);\n    }\n    /**\n     * @hidden\n     */\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\n        // typeof null === 'object' so special-case handing is needed.\n        switch (options === null ? 'null' : typeof options) {\n            case 'object':\n                return {\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\n                    mode: normalizeMode(options['mode'], defMode)\n                };\n            case 'string':\n                return {\n                    encoding: options,\n                    flag: defFlag,\n                    mode: defMode\n                };\n            case 'null':\n            case 'undefined':\n            case 'function':\n                return {\n                    encoding: defEnc,\n                    flag: defFlag,\n                    mode: defMode\n                };\n            default:\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\n        }\n    }\n    /**\n     * The default callback is a NOP.\n     * @hidden\n     * @private\n     */\n    function nopCb() {\n        // NOP.\n    }\n    /**\n     * The node frontend to all filesystems.\n     * This layer handles:\n     *\n     * * Sanity checking inputs.\n     * * Normalizing paths.\n     * * Resetting stack depth for asynchronous operations which may not go through\n     *   the browser by wrapping all input callbacks using `setImmediate`.\n     * * Performing the requested operation through the filesystem or the file\n     *   descriptor, as appropriate.\n     * * Handling optional arguments and setting default arguments.\n     * @see http://nodejs.org/api/fs.html\n     */\n    class FS {\n        constructor() {\n            /* tslint:enable:variable-name */\n            this.F_OK = 0;\n            this.R_OK = 4;\n            this.W_OK = 2;\n            this.X_OK = 1;\n            this.root = null;\n            this.fdMap = {};\n            this.nextFd = 100;\n        }\n        initialize(rootFS) {\n            if (!rootFS.constructor.isAvailable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\n            }\n            return this.root = rootFS;\n        }\n        /**\n         * converts Date or number to a fractional UNIX timestamp\n         * Grabbed from NodeJS sources (lib/fs.js)\n         */\n        _toUnixTimestamp(time) {\n            if (typeof time === 'number') {\n                return time;\n            }\n            else if (time instanceof Date) {\n                return time.getTime() / 1000;\n            }\n            throw new Error(\"Cannot parse time: \" + time);\n        }\n        /**\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\n         *   not been initialized.\n         */\n        getRootFS() {\n            if (this.root) {\n                return this.root;\n            }\n            else {\n                return null;\n            }\n        }\n        // FILE OR DIRECTORY METHODS\n        /**\n         * Asynchronous rename. No arguments other than a possible exception are given\n         * to the completion callback.\n         * @param oldPath\n         * @param newPath\n         * @param callback\n         */\n        rename(oldPath, newPath, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous rename.\n         * @param oldPath\n         * @param newPath\n         */\n        renameSync(oldPath, newPath) {\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\n        }\n        /**\n         * Test whether or not the given path exists by checking with the file system.\n         * Then call the callback argument with either true or false.\n         * @example Sample invocation\n         *   fs.exists('/etc/passwd', function (exists) {\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\n         *   });\n         * @param path\n         * @param callback\n         */\n        exists(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\n            }\n            catch (e) {\n                // Doesn't return an error. If something bad happens, we assume it just\n                // doesn't exist.\n                return newCb(false);\n            }\n        }\n        /**\n         * Test whether or not the given path exists by checking with the file system.\n         * @param path\n         * @return [boolean]\n         */\n        existsSync(path) {\n            try {\n                return assertRoot(this.root).existsSync(normalizePath(path));\n            }\n            catch (e) {\n                // Doesn't return an error. If something bad happens, we assume it just\n                // doesn't exist.\n                return false;\n            }\n        }\n        /**\n         * Asynchronous `stat`.\n         * @param path\n         * @param callback\n         */\n        stat(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `stat`.\n         * @param path\n         * @return [BrowserFS.node.fs.Stats]\n         */\n        statSync(path) {\n            return assertRoot(this.root).statSync(normalizePath(path), false);\n        }\n        /**\n         * Asynchronous `lstat`.\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n         * then the link itself is stat-ed, not the file that it refers to.\n         * @param path\n         * @param callback\n         */\n        lstat(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `lstat`.\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n         * then the link itself is stat-ed, not the file that it refers to.\n         * @param path\n         * @return [BrowserFS.node.fs.Stats]\n         */\n        lstatSync(path) {\n            return assertRoot(this.root).statSync(normalizePath(path), true);\n        }\n        truncate(path, arg2 = 0, cb = nopCb) {\n            let len = 0;\n            if (typeof arg2 === 'function') {\n                cb = arg2;\n            }\n            else if (typeof arg2 === 'number') {\n                len = arg2;\n            }\n            const newCb = wrapCb(cb, 1);\n            try {\n                if (len < 0) {\n                    throw new ApiError(ErrorCode.EINVAL);\n                }\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `truncate`.\n         * @param path\n         * @param len\n         */\n        truncateSync(path, len = 0) {\n            if (len < 0) {\n                throw new ApiError(ErrorCode.EINVAL);\n            }\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\n        }\n        /**\n         * Asynchronous `unlink`.\n         * @param path\n         * @param callback\n         */\n        unlink(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `unlink`.\n         * @param path\n         */\n        unlinkSync(path) {\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\n        }\n        open(path, flag, arg2, cb = nopCb) {\n            const mode = normalizeMode(arg2, 0x1a4);\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            const newCb = wrapCb(cb, 2);\n            try {\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\n                    if (file) {\n                        newCb(e, this.getFdForFile(file));\n                    }\n                    else {\n                        newCb(e);\n                    }\n                });\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous file open.\n         * @see http://www.manpagez.com/man/2/open/\n         * @param path\n         * @param flags\n         * @param mode defaults to `0644`\n         * @return [BrowserFS.File]\n         */\n        openSync(path, flag, mode = 0x1a4) {\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\n        }\n        readFile(filename, arg2 = {}, cb = nopCb) {\n            const options = normalizeOptions(arg2, null, 'r', null);\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            const newCb = wrapCb(cb, 2);\n            try {\n                const flag = FileFlag.getFileFlag(options['flag']);\n                if (!flag.isReadable()) {\n                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.'));\n                }\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        readFileSync(filename, arg2 = {}) {\n            const options = normalizeOptions(arg2, null, 'r', null);\n            const flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isReadable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.');\n            }\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\n        }\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                const flag = FileFlag.getFileFlag(options.flag);\n                if (!flag.isWriteable()) {\n                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.'));\n                }\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        writeFileSync(filename, data, arg3) {\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n            const flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isWriteable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.');\n            }\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n        }\n        appendFile(filename, data, arg3, cb = nopCb) {\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                const flag = FileFlag.getFileFlag(options.flag);\n                if (!flag.isAppendable()) {\n                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.'));\n                }\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        appendFileSync(filename, data, arg3) {\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n            const flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isAppendable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.');\n            }\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n        }\n        // FILE DESCRIPTOR METHODS\n        /**\n         * Asynchronous `fstat`.\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n         * specified by the file descriptor `fd`.\n         * @param fd\n         * @param callback\n         */\n        fstat(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                const file = this.fd2file(fd);\n                file.stat(newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `fstat`.\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n         * specified by the file descriptor `fd`.\n         * @param fd\n         * @return [BrowserFS.node.fs.Stats]\n         */\n        fstatSync(fd) {\n            return this.fd2file(fd).statSync();\n        }\n        /**\n         * Asynchronous close.\n         * @param fd\n         * @param callback\n         */\n        close(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                this.fd2file(fd).close((e) => {\n                    if (!e) {\n                        this.closeFd(fd);\n                    }\n                    newCb(e);\n                });\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous close.\n         * @param fd\n         */\n        closeSync(fd) {\n            this.fd2file(fd).closeSync();\n            this.closeFd(fd);\n        }\n        ftruncate(fd, arg2, cb = nopCb) {\n            const length = typeof arg2 === 'number' ? arg2 : 0;\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                const file = this.fd2file(fd);\n                if (length < 0) {\n                    throw new ApiError(ErrorCode.EINVAL);\n                }\n                file.truncate(length, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous ftruncate.\n         * @param fd\n         * @param len\n         */\n        ftruncateSync(fd, len = 0) {\n            const file = this.fd2file(fd);\n            if (len < 0) {\n                throw new ApiError(ErrorCode.EINVAL);\n            }\n            file.truncateSync(len);\n        }\n        /**\n         * Asynchronous fsync.\n         * @param fd\n         * @param callback\n         */\n        fsync(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                this.fd2file(fd).sync(newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous fsync.\n         * @param fd\n         */\n        fsyncSync(fd) {\n            this.fd2file(fd).syncSync();\n        }\n        /**\n         * Asynchronous fdatasync.\n         * @param fd\n         * @param callback\n         */\n        fdatasync(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                this.fd2file(fd).datasync(newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous fdatasync.\n         * @param fd\n         */\n        fdatasyncSync(fd) {\n            this.fd2file(fd).datasyncSync();\n        }\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\n            let buffer, offset, length, position = null;\n            if (typeof arg2 === 'string') {\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\n                let encoding = 'utf8';\n                switch (typeof arg3) {\n                    case 'function':\n                        // (fd, string, cb)\n                        cb = arg3;\n                        break;\n                    case 'number':\n                        // (fd, string, position, encoding?, cb?)\n                        position = arg3;\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\n                        break;\n                    default:\n                        // ...try to find the callback and get out of here!\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\n                        return cb(new ApiError(ErrorCode.EINVAL, 'Invalid arguments.'));\n                }\n                buffer = Buffer.from(arg2, encoding);\n                offset = 0;\n                length = buffer.length;\n            }\n            else {\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = typeof arg5 === 'number' ? arg5 : null;\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n            }\n            const newCb = wrapCb(cb, 3);\n            try {\n                const file = this.fd2file(fd);\n                if (position === undefined || position === null) {\n                    position = file.getPos();\n                }\n                file.write(buffer, offset, length, position, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        writeSync(fd, arg2, arg3, arg4, arg5) {\n            let buffer, offset = 0, length, position;\n            if (typeof arg2 === 'string') {\n                // Signature 1: (fd, string, [position?, [encoding?]])\n                position = typeof arg3 === 'number' ? arg3 : null;\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                offset = 0;\n                buffer = Buffer.from(arg2, encoding);\n                length = buffer.length;\n            }\n            else {\n                // Signature 2: (fd, buffer, offset, length, position?)\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = typeof arg5 === 'number' ? arg5 : null;\n            }\n            const file = this.fd2file(fd);\n            if (position === undefined || position === null) {\n                position = file.getPos();\n            }\n            return file.writeSync(buffer, offset, length, position);\n        }\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\n            let position, offset, length, buffer, newCb;\n            if (typeof arg2 === 'number') {\n                // legacy interface\n                // (fd, length, position, encoding, callback)\n                length = arg2;\n                position = arg3;\n                const encoding = arg4;\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n                offset = 0;\n                buffer = Buffer.alloc(length);\n                // XXX: Inefficient.\n                // Wrap the cb so we shelter upper layers of the API from these\n                // shenanigans.\n                newCb = wrapCb((err, bytesRead, buf) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    cb(err, buf.toString(encoding), bytesRead);\n                }, 3);\n            }\n            else {\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = arg5;\n                newCb = wrapCb(cb, 3);\n            }\n            try {\n                const file = this.fd2file(fd);\n                if (position === undefined || position === null) {\n                    position = file.getPos();\n                }\n                file.read(buffer, offset, length, position, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        readSync(fd, arg2, arg3, arg4, arg5) {\n            let shenanigans = false;\n            let buffer, offset, length, position, encoding = 'utf8';\n            if (typeof arg2 === 'number') {\n                length = arg2;\n                position = arg3;\n                encoding = arg4;\n                offset = 0;\n                buffer = Buffer.alloc(length);\n                shenanigans = true;\n            }\n            else {\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = arg5;\n            }\n            const file = this.fd2file(fd);\n            if (position === undefined || position === null) {\n                position = file.getPos();\n            }\n            const rv = file.readSync(buffer, offset, length, position);\n            if (!shenanigans) {\n                return rv;\n            }\n            else {\n                return [buffer.toString(encoding), rv];\n            }\n        }\n        /**\n         * Asynchronous `fchown`.\n         * @param fd\n         * @param uid\n         * @param gid\n         * @param callback\n         */\n        fchown(fd, uid, gid, callback = nopCb) {\n            const newCb = wrapCb(callback, 1);\n            try {\n                this.fd2file(fd).chown(uid, gid, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `fchown`.\n         * @param fd\n         * @param uid\n         * @param gid\n         */\n        fchownSync(fd, uid, gid) {\n            this.fd2file(fd).chownSync(uid, gid);\n        }\n        /**\n         * Asynchronous `fchmod`.\n         * @param fd\n         * @param mode\n         * @param callback\n         */\n        fchmod(fd, mode, cb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n                this.fd2file(fd).chmod(numMode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `fchmod`.\n         * @param fd\n         * @param mode\n         */\n        fchmodSync(fd, mode) {\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            this.fd2file(fd).chmodSync(numMode);\n        }\n        /**\n         * Change the file timestamps of a file referenced by the supplied file\n         * descriptor.\n         * @param fd\n         * @param atime\n         * @param mtime\n         * @param callback\n         */\n        futimes(fd, atime, mtime, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const file = this.fd2file(fd);\n                if (typeof atime === 'number') {\n                    atime = new Date(atime * 1000);\n                }\n                if (typeof mtime === 'number') {\n                    mtime = new Date(mtime * 1000);\n                }\n                file.utimes(atime, mtime, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Change the file timestamps of a file referenced by the supplied file\n         * descriptor.\n         * @param fd\n         * @param atime\n         * @param mtime\n         */\n        futimesSync(fd, atime, mtime) {\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\n        }\n        // DIRECTORY-ONLY METHODS\n        /**\n         * Asynchronous `rmdir`.\n         * @param path\n         * @param callback\n         */\n        rmdir(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).rmdir(path, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `rmdir`.\n         * @param path\n         */\n        rmdirSync(path) {\n            path = normalizePath(path);\n            return assertRoot(this.root).rmdirSync(path);\n        }\n        /**\n         * Asynchronous `mkdir`.\n         * @param path\n         * @param mode defaults to `0777`\n         * @param callback\n         */\n        mkdir(path, mode, cb = nopCb) {\n            if (typeof mode === 'function') {\n                cb = mode;\n                mode = 0x1ff;\n            }\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).mkdir(path, mode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `mkdir`.\n         * @param path\n         * @param mode defaults to `0777`\n         */\n        mkdirSync(path, mode) {\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\n        }\n        /**\n         * Asynchronous `readdir`. Reads the contents of a directory.\n         * The callback gets two arguments `(err, files)` where `files` is an array of\n         * the names of the files in the directory excluding `'.'` and `'..'`.\n         * @param path\n         * @param callback\n         */\n        readdir(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).readdir(path, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `readdir`. Reads the contents of a directory.\n         * @param path\n         * @return [String[]]\n         */\n        readdirSync(path) {\n            path = normalizePath(path);\n            return assertRoot(this.root).readdirSync(path);\n        }\n        // SYMLINK METHODS\n        /**\n         * Asynchronous `link`.\n         * @param srcpath\n         * @param dstpath\n         * @param callback\n         */\n        link(srcpath, dstpath, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                srcpath = normalizePath(srcpath);\n                dstpath = normalizePath(dstpath);\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `link`.\n         * @param srcpath\n         * @param dstpath\n         */\n        linkSync(srcpath, dstpath) {\n            srcpath = normalizePath(srcpath);\n            dstpath = normalizePath(dstpath);\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\n        }\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                if (type !== 'file' && type !== 'dir') {\n                    return newCb(new ApiError(ErrorCode.EINVAL, \"Invalid type: \" + type));\n                }\n                srcpath = normalizePath(srcpath);\n                dstpath = normalizePath(dstpath);\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `symlink`.\n         * @param srcpath\n         * @param dstpath\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\n         */\n        symlinkSync(srcpath, dstpath, type) {\n            if (!type) {\n                type = 'file';\n            }\n            else if (type !== 'file' && type !== 'dir') {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid type: \" + type);\n            }\n            srcpath = normalizePath(srcpath);\n            dstpath = normalizePath(dstpath);\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\n        }\n        /**\n         * Asynchronous readlink.\n         * @param path\n         * @param callback\n         */\n        readlink(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).readlink(path, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous readlink.\n         * @param path\n         * @return [String]\n         */\n        readlinkSync(path) {\n            path = normalizePath(path);\n            return assertRoot(this.root).readlinkSync(path);\n        }\n        // PROPERTY OPERATIONS\n        /**\n         * Asynchronous `chown`.\n         * @param path\n         * @param uid\n         * @param gid\n         * @param callback\n         */\n        chown(path, uid, gid, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `chown`.\n         * @param path\n         * @param uid\n         * @param gid\n         */\n        chownSync(path, uid, gid) {\n            path = normalizePath(path);\n            assertRoot(this.root).chownSync(path, false, uid, gid);\n        }\n        /**\n         * Asynchronous `lchown`.\n         * @param path\n         * @param uid\n         * @param gid\n         * @param callback\n         */\n        lchown(path, uid, gid, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `lchown`.\n         * @param path\n         * @param uid\n         * @param gid\n         */\n        lchownSync(path, uid, gid) {\n            path = normalizePath(path);\n            assertRoot(this.root).chownSync(path, true, uid, gid);\n        }\n        /**\n         * Asynchronous `chmod`.\n         * @param path\n         * @param mode\n         * @param callback\n         */\n        chmod(path, mode, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const numMode = normalizeMode(mode, -1);\n                if (numMode < 0) {\n                    throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n                }\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `chmod`.\n         * @param path\n         * @param mode\n         */\n        chmodSync(path, mode) {\n            const numMode = normalizeMode(mode, -1);\n            if (numMode < 0) {\n                throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n            }\n            path = normalizePath(path);\n            assertRoot(this.root).chmodSync(path, false, numMode);\n        }\n        /**\n         * Asynchronous `lchmod`.\n         * @param path\n         * @param mode\n         * @param callback\n         */\n        lchmod(path, mode, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const numMode = normalizeMode(mode, -1);\n                if (numMode < 0) {\n                    throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n                }\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `lchmod`.\n         * @param path\n         * @param mode\n         */\n        lchmodSync(path, mode) {\n            const numMode = normalizeMode(mode, -1);\n            if (numMode < 1) {\n                throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n            }\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\n        }\n        /**\n         * Change file timestamps of the file referenced by the supplied path.\n         * @param path\n         * @param atime\n         * @param mtime\n         * @param callback\n         */\n        utimes(path, atime, mtime, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Change file timestamps of the file referenced by the supplied path.\n         * @param path\n         * @param atime\n         * @param mtime\n         */\n        utimesSync(path, atime, mtime) {\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\n        }\n        realpath(path, arg2, cb = nopCb) {\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\n            const newCb = wrapCb(cb, 2);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).realpath(path, cache, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `realpath`.\n         * @param path\n         * @param cache An object literal of mapped paths that can be used to\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\n         *   known real paths.\n         * @return [String]\n         */\n        realpathSync(path, cache = {}) {\n            path = normalizePath(path);\n            return assertRoot(this.root).realpathSync(path, cache);\n        }\n        watchFile(filename, arg2, listener = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        unwatchFile(filename, listener = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        watch(filename, arg2, listener = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        access(path, arg2, cb = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        accessSync(path, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        createReadStream(path, options) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        createWriteStream(path, options) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\n         */\n        wrapCallbacks(cbWrapper) {\n            wrapCbHook = cbWrapper;\n        }\n        getFdForFile(file) {\n            const fd = this.nextFd++;\n            this.fdMap[fd] = file;\n            return fd;\n        }\n        fd2file(fd) {\n            const rv = this.fdMap[fd];\n            if (rv) {\n                return rv;\n            }\n            else {\n                throw new ApiError(ErrorCode.EBADF, 'Invalid file descriptor.');\n            }\n        }\n        closeFd(fd) {\n            delete this.fdMap[fd];\n        }\n    }\n    /* tslint:disable:variable-name */\n    // Exported fs.Stats.\n    FS.Stats = Stats;\n    //# sourceMappingURL=FS.js.map\n\n    return FS;\n});"]}