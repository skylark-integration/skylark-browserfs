{"version":3,"sources":["libs/path.js"],"names":["define","splitPathRe","path","normalize","p","absolute","charAt","sep","components","_removeDuplicateSeps","split","goodComponents","idx","length","c","pop","push","unshift","join","paths","_i","arguments","processed","i","segment","TypeError","resolve","resolved","substr","cwd","process","this","relative","from","to","fromSegs","toSegs","shift","upCount","downSegs","slice","rv","dirname","sections","basename","ext","lastPart","extname","lastIndexOf","isAbsolute","_makeLong","parse","filename","out","allParts","exec","root","dir","base","name","format","pathObject","replace","_replaceRegex","RegExp","delimiter","posix","win32"],"mappings":"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","file":"../../libs/path.js","sourcesContent":["define([],function(){\r\n\tvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n\r\n\tfunction posixSplitPath(filename) {\r\n\t    var out = splitPathRe.exec(filename);\r\n\t    out.shift();\r\n\t    return out;\r\n\t}\r\n\t/**\r\n\t * Emulates Node's `path` module. This module contains utilities for handling and\r\n\t * transforming file paths. **All** of these methods perform only string\r\n\t * transformations. The file system is not consulted to check whether paths are\r\n\t * valid.\r\n\t * @see http://nodejs.org/api/path.html\r\n\t * @class\r\n\t */\r\n\tvar path = (function () {\r\n\t    function path() {\r\n\t    }\r\n\t    /**\r\n\t     * Normalize a string path, taking care of '..' and '.' parts.\r\n\t     *\r\n\t     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\r\n\t     * @example Usage example\r\n\t     *   path.normalize('/foo/bar//baz/asdf/quux/..')\r\n\t     *   // returns\r\n\t     *   '/foo/bar/baz/asdf'\r\n\t     * @param [String] p The path to normalize.\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.normalize = function (p) {\r\n\t        // Special case: '' -> '.'\r\n\t        if (p === '') {\r\n\t            p = '.';\r\n\t        }\r\n\t        // It's very important to know if the path is relative or not, since it\r\n\t        // changes how we process .. and reconstruct the split string.\r\n\t        var absolute = p.charAt(0) === path.sep;\r\n\t        // Remove repeated //s\r\n\t        p = path._removeDuplicateSeps(p);\r\n\t        // Try to remove as many '../' as possible, and remove '.' completely.\r\n\t        var components = p.split(path.sep);\r\n\t        var goodComponents = [];\r\n\t        for (var idx = 0; idx < components.length; idx++) {\r\n\t            var c = components[idx];\r\n\t            if (c === '.') {\r\n\t                continue;\r\n\t            }\r\n\t            else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\r\n\t                // In the absolute case: Path is relative to root, so we may pop even if\r\n\t                // goodComponents is empty (e.g. /../ => /)\r\n\t                // In the relative case: We're getting rid of a directory that preceded\r\n\t                // it (e.g. /foo/../bar -> /bar)\r\n\t                goodComponents.pop();\r\n\t            }\r\n\t            else {\r\n\t                goodComponents.push(c);\r\n\t            }\r\n\t        }\r\n\t        // Add in '.' when it's a relative path with no other nonempty components.\r\n\t        // Possible results: '.' and './' (input: [''] or [])\r\n\t        // @todo Can probably simplify this logic.\r\n\t        if (!absolute && goodComponents.length < 2) {\r\n\t            switch (goodComponents.length) {\r\n\t                case 1:\r\n\t                    if (goodComponents[0] === '') {\r\n\t                        goodComponents.unshift('.');\r\n\t                    }\r\n\t                    break;\r\n\t                default:\r\n\t                    goodComponents.push('.');\r\n\t            }\r\n\t        }\r\n\t        p = goodComponents.join(path.sep);\r\n\t        if (absolute && p.charAt(0) !== path.sep) {\r\n\t            p = path.sep + p;\r\n\t        }\r\n\t        return p;\r\n\t    };\r\n\t    /**\r\n\t     * Join all arguments together and normalize the resulting path.\r\n\t     *\r\n\t     * Arguments must be strings.\r\n\t     * @example Usage\r\n\t     *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\r\n\t     *   // returns\r\n\t     *   '/foo/bar/baz/asdf'\r\n\t     *\r\n\t     *   path.join('foo', {}, 'bar')\r\n\t     *   // throws exception\r\n\t     *   TypeError: Arguments to path.join must be strings\r\n\t     * @param [String,...] paths Each component of the path\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.join = function () {\r\n\t        var paths = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            paths[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        // Required: Prune any non-strings from the path. I also prune empty segments\r\n\t        // so we can do a simple join of the array.\r\n\t        var processed = [];\r\n\t        for (var i = 0; i < paths.length; i++) {\r\n\t            var segment = paths[i];\r\n\t            if (typeof segment !== 'string') {\r\n\t                throw new TypeError(\"Invalid argument type to path.join: \" + (typeof segment));\r\n\t            }\r\n\t            else if (segment !== '') {\r\n\t                processed.push(segment);\r\n\t            }\r\n\t        }\r\n\t        return path.normalize(processed.join(path.sep));\r\n\t    };\r\n\t    /**\r\n\t     * Resolves to to an absolute path.\r\n\t     *\r\n\t     * If to isn't already absolute from arguments are prepended in right to left\r\n\t     * order, until an absolute path is found. If after using all from paths still\r\n\t     * no absolute path is found, the current working directory is used as well.\r\n\t     * The resulting path is normalized, and trailing slashes are removed unless\r\n\t     * the path gets resolved to the root directory. Non-string arguments are\r\n\t     * ignored.\r\n\t     *\r\n\t     * Another way to think of it is as a sequence of cd commands in a shell.\r\n\t     *\r\n\t     *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\r\n\t     *\r\n\t     * Is similar to:\r\n\t     *\r\n\t     *     cd foo/bar\r\n\t     *     cd /tmp/file/\r\n\t     *     cd ..\r\n\t     *     cd a/../subfile\r\n\t     *     pwd\r\n\t     *\r\n\t     * The difference is that the different paths don't need to exist and may also\r\n\t     * be files.\r\n\t     * @example Usage example\r\n\t     *   path.resolve('/foo/bar', './baz')\r\n\t     *   // returns\r\n\t     *   '/foo/bar/baz'\r\n\t     *\r\n\t     *   path.resolve('/foo/bar', '/tmp/file/')\r\n\t     *   // returns\r\n\t     *   '/tmp/file'\r\n\t     *\r\n\t     *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\r\n\t     *   // if currently in /home/myself/node, it returns\r\n\t     *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\r\n\t     * @param [String,...] paths\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.resolve = function () {\r\n\t        var paths = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            paths[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        // Monitor for invalid paths, throw out empty paths, and look for the *last*\r\n\t        // absolute path that we see.\r\n\t        var processed = [];\r\n\t        for (var i = 0; i < paths.length; i++) {\r\n\t            var p = paths[i];\r\n\t            if (typeof p !== 'string') {\r\n\t                throw new TypeError(\"Invalid argument type to path.join: \" + (typeof p));\r\n\t            }\r\n\t            else if (p !== '') {\r\n\t                // Remove anything that has occurred before this absolute path, as it\r\n\t                // doesn't matter.\r\n\t                if (p.charAt(0) === path.sep) {\r\n\t                    processed = [];\r\n\t                }\r\n\t                processed.push(p);\r\n\t            }\r\n\t        }\r\n\t        // Special: Remove trailing slash unless it's the root\r\n\t        var resolved = path.normalize(processed.join(path.sep));\r\n\t        if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === path.sep) {\r\n\t            return resolved.substr(0, resolved.length - 1);\r\n\t        }\r\n\t        // Special: If it doesn't start with '/', it's relative and we need to append\r\n\t        // the current directory.\r\n\t        if (resolved.charAt(0) !== path.sep) {\r\n\t            // Remove ./, since we're going to append the current directory.\r\n\t            if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === path.sep)) {\r\n\t                resolved = resolved.length === 1 ? '' : resolved.substr(2);\r\n\t            }\r\n\t            // Append the current directory, which *must* be an absolute path.\r\n\t            var cwd = process.cwd();\r\n\t            if (resolved !== '') {\r\n\t                // cwd will never end in a /... unless it's the root.\r\n\t                resolved = this.normalize(cwd + (cwd !== '/' ? path.sep : '') + resolved);\r\n\t            }\r\n\t            else {\r\n\t                resolved = cwd;\r\n\t            }\r\n\t        }\r\n\t        return resolved;\r\n\t    };\r\n\t    /**\r\n\t     * Solve the relative path from from to to.\r\n\t     *\r\n\t     * At times we have two absolute paths, and we need to derive the relative path\r\n\t     * from one to the other. This is actually the reverse transform of\r\n\t     * path.resolve, which means we see that:\r\n\t     *\r\n\t     *    path.resolve(from, path.relative(from, to)) == path.resolve(to)\r\n\t     *\r\n\t     * @example Usage example\r\n\t     *   path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\r\n\t     *   // returns\r\n\t     *   '..\\\\..\\\\impl\\\\bbb'\r\n\t     *\r\n\t     *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\r\n\t     *   // returns\r\n\t     *   '../../impl/bbb'\r\n\t     * @param [String] from\r\n\t     * @param [String] to\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.relative = function (from, to) {\r\n\t        var i;\r\n\t        // Alright. Let's resolve these two to absolute paths and remove any\r\n\t        // weirdness.\r\n\t        from = path.resolve(from);\r\n\t        to = path.resolve(to);\r\n\t        var fromSegs = from.split(path.sep);\r\n\t        var toSegs = to.split(path.sep);\r\n\t        // Remove the first segment on both, as it's '' (both are absolute paths)\r\n\t        toSegs.shift();\r\n\t        fromSegs.shift();\r\n\t        // There are two segments to this path:\r\n\t        // * Going *up* the directory hierarchy with '..'\r\n\t        // * Going *down* the directory hierarchy with foo/baz/bat.\r\n\t        var upCount = 0;\r\n\t        var downSegs = [];\r\n\t        // Figure out how many things in 'from' are shared with 'to'.\r\n\t        for (i = 0; i < fromSegs.length; i++) {\r\n\t            var seg = fromSegs[i];\r\n\t            if (seg === toSegs[i]) {\r\n\t                continue;\r\n\t            }\r\n\t            // The rest of 'from', including the current element, indicates how many\r\n\t            // directories we need to go up.\r\n\t            upCount = fromSegs.length - i;\r\n\t            break;\r\n\t        }\r\n\t        // The rest of 'to' indicates where we need to change to. We place this\r\n\t        // outside of the loop, as toSegs.length may be greater than fromSegs.length.\r\n\t        downSegs = toSegs.slice(i);\r\n\t        // Special case: If 'from' is '/'\r\n\t        if (fromSegs.length === 1 && fromSegs[0] === '') {\r\n\t            upCount = 0;\r\n\t        }\r\n\t        // upCount can't be greater than the number of fromSegs\r\n\t        // (cd .. from / is still /)\r\n\t        if (upCount > fromSegs.length) {\r\n\t            upCount = fromSegs.length;\r\n\t        }\r\n\t        // Create the final string!\r\n\t        var rv = '';\r\n\t        for (i = 0; i < upCount; i++) {\r\n\t            rv += '../';\r\n\t        }\r\n\t        rv += downSegs.join(path.sep);\r\n\t        // Special case: Remove trailing '/'. Happens if it's all up and no down.\r\n\t        if (rv.length > 1 && rv.charAt(rv.length - 1) === path.sep) {\r\n\t            rv = rv.substr(0, rv.length - 1);\r\n\t        }\r\n\t        return rv;\r\n\t    };\r\n\t    /**\r\n\t     * Return the directory name of a path. Similar to the Unix `dirname` command.\r\n\t     *\r\n\t     * Note that BrowserFS does not validate if the path is actually a valid\r\n\t     * directory.\r\n\t     * @example Usage example\r\n\t     *   path.dirname('/foo/bar/baz/asdf/quux')\r\n\t     *   // returns\r\n\t     *   '/foo/bar/baz/asdf'\r\n\t     * @param [String] p The path to get the directory name of.\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.dirname = function (p) {\r\n\t        // We get rid of //, but we don't modify anything else (e.g. any extraneous .\r\n\t        // and ../ are kept intact)\r\n\t        p = path._removeDuplicateSeps(p);\r\n\t        var absolute = p.charAt(0) === path.sep;\r\n\t        var sections = p.split(path.sep);\r\n\t        // Do 1 if it's /foo/bar, 2 if it's /foo/bar/\r\n\t        if (sections.pop() === '' && sections.length > 0) {\r\n\t            sections.pop();\r\n\t        }\r\n\t        // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.\r\n\t        // If not absolute, the first section is the first part of the path, and is OK\r\n\t        // to return.\r\n\t        if (sections.length > 1 || (sections.length === 1 && !absolute)) {\r\n\t            return sections.join(path.sep);\r\n\t        }\r\n\t        else if (absolute) {\r\n\t            return path.sep;\r\n\t        }\r\n\t        else {\r\n\t            return '.';\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Return the last portion of a path. Similar to the Unix basename command.\r\n\t     * @example Usage example\r\n\t     *   path.basename('/foo/bar/baz/asdf/quux.html')\r\n\t     *   // returns\r\n\t     *   'quux.html'\r\n\t     *\r\n\t     *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')\r\n\t     *   // returns\r\n\t     *   'quux'\r\n\t     * @param [String] p\r\n\t     * @param [String?] ext\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.basename = function (p, ext) {\r\n\t        if (ext === void 0) { ext = \"\"; }\r\n\t        // Special case: Normalize will modify this to '.'\r\n\t        if (p === '') {\r\n\t            return p;\r\n\t        }\r\n\t        // Normalize the string first to remove any weirdness.\r\n\t        p = path.normalize(p);\r\n\t        // Get the last part of the string.\r\n\t        var sections = p.split(path.sep);\r\n\t        var lastPart = sections[sections.length - 1];\r\n\t        // Special case: If it's empty, then we have a string like so: foo/\r\n\t        // Meaning, 'foo' is guaranteed to be a directory.\r\n\t        if (lastPart === '' && sections.length > 1) {\r\n\t            return sections[sections.length - 2];\r\n\t        }\r\n\t        // Remove the extension, if need be.\r\n\t        if (ext.length > 0) {\r\n\t            var lastPartExt = lastPart.substr(lastPart.length - ext.length);\r\n\t            if (lastPartExt === ext) {\r\n\t                return lastPart.substr(0, lastPart.length - ext.length);\r\n\t            }\r\n\t        }\r\n\t        return lastPart;\r\n\t    };\r\n\t    /**\r\n\t     * Return the extension of the path, from the last '.' to end of string in the\r\n\t     * last portion of the path. If there is no '.' in the last portion of the path\r\n\t     * or the first character of it is '.', then it returns an empty string.\r\n\t     * @example Usage example\r\n\t     *   path.extname('index.html')\r\n\t     *   // returns\r\n\t     *   '.html'\r\n\t     *\r\n\t     *   path.extname('index.')\r\n\t     *   // returns\r\n\t     *   '.'\r\n\t     *\r\n\t     *   path.extname('index')\r\n\t     *   // returns\r\n\t     *   ''\r\n\t     * @param [String] p\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.extname = function (p) {\r\n\t        p = path.normalize(p);\r\n\t        var sections = p.split(path.sep);\r\n\t        p = sections.pop();\r\n\t        // Special case: foo/file.ext/ should return '.ext'\r\n\t        if (p === '' && sections.length > 0) {\r\n\t            p = sections.pop();\r\n\t        }\r\n\t        if (p === '..') {\r\n\t            return '';\r\n\t        }\r\n\t        var i = p.lastIndexOf('.');\r\n\t        if (i === -1 || i === 0) {\r\n\t            return '';\r\n\t        }\r\n\t        return p.substr(i);\r\n\t    };\r\n\t    /**\r\n\t     * Checks if the given path is an absolute path.\r\n\t     *\r\n\t     * Despite not being documented, this is a tested part of Node's path API.\r\n\t     * @param [String] p\r\n\t     * @return [Boolean] True if the path appears to be an absolute path.\r\n\t     */\r\n\t    path.isAbsolute = function (p) {\r\n\t        return p.length > 0 && p.charAt(0) === path.sep;\r\n\t    };\r\n\t    /**\r\n\t     * Unknown. Undocumented.\r\n\t     */\r\n\t    path._makeLong = function (p) {\r\n\t        return p;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an object from a path string.\r\n\t     */\r\n\t    path.parse = function (p) {\r\n\t        var allParts = posixSplitPath(p);\r\n\t        return {\r\n\t            root: allParts[0],\r\n\t            dir: allParts[0] + allParts[1].slice(0, -1),\r\n\t            base: allParts[2],\r\n\t            ext: allParts[3],\r\n\t            name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n\t        };\r\n\t    };\r\n\t    path.format = function (pathObject) {\r\n\t        if (pathObject === null || typeof pathObject !== 'object') {\r\n\t            throw new TypeError(\"Parameter 'pathObject' must be an object, not \" + typeof pathObject);\r\n\t        }\r\n\t        var root = pathObject.root || '';\r\n\t        if (typeof root !== 'string') {\r\n\t            throw new TypeError(\"'pathObject.root' must be a string or undefined, not \" +\r\n\t                typeof pathObject.root);\r\n\t        }\r\n\t        var dir = pathObject.dir ? pathObject.dir + path.sep : '';\r\n\t        var base = pathObject.base || '';\r\n\t        return dir + base;\r\n\t    };\r\n\t    path._removeDuplicateSeps = function (p) {\r\n\t        p = p.replace(this._replaceRegex, this.sep);\r\n\t        return p;\r\n\t    };\r\n\t    // The platform-specific file separator. BrowserFS uses `/`.\r\n\t    path.sep = '/';\r\n\t    path._replaceRegex = new RegExp(\"//+\", 'g');\r\n\t    // The platform-specific path delimiter. BrowserFS uses `:`.\r\n\t    path.delimiter = ':';\r\n\t    path.posix = path;\r\n\t    // XXX: Typing hack. We don't actually support win32.\r\n\t    path.win32 = path;\r\n\t    return path;\r\n\t}());\r\n\r\n\r\n\treturn path;\r\n});"]}