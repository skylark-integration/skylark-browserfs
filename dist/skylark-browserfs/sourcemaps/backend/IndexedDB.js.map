{"version":3,"sources":["backend/IndexedDB.js"],"names":["define","key_value_filesystem","api_error","global","util","AsyncKeyValueFileSystem","ApiError","ErrorCode","arrayBuffer2Buffer","buffer2ArrayBuffer","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","convertError","e","message","toString","name","ENOENT","ENOSPC","EIO","onErrorHandler","cb","code","preventDefault","undefined","IndexedDBROTransaction","[object Object]","tx","store","this","key","r","get","onerror","onsuccess","event","result","target","IndexedDBRWTransaction","super","data","overwrite","arraybuffer","put","add","setTimeout","_e","abort","IndexedDBStore","db","storeName","openReq","open","onupgradeneeded","objectStoreNames","contains","deleteObjectStore","createObjectStore","EACCES","IndexedDBFileSystem","Name","transaction","objectStore","clear","type","EINVAL","cacheSize","opts","Create","idbfs","init","Options","optional","description"],"mappings":"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","file":"../../backend/IndexedDB.js","sourcesContent":["define([\n    '../generic/key_value_filesystem',\n    '../core/api_error',\n    '../core/global',\n    '../core/util'\n], function (key_value_filesystem, api_error, global, util) {\n    'use strict';\n    const { AsyncKeyValueFileSystem } =  key_value_filesystem;\n    const { ApiError, ErrorCode }  = api_error;\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = util;\n\n    /**\n     * Get the indexedDB constructor for the current browser.\n     * @hidden\n     */\n    const indexedDB = global.indexedDB ||\n        global.mozIndexedDB ||\n        global.webkitIndexedDB ||\n        global.msIndexedDB;\n    /**\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\n     * standardized BrowserFS API error.\n     * @hidden\n     */\n    function convertError(e, message = e.toString()) {\n        switch (e.name) {\n            case \"NotFoundError\":\n                return new ApiError(ErrorCode.ENOENT, message);\n            case \"QuotaExceededError\":\n                return new ApiError(ErrorCode.ENOSPC, message);\n            default:\n                // The rest do not seem to map cleanly to standard error codes.\n                return new ApiError(ErrorCode.EIO, message);\n        }\n    }\n    /**\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\n     * handle them generically: Call the user-supplied callback with a translated\n     * version of the error, and let the error bubble up.\n     * @hidden\n     */\n    function onErrorHandler(cb, code = ErrorCode.EIO, message = null) {\n        return function (e) {\n            // Prevent the error from canceling the transaction.\n            e.preventDefault();\n            cb(new ApiError(code, message !== null ? message : undefined));\n        };\n    }\n    /**\n     * @hidden\n     */\n    class IndexedDBROTransaction {\n        constructor(tx, store) {\n            this.tx = tx;\n            this.store = store;\n        }\n        get(key, cb) {\n            try {\n                const r = this.store.get(key);\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = (event) => {\n                    // IDB returns the value 'undefined' when you try to get keys that\n                    // don't exist. The caller expects this behavior.\n                    const result = event.target.result;\n                    if (result === undefined) {\n                        cb(null, result);\n                    }\n                    else {\n                        // IDB data is stored as an ArrayBuffer\n                        cb(null, arrayBuffer2Buffer(result));\n                    }\n                };\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    class IndexedDBRWTransaction extends IndexedDBROTransaction {\n        constructor(tx, store) {\n            super(tx, store);\n        }\n        put(key, data, overwrite, cb) {\n            try {\n                const arraybuffer = buffer2ArrayBuffer(data);\n                let r;\n                // Note: 'add' will never overwrite an existing key.\n                r = overwrite ? this.store.put(arraybuffer, key) : this.store.add(arraybuffer, key);\n                // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = (event) => {\n                    cb(null, true);\n                };\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n        del(key, cb) {\n            try {\n                // NOTE: IE8 has a bug with identifiers named 'delete' unless used as a string\n                // like this.\n                // http://stackoverflow.com/a/26479152\n                const r = this.store['delete'](key);\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = (event) => {\n                    cb();\n                };\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n        commit(cb) {\n            // Return to the event loop to commit the transaction.\n            setTimeout(cb, 0);\n        }\n        abort(cb) {\n            let _e = null;\n            try {\n                this.tx.abort();\n            }\n            catch (e) {\n                _e = convertError(e);\n            }\n            finally {\n                cb(_e);\n            }\n        }\n    }\n    class IndexedDBStore {\n        constructor(db, storeName) {\n            this.db = db;\n            this.storeName = storeName;\n        }\n        static Create(storeName, cb) {\n            const openReq = indexedDB.open(storeName, 1);\n            openReq.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                // Huh. This should never happen; we're at version 1. Why does another\n                // database exist?\n                if (db.objectStoreNames.contains(storeName)) {\n                    db.deleteObjectStore(storeName);\n                }\n                db.createObjectStore(storeName);\n            };\n            openReq.onsuccess = (event) => {\n                cb(null, new IndexedDBStore(event.target.result, storeName));\n            };\n            openReq.onerror = onErrorHandler(cb, ErrorCode.EACCES);\n        }\n        name() {\n            return IndexedDBFileSystem.Name + \" - \" + this.storeName;\n        }\n        clear(cb) {\n            try {\n                const tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();\n                r.onsuccess = (event) => {\n                    // Use setTimeout to commit transaction.\n                    setTimeout(cb, 0);\n                };\n                r.onerror = onErrorHandler(cb);\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n        beginTransaction(type = 'readonly') {\n            const tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);\n            if (type === 'readwrite') {\n                return new IndexedDBRWTransaction(tx, objectStore);\n            }\n            else if (type === 'readonly') {\n                return new IndexedDBROTransaction(tx, objectStore);\n            }\n            else {\n                throw new ApiError(ErrorCode.EINVAL, 'Invalid transaction type.');\n            }\n        }\n    }\n    /**\n     * A file system that uses the IndexedDB key value file system.\n     */\n    class IndexedDBFileSystem extends AsyncKeyValueFileSystem {\n        constructor(cacheSize) {\n            super(cacheSize);\n        }\n        /**\n         * Constructs an IndexedDB file system with the given options.\n         */\n        static Create(opts = {}, cb) {\n            IndexedDBStore.Create(opts.storeName ? opts.storeName : 'browserfs', (e, store) => {\n                if (store) {\n                    const idbfs = new IndexedDBFileSystem(typeof (opts.cacheSize) === 'number' ? opts.cacheSize : 100);\n                    idbfs.init(store, (e) => {\n                        if (e) {\n                            cb(e);\n                        }\n                        else {\n                            cb(null, idbfs);\n                        }\n                    });\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        static isAvailable() {\n            // In Safari's private browsing mode, indexedDB.open returns NULL.\n            // In Firefox, it throws an exception.\n            // In Chrome, it \"just works\", and clears the database when you leave the page.\n            // Untested: Opera, IE.\n            try {\n                return typeof indexedDB !== 'undefined' && null !== indexedDB.open(\"__browserfs_test__\");\n            }\n            catch (e) {\n                return false;\n            }\n        }\n    }\n    IndexedDBFileSystem.Name = \"IndexedDB\";\n    IndexedDBFileSystem.Options = {\n        storeName: {\n            type: \"string\",\n            optional: true,\n            description: \"The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name.\"\n        },\n        cacheSize: {\n            type: \"number\",\n            optional: true,\n            description: \"The size of the inode cache. Defaults to 100. A size of 0 or below disables caching.\"\n        }\n    };\n\n\n    IndexedDBFileSystem.IndexedDBROTransaction = IndexedDBROTransaction;\n    IndexedDBFileSystem.IndexedDBRWTransaction = IndexedDBRWTransaction;\n    IndexedDBFileSystem.IndexedDBStore = IndexedDBStore;\n\n    return IndexedDBFileSystem;\n});"]}