{"version":3,"sources":["backend/HTTPRequest.js"],"names":["define","file_system","api_error","file_flag","util","node_fs_stats","preload_file","xhr","fetch","file_index","BaseFileSystem","ApiError","ErrorCode","ActionType","copyingSlice","Stats","NoSyncFile","xhrIsAvailable","asyncDownloadFile","syncDownloadFile","getFileSizeAsync","getFileSizeSync","fetchIsAvailable","fetchFileAsync","fetchFileSizeAsync","FileIndex","isFileInode","isDirInode","syncNotAvailableError","ENOTSUP","HTTPRequest","[object Object]","index","prefixUrl","preferXHR","super","length","charAt","this","_index","fromListing","_requestFileAsyncInternal","_requestFileSizeAsyncInternal","_requestFileSyncInternal","_requestFileSizeSyncInternal","opts","cb","undefined","e","data","baseUrl","fileIterator","file","fileData","Name","path","buffer","inode","getInode","EISDIR","ENOENT","stats","getData","size","isLstat","_requestFileSizeAsync","clone","getStats","FileError","EINVAL","_requestFileSizeSync","flags","mode","isWriteable","EPERM","self","pathExistsAction","THROW_EXCEPTION","TRUNCATE_FILE","EEXIST","NOP","_requestFileAsync","err","_requestFileSync","readdirSync","getListing","ENOTDIR","fname","encoding","flag","oldCb","open","fd","arg","close","err2","fdBuff","getBuffer","buff","toString","tryToString","openSync","closeSync","filePath","slice","p","type","_getHTTPPath","Options","optional","description"],"mappings":"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","file":"../../backend/HTTPRequest.js","sourcesContent":["define([\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/util',\n    '../core/node_fs_stats',\n    '../generic/preload_file',\n    '../generic/xhr',\n    '../generic/fetch',\n    '../generic/file_index'\n], function (file_system, api_error, file_flag, util, node_fs_stats, preload_file, xhr, fetch, file_index) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode }  = api_error;\n    const { ActionType }  = file_flag;\n    const { copyingSlice }  = util;\n    const  {Stats} = node_fs_stats;\n    const { NoSyncFile }  = preload_file;\n    const { xhrIsAvailable, asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync }  = xhr;\n    const { fetchIsAvailable, fetchFileAsync, fetchFileSizeAsync }  = fetch;\n    const { FileIndex, isFileInode, isDirInode }  = file_index;\n    /**\n     * Try to convert the given buffer into a string, and pass it to the callback.\n     * Optimization that removes the needed try/catch into a helper function, as\n     * this is an uncommon case.\n     * @hidden\n     */\n    function tryToString(buff, encoding, cb) {\n        try {\n            cb(null, buff.toString(encoding));\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    function syncNotAvailableError() {\n        throw new ApiError(ErrorCode.ENOTSUP, `Synchronous HTTP download methods are not available in this environment.`);\n    }\n    /**\n     * A simple filesystem backed by HTTP downloads. You must create a directory listing using the\n     * `make_http_index` tool provided by BrowserFS.\n     *\n     * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by\n     * running `make_http_index` in your terminal in the directory you would like to index:\n     *\n     * ```\n     * make_http_index > index.json\n     * ```\n     *\n     * Listings objects look like the following:\n     *\n     * ```json\n     * {\n     *   \"home\": {\n     *     \"jvilk\": {\n     *       \"someFile.txt\": null,\n     *       \"someDir\": {\n     *         // Empty directory\n     *       }\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*\n     */\n    class HTTPRequest extends BaseFileSystem {\n        constructor(index, prefixUrl = '', preferXHR = false) {\n            super();\n            // prefix_url must end in a directory separator.\n            if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {\n                prefixUrl = prefixUrl + '/';\n            }\n            this.prefixUrl = prefixUrl;\n            this._index = FileIndex.fromListing(index);\n            if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {\n                this._requestFileAsyncInternal = fetchFileAsync;\n                this._requestFileSizeAsyncInternal = fetchFileSizeAsync;\n            }\n            else {\n                this._requestFileAsyncInternal = asyncDownloadFile;\n                this._requestFileSizeAsyncInternal = getFileSizeAsync;\n            }\n            if (xhrIsAvailable) {\n                this._requestFileSyncInternal = syncDownloadFile;\n                this._requestFileSizeSyncInternal = getFileSizeSync;\n            }\n            else {\n                this._requestFileSyncInternal = syncNotAvailableError;\n                this._requestFileSizeSyncInternal = syncNotAvailableError;\n            }\n        }\n        /**\n         * Construct an HTTPRequest file system backend with the given options.\n         */\n        static Create(opts, cb) {\n            if (opts.index === undefined) {\n                opts.index = `index.json`;\n            }\n            if (typeof (opts.index) === \"string\") {\n                asyncDownloadFile(opts.index, \"json\", (e, data) => {\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        cb(null, new HTTPRequest(data, opts.baseUrl));\n                    }\n                });\n            }\n            else {\n                cb(null, new HTTPRequest(opts.index, opts.baseUrl));\n            }\n        }\n        static isAvailable() {\n            return xhrIsAvailable || fetchIsAvailable;\n        }\n        empty() {\n            this._index.fileIterator(function (file) {\n                file.fileData = null;\n            });\n        }\n        getName() {\n            return HTTPRequest.Name;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system. We could calculate the total space, but that's not\n            // important right now.\n            cb(0, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            // Synchronous operations are only available via the XHR interface for now.\n            return xhrIsAvailable;\n        }\n        /**\n         * Special HTTPFS function: Preload the given file into the index.\n         * @param [String] path\n         * @param [BrowserFS.Buffer] buffer\n         */\n        preloadFile(path, buffer) {\n            const inode = this._index.getInode(path);\n            if (isFileInode(inode)) {\n                if (inode === null) {\n                    throw ApiError.ENOENT(path);\n                }\n                const stats = inode.getData();\n                stats.size = buffer.length;\n                stats.fileData = buffer;\n            }\n            else {\n                throw ApiError.EISDIR(path);\n            }\n        }\n        stat(path, isLstat, cb) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(ApiError.ENOENT(path));\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    this._requestFileSizeAsync(path, function (e, size) {\n                        if (e) {\n                            return cb(e);\n                        }\n                        stats.size = size;\n                        cb(null, Stats.clone(stats));\n                    });\n                }\n                else {\n                    cb(null, Stats.clone(stats));\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n                cb(null, stats);\n            }\n            else {\n                cb(ApiError.FileError(ErrorCode.EINVAL, path));\n            }\n        }\n        statSync(path, isLstat) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    stats.size = this._requestFileSizeSync(path);\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n            }\n            else {\n                throw ApiError.FileError(ErrorCode.EINVAL, path);\n            }\n            return stats;\n        }\n        open(path, flags, mode, cb) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                return cb(new ApiError(ErrorCode.EPERM, path));\n            }\n            const self = this;\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(ApiError.ENOENT(path));\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        return cb(ApiError.EEXIST(path));\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), stats.fileData));\n                        }\n                        // @todo be lazier about actually requesting the file\n                        this._requestFileAsync(path, 'buffer', function (err, buffer) {\n                            if (err) {\n                                return cb(err);\n                            }\n                            // we don't initially have file sizes\n                            stats.size = buffer.length;\n                            stats.fileData = buffer;\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), buffer));\n                        });\n                        break;\n                    default:\n                        return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.'));\n                }\n            }\n            else {\n                return cb(ApiError.EISDIR(path));\n            }\n        }\n        openSync(path, flags, mode) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, path);\n            }\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw ApiError.EEXIST(path);\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return new NoSyncFile(this, path, flags, Stats.clone(stats), stats.fileData);\n                        }\n                        // @todo be lazier about actually requesting the file\n                        const buffer = this._requestFileSync(path, 'buffer');\n                        // we don't initially have file sizes\n                        stats.size = buffer.length;\n                        stats.fileData = buffer;\n                        return new NoSyncFile(this, path, flags, Stats.clone(stats), buffer);\n                    default:\n                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw ApiError.EISDIR(path);\n            }\n        }\n        readdir(path, cb) {\n            try {\n                cb(null, this.readdirSync(path));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            else if (isDirInode(inode)) {\n                return inode.getListing();\n            }\n            else {\n                throw ApiError.ENOTDIR(path);\n            }\n        }\n        /**\n         * We have the entire file as a buffer; optimize readFile.\n         */\n        readFile(fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (!err) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    cb(err, copyingSlice(fdBuff));\n                }\n                else {\n                    tryToString(fdBuff, encoding, cb);\n                }\n            });\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        _getHTTPPath(filePath) {\n            if (filePath.charAt(0) === '/') {\n                filePath = filePath.slice(1);\n            }\n            return this.prefixUrl + filePath;\n        }\n        _requestFileAsync(p, type, cb) {\n            this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);\n        }\n        _requestFileSync(p, type) {\n            return this._requestFileSyncInternal(this._getHTTPPath(p), type);\n        }\n        /**\n         * Only requests the HEAD content, for the file size.\n         */\n        _requestFileSizeAsync(path, cb) {\n            this._requestFileSizeAsyncInternal(this._getHTTPPath(path), cb);\n        }\n        _requestFileSizeSync(path) {\n            return this._requestFileSizeSyncInternal(this._getHTTPPath(path));\n        }\n    }\n    HTTPRequest.Name = \"HTTPRequest\";\n    HTTPRequest.Options = {\n        index: {\n            type: [\"string\", \"object\"],\n            optional: true,\n            description: \"URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`.\"\n        },\n        baseUrl: {\n            type: \"string\",\n            optional: true,\n            description: \"Used as the URL prefix for fetched files. Default: Fetch files relative to the index.\"\n        },\n        preferXHR: {\n            type: \"boolean\",\n            optional: true,\n            description: \"Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false\"\n        }\n    };\n\n    return HTTPRequest;\n});"]}