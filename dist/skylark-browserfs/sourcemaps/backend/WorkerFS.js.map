{"version":3,"sources":["backend/WorkerFS.js"],"names":["define","buffers","file_system","api_error","file_flag","util","file","node_fs_stats","preload_file","global","fs","BaseFileSystem","ApiError","ErrorCode","FileFlag","buffer2ArrayBuffer","arrayBuffer2Buffer","emptyBuffer","BaseFile","Stats","PreloadFile","Buffer","SpecialArgType","CallbackArgumentConverter","[object Object]","this","_callbacks","_nextId","cb","id","type","CB","FileDescriptorArgumentConverter","_fileDescriptors","fd","p","flag","data","stat","err","stats","bufferToTransferrableObject","toBuffer","isReadable","read","alloc","size","bytesRead","buff","FD","path","getFlagString","ArrayBuffer","request","fdArg","args","_applyFdChanges","method","e","remoteFd","transferrableObjectToBuffer","remoteStats","fromBuffer","getFileFlag","isWriteable","write","length","isAppendable","getPos","applyStatChanges","mode","chmod","truncate","apiErrorLocal2Remote","API_ERROR","errorData","writeToBuffer","apiErrorRemote2Local","errorLocal2Remote","ERROR","name","message","stack","errorRemote2Local","cnstr","Error","statsLocal2Remote","STATS","statsData","statsRemote2Local","fileFlagLocal2Remote","FILEFLAG","flagStr","fileFlagRemote2Local","remoteFlag","bufferLocal2Remote","BUFFER","bufferRemote2Local","buffArg","WorkerFile","_fs","_path","_flag","_stat","remoteFdId","contents","super","_remoteFdId","getBuffer","getStats","getPath","getFlag","_syncClose","isDirty","syncClose","resetDirty","WorkerFS","worker","_callbackConverter","_isInitialized","_isReadOnly","_supportLinks","_supportProps","_worker","addEventListener","resp","hasOwnProperty","i","fixedArgs","Array","_argRemote2Local","toLocalArg","cbId","apply","opts","_initialize","fdConverter","argLocal2Remote","arg","requestArgs","toRemoteArg","argRemote2Local","fixedRequestArgs","specialArg","arguments","countdown","fixedArg","browserfsMessage","postMessage","remoteCb","applyFdAPIRequest","response","rootFs","getRootFS","probeResponse","PROBE","isReadOnly","supportsLinks","supportsProps","rootFS","Name","oldPath","newPath","_rpc","isLstat","cache","len","fname","encoding","isLchmod","isLchown","uid","gid","atime","mtime","srcpath","dstpath","_argLocal2Remote","methodName","Options","description","validator","v","EINVAL"],"mappings":";;;;;;;AAAAA,QACI,kBACA,sBACA,oBACA,oBACA,eACA,eACA,wBACA,0BACA,iBACA,mBACD,SAAUC,EAAQC,EAAaC,EAAWC,EAAWC,EAAMC,EAAMC,EAAeC,EAAcC,EAAQC,GACrG,aAEA,MAAMC,eAAEA,GAAmBT,GACrBU,SAAEA,EAAQC,UAAEA,GAAeV,GAC3BW,SAAEA,GAAcV,GAChBW,mBAAEA,EAAkBC,mBAAEA,EAAkBC,YAAEA,GAAiBZ,GAC3Da,SAAEA,GAAcZ,GAChBa,MAAEA,GAAWZ,GACba,YAACA,GAAgBZ,GACjBa,OAAEA,GAAWpB,EAKnB,IAAIqB,GACJ,SAAWA,GAEPA,EAAeA,EAAmB,GAAI,GAAK,KAE3CA,EAAeA,EAAmB,GAAI,GAAK,KAE3CA,EAAeA,EAA0B,UAAI,GAAK,YAElDA,EAAeA,EAAsB,MAAI,GAAK,QAE9CA,EAAeA,EAAsB,MAAI,GAAK,QAE9CA,EAAeA,EAAyB,SAAI,GAAK,WAEjDA,EAAeA,EAAuB,OAAI,GAAK,SAE/CA,EAAeA,EAAsB,MAAI,GAAK,QAhBlD,CAiBGA,IAAmBA,aAMhBC,EACFC,cACIC,KAAKC,cACLD,KAAKE,QAAU,EAEnBH,YAAYI,GACR,MAAMC,EAAKJ,KAAKE,UAEhB,OADAF,KAAKC,WAAWG,GAAMD,GAElBE,KAAMR,EAAeS,GACrBF,GAAIA,GAGZL,WAAWK,GACP,MAAMD,EAAKH,KAAKC,WAAWG,GAE3B,cADOJ,KAAKC,WAAWG,GAChBD,SAMTI,EACFR,cACIC,KAAKQ,oBACLR,KAAKE,QAAU,EAEnBH,YAAYU,EAAIC,EAAGC,EAAMR,GACrB,MAAMC,EAAKJ,KAAKE,UAChB,IAAIU,EACAC,EACJb,KAAKQ,iBAAiBJ,GAAMK,EAE5BA,EAAGI,KAAK,CAACC,EAAKC,KACND,EACAX,EAAGW,IAGHD,EAAOG,EAA4BD,EAAME,YAErCN,EAAKO,aACLT,EAAGU,KAAKvB,EAAOwB,MAAML,EAAMM,MAAO,EAAGN,EAAMM,KAAM,EAAG,CAACP,EAAKQ,EAAWC,KAC7DT,EACAX,EAAGW,IAGHF,EAAOI,EAA4BO,GACnCpB,EAAG,MACCE,KAAMR,EAAe2B,GACrBpB,GAAIA,EACJQ,KAAMA,EACNC,KAAMA,EACNY,KAAMf,EACNC,KAAMA,EAAKe,qBAQvBvB,EAAG,MACCE,KAAMR,EAAe2B,GACrBpB,GAAIA,EACJQ,KAAM,IAAIe,YAAY,GACtBd,KAAMA,EACNY,KAAMf,EACNC,KAAMA,EAAKe,qBAM/B3B,kBAAkB6B,EAASzB,GACvB,MAAM0B,EAAQD,EAAQE,KAAK,GAC3B9B,KAAK+B,gBAAgBF,EAAO,CAACf,EAAKL,KAC1BK,EACAX,EAAGW,GAIHL,EAAGmB,EAAQI,QAASC,IACO,UAAnBL,EAAQI,eACDhC,KAAKQ,iBAAiBqB,EAAMzB,IAEvCD,EAAG8B,OAKnBlC,gBAAgBmC,EAAU/B,GACtB,MAAMM,EAAKT,KAAKQ,iBAAiB0B,EAAS9B,IAAKQ,EAAOuB,EAA4BD,EAAStB,MAAOwB,EAAc1C,EAAM2C,WAAWF,EAA4BD,EAASrB,OAEhKF,EAAOtB,EAASiD,YAAYJ,EAASvB,MACvCA,EAAK4B,cAGL9B,EAAG+B,MAAM5B,EAAM,EAAGA,EAAK6B,OAAQ9B,EAAK+B,eAAiBjC,EAAGkC,SAAW,EAAIV,IACnE,SAASW,IAELnC,EAAGI,KAAK,CAACoB,EAAGlB,KACJkB,EACA9B,EAAG8B,GAGClB,EAAM8B,OAAST,EAAYS,KAC3BpC,EAAGqC,MAAMV,EAAYS,KAAOZ,IACxB9B,EAAG8B,EAAGxB,KAIVN,EAAG8B,EAAGxB,KAKlBwB,EACA9B,EAAG8B,GAMEtB,EAAK+B,eAMNE,IALAnC,EAAGsC,SAASnC,EAAK6B,OAAQ,KACrBG,QAUhBzC,EAAG,KAAMM,IAOrB,SAASuC,EAAqBf,GAC1B,OACI5B,KAAMR,EAAeoD,UACrBC,UAAWlC,EAA4BiB,EAAEkB,kBAMjD,SAASC,EAAqBnB,GAC1B,OAAO9C,EAASkD,WAAWF,EAA4BF,EAAEiB,YAK7D,SAASG,EAAkBpB,GACvB,OACI5B,KAAMR,EAAeyD,MACrBC,KAAMtB,EAAEsB,KACRC,QAASvB,EAAEuB,QACXC,MAAOxB,EAAEwB,OAMjB,SAASC,EAAkBzB,GACvB,IAAI0B,EAAQ3E,EAAOiD,EAAEsB,MACE,mBAAZ,IACPI,EAAQC,OAEZ,MAAM9C,EAAM,IAAI6C,EAAM1B,EAAEuB,SAExB,OADA1C,EAAI2C,MAAQxB,EAAEwB,MACP3C,EAKX,SAAS+C,EAAkB9C,GACvB,OACIV,KAAMR,EAAeiE,MACrBC,UAAW/C,EAA4BD,EAAME,aAMrD,SAAS+C,EAAkBjD,GACvB,OAAOrB,EAAM2C,WAAWF,EAA4BpB,EAAMgD,YAK9D,SAASE,EAAqBtD,GAC1B,OACIN,KAAMR,EAAeqE,SACrBC,QAASxD,EAAKe,iBAMtB,SAAS0C,EAAqBC,GAC1B,OAAOhF,EAASiD,YAAY+B,EAAWF,SAK3C,SAASnD,EAA4BO,GACjC,OAAOjC,EAAmBiC,GAK9B,SAASY,EAA4BZ,GACjC,OAAOhC,EAAmBgC,GAK9B,SAAS+C,EAAmB/C,GACxB,OACIlB,KAAMR,EAAe0E,OACrB3D,KAAMI,EAA4BO,IAM1C,SAASiD,EAAmBC,GACxB,OAAOtC,EAA4BsC,EAAQ7D,YAiBzC8D,UAAmB/E,EACrBI,YAAY4E,EAAKC,EAAOC,EAAOC,EAAOC,EAAYC,GAC9CC,MAAMN,EAAKC,EAAOC,EAAOC,EAAOE,GAChChF,KAAKkF,YAAcH,EAEvBhF,gBACI,OAAOC,KAAKkF,YAKhBnF,cACI,OACIM,KAAMR,EAAe2B,GACrBpB,GAAIJ,KAAKkF,YACTtE,KAAMI,EAA4BhB,KAAKmF,aACvCtE,KAAMG,EAA4BhB,KAAKoF,WAAWnE,YAClDQ,KAAMzB,KAAKqF,UACX1E,KAAMX,KAAKsF,UAAU5D,iBAG7B3B,KAAKI,GACDH,KAAKuF,WAAW,OAAQpF,GAE5BJ,MAAMI,GACFH,KAAKuF,WAAW,QAASpF,GAE7BJ,WAAWM,EAAMF,GACTH,KAAKwF,UACLxF,KAAK2E,IAAIc,UAAUpF,EAAML,KAAOiC,IACvBA,GACDjC,KAAK0F,aAETvF,EAAG8B,KAIP9B,WA+BNwF,UAAiBzG,EAKnBa,YAAY6F,GA/EhB,IAAuBhF,EAgFfqE,QACAjF,KAAK6F,mBAAqB,IAAI/F,EAC9BE,KAAK8F,gBAAiB,EACtB9F,KAAK+F,aAAc,EACnB/F,KAAKgG,eAAgB,EACrBhG,KAAKiG,eAAgB,EACrBjG,KAAKkG,QAAUN,EACf5F,KAAKkG,QAAQC,iBAAiB,UAAYlE,IACtC,MAAMmE,EAAOnE,EAAErB,KACf,IAzFWA,EAyFOwF,IAxFK,iBAATxF,GAAqBA,EAAKyF,eAAe,qBAAuBzF,EAAuB,iBAwF5E,CACrB,IAAI0F,EACJ,MAAMxE,EAAOsE,EAAKtE,KACZyE,EAAY,IAAIC,MAAM1E,EAAKW,QAEjC,IAAK6D,EAAI,EAAGA,EAAIC,EAAU9D,OAAQ6D,IAC9BC,EAAUD,GAAKtG,KAAKyG,iBAAiB3E,EAAKwE,IAE9CtG,KAAK6F,mBAAmBa,WAAWN,EAAKO,MAAMC,MAAM,KAAML,MAItExG,cAAc8G,EAAM1G,GAChB,MAAMlB,EAAK,IAAI0G,EAASkB,EAAKjB,QAC7B3G,EAAG6H,YAAY,KACX3G,EAAG,KAAMlB,KAGjBc,qBACI,MAAkC,oBAApB,eAAuD,oBAAb,OAK5DA,4BAA4B6F,GACxB,MAAMmB,EAAc,IAAIxG,EACxB,SAASyG,EAAgBC,EAAKC,EAAa/G,GACvC,cAAe8G,GACX,IAAK,SACGA,aAAevH,EACfS,EAAG,KAAM0D,EAAkBoD,IAEtBA,aAAe9H,EACpBgB,EAAG,KAAM6C,EAAqBiE,IAEzBA,aAAexH,EAEpBU,EAAG,KAAM4G,EAAYI,YAAYF,EAAKC,EAAY,GAAIA,EAAY,GAAI/G,IAEjE8G,aAAe5H,EACpBc,EAAG,KAAM8D,EAAqBgD,IAEzBA,aAAerH,EACpBO,EAAG,KAAMmE,EAAmB2C,IAEvBA,aAAerD,MACpBzD,EAAG,KAAMkD,EAAkB4D,IAG3B9G,EAAG,KAAM8G,GAEb,MACJ,QACI9G,EAAG,KAAM8G,IAIrB,SAASG,EAAgBH,EAAKI,GAC1B,IAAKJ,EACD,OAAOA,EAEX,cAAeA,GACX,IAAK,SACD,GAA2B,iBAAhBA,EAAU,KAgEjB,OAAOA,EAhE0B,CACjC,MAAMK,EAAaL,EACnB,OAAQK,EAAWjH,MACf,KAAKR,EAAeS,GAChB,MAAMqG,EAAOM,EAAI7G,GACjB,OAAO,WACH,IAAIkG,EACJ,MAAMC,EAAY,IAAIC,MAAMe,UAAU9E,QACtC,IAAIe,EAASgE,EAAYD,UAAU9E,OAYnC,IAAK6D,EAAI,EAAGA,EAAIiB,UAAU9E,OAAQ6D,IAE9B,EAAEA,EAAGW,KACDD,EAAgBC,EAAKI,EAAkB,CAACvG,EAAK2G,KACzClB,EAAUD,GAAKmB,EACX3G,EAfR0G,EAAY,IACZA,GAAa,EACbhE,GACIkE,kBAAkB,EAClBf,KAAMA,EACN7E,MAAOkB,EAWelC,KAT1B8E,EAAO+B,YAAYnE,IAWU,KAAdgE,IACPhE,GACIkE,kBAAkB,EAClBf,KAAMA,EACN7E,KAAMyE,GAEVX,EAAO+B,YAAYnE,OAZ/B,CAeG8C,EAAGiB,UAAUjB,IAEK,IAArBiB,UAAU9E,SACVe,GACIkE,kBAAkB,EAClBf,KAAMA,EACN7E,KAAMyE,GAEVX,EAAO+B,YAAYnE,KAG/B,KAAK3D,EAAeoD,UAChB,OAAOG,EAAqBkE,GAChC,KAAKzH,EAAeiE,MAChB,OAAOE,EAAkBsD,GAC7B,KAAKzH,EAAeqE,SAChB,OAAOE,EAAqBkD,GAChC,KAAKzH,EAAe0E,OAChB,OAAOC,EAAmB8C,GAC9B,KAAKzH,EAAeyD,MAChB,OAAOI,EAAkB4D,GAC7B,QAEI,OAAOL,GAMvB,QACI,OAAOA,GAjO3B,IAAsBrG,EAoOdgF,EAAOO,iBAAiB,UAAYlE,IAChC,MAAML,EAAUK,EAAErB,KAClB,IAtOUA,EAsOOgB,IArOM,iBAAThB,GAAqBA,EAAKyF,eAAe,qBAAuBzF,EAAuB,iBAqO1E,CACvB,MAAMkB,EAAOF,EAAQE,KAAMyE,EAAY,IAAIC,MAAM1E,EAAKW,QACtD,OAAQb,EAAQI,QACZ,IAAK,QACL,IAAK,OACD,MAEI,MAAM4F,EAAW9F,EAAK,GACtBiF,EAAYc,kBAAkBjG,EAAUd,IAEpC,MAAMgH,GACFJ,kBAAkB,EAClBf,KAAMiB,EAASxH,GACf0B,KAAMhB,GAAOkC,EAAqBlC,QAEtC8E,EAAO+B,YAAYG,MAV3B,GAaA,MACJ,IAAK,QACD,MACI,MAAMC,EAAS9I,EAAG+I,YAAaJ,EAAW9F,EAAK,GAAImG,GAC/C5H,KAAMR,EAAeqI,MACrBC,WAAYJ,EAAOI,aACnBC,cAAeL,EAAOK,gBACtBC,cAAeN,EAAOM,iBACvBP,GACCJ,kBAAkB,EAClBf,KAAMiB,EAASxH,GACf0B,MAAOmG,IAEXrC,EAAO+B,YAAYG,IAXvB,GAaA,MACJ,QAEI,IAAK,IAAIxB,EAAI,EAAGA,EAAIxE,EAAKW,OAAQ6D,IAC7BC,EAAUD,GAAKc,EAAgBtF,EAAKwE,GAAIC,GAE5C,MAAM+B,EAASrJ,EAAG+I,YAClBM,EAAO1G,EAAQI,QAAQ4E,MAAM0B,EAAQ/B,OAMzDxG,UACI,OAAO4F,EAAS4C,KAEpBxI,aAAe,OAAOC,KAAK+F,YAC3BhG,gBAAkB,OAAO,EACzBA,gBAAkB,OAAOC,KAAKgG,cAC9BjG,gBAAkB,OAAOC,KAAKiG,cAC9BlG,OAAOyI,EAASC,EAAStI,GACrBH,KAAK0I,KAAK,SAAUnB,WAExBxH,KAAKW,EAAGiI,EAASxI,GACbH,KAAK0I,KAAK,OAAQnB,WAEtBxH,KAAKW,EAAGC,EAAMkC,EAAM1C,GAChBH,KAAK0I,KAAK,OAAQnB,WAEtBxH,OAAOW,EAAGP,GACNH,KAAK0I,KAAK,SAAUnB,WAExBxH,MAAMW,EAAGP,GACLH,KAAK0I,KAAK,QAASnB,WAEvBxH,MAAMW,EAAGmC,EAAM1C,GACXH,KAAK0I,KAAK,QAASnB,WAEvBxH,QAAQW,EAAGP,GACPH,KAAK0I,KAAK,UAAWnB,WAEzBxH,OAAOW,EAAGP,GACNH,KAAK0I,KAAK,SAAUnB,WAExBxH,SAASW,EAAGkI,EAAOzI,GACfH,KAAK0I,KAAK,WAAYnB,WAE1BxH,SAASW,EAAGmI,EAAK1I,GACbH,KAAK0I,KAAK,WAAYnB,WAE1BxH,SAAS+I,EAAOC,EAAUpI,EAAMR,GAC5BH,KAAK0I,KAAK,WAAYnB,WAE1BxH,UAAU+I,EAAOlI,EAAMmI,EAAUpI,EAAMkC,EAAM1C,GACzCH,KAAK0I,KAAK,YAAanB,WAE3BxH,WAAW+I,EAAOlI,EAAMmI,EAAUpI,EAAMkC,EAAM1C,GAC1CH,KAAK0I,KAAK,aAAcnB,WAE5BxH,MAAMW,EAAGsI,EAAUnG,EAAM1C,GACrBH,KAAK0I,KAAK,QAASnB,WAEvBxH,MAAMW,EAAGuI,EAAUC,EAAKC,EAAKhJ,GACzBH,KAAK0I,KAAK,QAASnB,WAEvBxH,OAAOW,EAAG0I,EAAOC,EAAOlJ,GACpBH,KAAK0I,KAAK,SAAUnB,WAExBxH,KAAKuJ,EAASC,EAASpJ,GACnBH,KAAK0I,KAAK,OAAQnB,WAEtBxH,QAAQuJ,EAASC,EAASlJ,EAAMF,GAC5BH,KAAK0I,KAAK,UAAWnB,WAEzBxH,SAASW,EAAGP,GACRH,KAAK0I,KAAK,WAAYnB,WAE1BxH,UAAUiC,EAAQvB,EAAIN,GAClBH,KAAKkG,QAAQyB,aACTD,kBAAkB,EAClB1F,OAAQA,EACRF,MAAOrB,EAAG0G,cAAenH,KAAK6F,mBAAmBsB,YAAYhH,MAMrEJ,YAAYI,GACR,GAAKH,KAAK8F,eAeN3F,QAfsB,CACtB,MAAMqD,GACFkE,kBAAkB,EAClB1F,OAAQ,QACRF,MAAO9B,KAAKwJ,iBAAiBhK,KAAgBQ,KAAK6F,mBAAmBsB,YAAac,IAC1EjI,KAAK8F,gBAAiB,EACtB9F,KAAK+F,YAAckC,EAAcE,WACjCnI,KAAKgG,cAAgBiC,EAAcG,cACnCpI,KAAKiG,cAAgBgC,EAAcI,cACnClI,QAGZH,KAAKkG,QAAQyB,YAAYnE,IAMjCzD,iBAAiBkH,GACb,IAAKA,EACD,OAAOA,EAEX,cAAeA,GACX,IAAK,SACD,GAA2B,iBAAhBA,EAAU,KAqBjB,OAAOA,EArB0B,CACjC,MAAMK,EAAaL,EACnB,OAAQK,EAAWjH,MACf,KAAKR,EAAeoD,UAChB,OAAOG,EAAqBkE,GAChC,KAAKzH,EAAe2B,GAChB,MAAMK,EAAQyF,EACd,OAAO,IAAI5C,EAAW1E,KAAM6B,EAAMJ,KAAMpC,EAASiD,YAAYT,EAAMlB,MAAOjB,EAAM2C,WAAWF,EAA4BN,EAAMhB,OAAQgB,EAAMzB,GAAI+B,EAA4BN,EAAMjB,OACrL,KAAKf,EAAeiE,MAChB,OAAOE,EAAkBsD,GAC7B,KAAKzH,EAAeqE,SAChB,OAAOE,EAAqBkD,GAChC,KAAKzH,EAAe0E,OAChB,OAAOC,EAAmB8C,GAC9B,KAAKzH,EAAeyD,MAChB,OAAOI,EAAkB4D,GAC7B,QACI,OAAOL,GAMvB,QACI,OAAOA,GAGnBlH,KAAK0J,EAAY3H,GACb,MAAMyE,EAAY,IAAIC,MAAM1E,EAAKW,QACjC,IAAK,IAAI6D,EAAI,EAAGA,EAAIxE,EAAKW,OAAQ6D,IAC7BC,EAAUD,GAAKtG,KAAKwJ,iBAAiB1H,EAAKwE,IAE9C,MAAM9C,GACFkE,kBAAkB,EAClB1F,OAAQyH,EACR3H,KAAMyE,GAEVvG,KAAKkG,QAAQyB,YAAYnE,GAK7BzD,iBAAiBkH,GACb,IAAKA,EACD,OAAOA,EAEX,cAAeA,GACX,IAAK,SACD,OAAIA,aAAevH,EACRmE,EAAkBoD,GAEpBA,aAAe9H,EACb6D,EAAqBiE,GAEvBA,aAAevC,EACbuC,EAAIE,cAENF,aAAe5H,EACb4E,EAAqBgD,GAEvBA,aAAerH,EACb0E,EAAmB2C,GAErBA,aAAerD,MACbP,EAAkB4D,GAGlB,mBAEf,IAAK,WACD,OAAOjH,KAAK6F,mBAAmBsB,YAAYF,GAC/C,QACI,OAAOA,IAqBvB,OAjBAtB,EAAS4C,KAAO,WAChB5C,EAAS+D,SACL9D,QACIvF,KAAM,SACNsJ,YAAa,+FACbC,UAAW,SAAUC,EAAG1J,GAEhB0J,EAAe,YACf1J,IAGAA,EAAG,IAAIhB,EAASC,EAAU0K,OAAQ,6CAM3CnE","file":"../../backend/WorkerFS.js","sourcesContent":["define([\n    '../libs/buffers',\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/util',\n    '../core/file',\n    '../core/node_fs_stats',\n    '../generic/preload_file',\n    '../core/global',\n    '../core/node_fs'\n], function (buffers,file_system, api_error, file_flag, util, file, node_fs_stats, preload_file, global, fs) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode }  = api_error;\n    const { FileFlag }  = file_flag;\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer, emptyBuffer }  = util;\n    const { BaseFile }  = file;\n    const { Stats }  = node_fs_stats;\n    const {PreloadFile}  = preload_file;\n    const { Buffer } = buffers;\n\n    /**\n     * @hidden\n     */\n    var SpecialArgType;\n    (function (SpecialArgType) {\n        // Callback\n        SpecialArgType[SpecialArgType[\"CB\"] = 0] = \"CB\";\n        // File descriptor\n        SpecialArgType[SpecialArgType[\"FD\"] = 1] = \"FD\";\n        // API error\n        SpecialArgType[SpecialArgType[\"API_ERROR\"] = 2] = \"API_ERROR\";\n        // Stats object\n        SpecialArgType[SpecialArgType[\"STATS\"] = 3] = \"STATS\";\n        // Initial probe for file system information.\n        SpecialArgType[SpecialArgType[\"PROBE\"] = 4] = \"PROBE\";\n        // FileFlag object.\n        SpecialArgType[SpecialArgType[\"FILEFLAG\"] = 5] = \"FILEFLAG\";\n        // Buffer object.\n        SpecialArgType[SpecialArgType[\"BUFFER\"] = 6] = \"BUFFER\";\n        // Generic Error object.\n        SpecialArgType[SpecialArgType[\"ERROR\"] = 7] = \"ERROR\";\n    })(SpecialArgType || (SpecialArgType = {}));\n    /**\n     * Converts callback arguments into ICallbackArgument objects, and back\n     * again.\n     * @hidden\n     */\n    class CallbackArgumentConverter {\n        constructor() {\n            this._callbacks = {};\n            this._nextId = 0;\n        }\n        toRemoteArg(cb) {\n            const id = this._nextId++;\n            this._callbacks[id] = cb;\n            return {\n                type: SpecialArgType.CB,\n                id: id\n            };\n        }\n        toLocalArg(id) {\n            const cb = this._callbacks[id];\n            delete this._callbacks[id];\n            return cb;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class FileDescriptorArgumentConverter {\n        constructor() {\n            this._fileDescriptors = {};\n            this._nextId = 0;\n        }\n        toRemoteArg(fd, p, flag, cb) {\n            const id = this._nextId++;\n            let data;\n            let stat;\n            this._fileDescriptors[id] = fd;\n            // Extract needed information asynchronously.\n            fd.stat((err, stats) => {\n                if (err) {\n                    cb(err);\n                }\n                else {\n                    stat = bufferToTransferrableObject(stats.toBuffer());\n                    // If it's a readable flag, we need to grab contents.\n                    if (flag.isReadable()) {\n                        fd.read(Buffer.alloc(stats.size), 0, stats.size, 0, (err, bytesRead, buff) => {\n                            if (err) {\n                                cb(err);\n                            }\n                            else {\n                                data = bufferToTransferrableObject(buff);\n                                cb(null, {\n                                    type: SpecialArgType.FD,\n                                    id: id,\n                                    data: data,\n                                    stat: stat,\n                                    path: p,\n                                    flag: flag.getFlagString()\n                                });\n                            }\n                        });\n                    }\n                    else {\n                        // File is not readable, which means writing to it will append or\n                        // truncate/replace existing contents. Return an empty arraybuffer.\n                        cb(null, {\n                            type: SpecialArgType.FD,\n                            id: id,\n                            data: new ArrayBuffer(0),\n                            stat: stat,\n                            path: p,\n                            flag: flag.getFlagString()\n                        });\n                    }\n                }\n            });\n        }\n        applyFdAPIRequest(request, cb) {\n            const fdArg = request.args[0];\n            this._applyFdChanges(fdArg, (err, fd) => {\n                if (err) {\n                    cb(err);\n                }\n                else {\n                    // Apply method on now-changed file descriptor.\n                    fd[request.method]((e) => {\n                        if (request.method === 'close') {\n                            delete this._fileDescriptors[fdArg.id];\n                        }\n                        cb(e);\n                    });\n                }\n            });\n        }\n        _applyFdChanges(remoteFd, cb) {\n            const fd = this._fileDescriptors[remoteFd.id], data = transferrableObjectToBuffer(remoteFd.data), remoteStats = Stats.fromBuffer(transferrableObjectToBuffer(remoteFd.stat));\n            // Write data if the file is writable.\n            const flag = FileFlag.getFileFlag(remoteFd.flag);\n            if (flag.isWriteable()) {\n                // Appendable: Write to end of file.\n                // Writeable: Replace entire contents of file.\n                fd.write(data, 0, data.length, flag.isAppendable() ? fd.getPos() : 0, (e) => {\n                    function applyStatChanges() {\n                        // Check if mode changed.\n                        fd.stat((e, stats) => {\n                            if (e) {\n                                cb(e);\n                            }\n                            else {\n                                if (stats.mode !== remoteStats.mode) {\n                                    fd.chmod(remoteStats.mode, (e) => {\n                                        cb(e, fd);\n                                    });\n                                }\n                                else {\n                                    cb(e, fd);\n                                }\n                            }\n                        });\n                    }\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        // If writeable & not appendable, we need to ensure file contents are\n                        // identical to those from the remote FD. Thus, we truncate to the\n                        // length of the remote file.\n                        if (!flag.isAppendable()) {\n                            fd.truncate(data.length, () => {\n                                applyStatChanges();\n                            });\n                        }\n                        else {\n                            applyStatChanges();\n                        }\n                    }\n                });\n            }\n            else {\n                cb(null, fd);\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    function apiErrorLocal2Remote(e) {\n        return {\n            type: SpecialArgType.API_ERROR,\n            errorData: bufferToTransferrableObject(e.writeToBuffer())\n        };\n    }\n    /**\n     * @hidden\n     */\n    function apiErrorRemote2Local(e) {\n        return ApiError.fromBuffer(transferrableObjectToBuffer(e.errorData));\n    }\n    /**\n     * @hidden\n     */\n    function errorLocal2Remote(e) {\n        return {\n            type: SpecialArgType.ERROR,\n            name: e.name,\n            message: e.message,\n            stack: e.stack\n        };\n    }\n    /**\n     * @hidden\n     */\n    function errorRemote2Local(e) {\n        let cnstr = global[e.name];\n        if (typeof (cnstr) !== 'function') {\n            cnstr = Error;\n        }\n        const err = new cnstr(e.message);\n        err.stack = e.stack;\n        return err;\n    }\n    /**\n     * @hidden\n     */\n    function statsLocal2Remote(stats) {\n        return {\n            type: SpecialArgType.STATS,\n            statsData: bufferToTransferrableObject(stats.toBuffer())\n        };\n    }\n    /**\n     * @hidden\n     */\n    function statsRemote2Local(stats) {\n        return Stats.fromBuffer(transferrableObjectToBuffer(stats.statsData));\n    }\n    /**\n     * @hidden\n     */\n    function fileFlagLocal2Remote(flag) {\n        return {\n            type: SpecialArgType.FILEFLAG,\n            flagStr: flag.getFlagString()\n        };\n    }\n    /**\n     * @hidden\n     */\n    function fileFlagRemote2Local(remoteFlag) {\n        return FileFlag.getFileFlag(remoteFlag.flagStr);\n    }\n    /**\n     * @hidden\n     */\n    function bufferToTransferrableObject(buff) {\n        return buffer2ArrayBuffer(buff);\n    }\n    /**\n     * @hidden\n     */\n    function transferrableObjectToBuffer(buff) {\n        return arrayBuffer2Buffer(buff);\n    }\n    /**\n     * @hidden\n     */\n    function bufferLocal2Remote(buff) {\n        return {\n            type: SpecialArgType.BUFFER,\n            data: bufferToTransferrableObject(buff)\n        };\n    }\n    /**\n     * @hidden\n     */\n    function bufferRemote2Local(buffArg) {\n        return transferrableObjectToBuffer(buffArg.data);\n    }\n    /**\n     * @hidden\n     */\n    function isAPIRequest(data) {\n        return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];\n    }\n    /**\n     * @hidden\n     */\n    function isAPIResponse(data) {\n        return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];\n    }\n    /**\n     * Represents a remote file in a different worker/thread.\n     */\n    class WorkerFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, remoteFdId, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n            this._remoteFdId = remoteFdId;\n        }\n        getRemoteFdId() {\n            return this._remoteFdId;\n        }\n        /**\n         * @hidden\n         */\n        toRemoteArg() {\n            return {\n                type: SpecialArgType.FD,\n                id: this._remoteFdId,\n                data: bufferToTransferrableObject(this.getBuffer()),\n                stat: bufferToTransferrableObject(this.getStats().toBuffer()),\n                path: this.getPath(),\n                flag: this.getFlag().getFlagString()\n            };\n        }\n        sync(cb) {\n            this._syncClose('sync', cb);\n        }\n        close(cb) {\n            this._syncClose('close', cb);\n        }\n        _syncClose(type, cb) {\n            if (this.isDirty()) {\n                this._fs.syncClose(type, this, (e) => {\n                    if (!e) {\n                        this.resetDirty();\n                    }\n                    cb(e);\n                });\n            }\n            else {\n                cb();\n            }\n        }\n    }\n    /**\n     * WorkerFS lets you access a BrowserFS instance that is running in a different\n     * JavaScript context (e.g. access BrowserFS in one of your WebWorkers, or\n     * access BrowserFS running on the main page from a WebWorker).\n     *\n     * For example, to have a WebWorker access files in the main browser thread,\n     * do the following:\n     *\n     * MAIN BROWSER THREAD:\n     *\n     * ```javascript\n     *   // Listen for remote file system requests.\n     *   BrowserFS.FileSystem.WorkerFS.attachRemoteListener(webWorkerObject);\n     * ```\n     *\n     * WEBWORKER THREAD:\n     *\n     * ```javascript\n     *   // Set the remote file system as the root file system.\n     *   BrowserFS.configure({ fs: \"WorkerFS\", options: { worker: self }}, function(e) {\n     *     // Ready!\n     *   });\n     * ```\n     *\n     * Note that synchronous operations are not permitted on the WorkerFS, regardless\n     * of the configuration option of the remote FS.\n     */\n    class WorkerFS extends BaseFileSystem {\n        /**\n         * Constructs a new WorkerFS instance that connects with BrowserFS running on\n         * the specified worker.\n         */\n        constructor(worker) {\n            super();\n            this._callbackConverter = new CallbackArgumentConverter();\n            this._isInitialized = false;\n            this._isReadOnly = false;\n            this._supportLinks = false;\n            this._supportProps = false;\n            this._worker = worker;\n            this._worker.addEventListener('message', (e) => {\n                const resp = e.data;\n                if (isAPIResponse(resp)) {\n                    let i;\n                    const args = resp.args;\n                    const fixedArgs = new Array(args.length);\n                    // Dispatch event to correct id.\n                    for (i = 0; i < fixedArgs.length; i++) {\n                        fixedArgs[i] = this._argRemote2Local(args[i]);\n                    }\n                    this._callbackConverter.toLocalArg(resp.cbId).apply(null, fixedArgs);\n                }\n            });\n        }\n        static Create(opts, cb) {\n            const fs = new WorkerFS(opts.worker);\n            fs._initialize(() => {\n                cb(null, fs);\n            });\n        }\n        static isAvailable() {\n            return typeof (importScripts) !== 'undefined' || typeof (Worker) !== 'undefined';\n        }\n        /**\n         * Attaches a listener to the remote worker for file system requests.\n         */\n        static attachRemoteListener(worker) {\n            const fdConverter = new FileDescriptorArgumentConverter();\n            function argLocal2Remote(arg, requestArgs, cb) {\n                switch (typeof arg) {\n                    case 'object':\n                        if (arg instanceof Stats) {\n                            cb(null, statsLocal2Remote(arg));\n                        }\n                        else if (arg instanceof ApiError) {\n                            cb(null, apiErrorLocal2Remote(arg));\n                        }\n                        else if (arg instanceof BaseFile) {\n                            // Pass in p and flags from original request.\n                            cb(null, fdConverter.toRemoteArg(arg, requestArgs[0], requestArgs[1], cb));\n                        }\n                        else if (arg instanceof FileFlag) {\n                            cb(null, fileFlagLocal2Remote(arg));\n                        }\n                        else if (arg instanceof Buffer) {\n                            cb(null, bufferLocal2Remote(arg));\n                        }\n                        else if (arg instanceof Error) {\n                            cb(null, errorLocal2Remote(arg));\n                        }\n                        else {\n                            cb(null, arg);\n                        }\n                        break;\n                    default:\n                        cb(null, arg);\n                        break;\n                }\n            }\n            function argRemote2Local(arg, fixedRequestArgs) {\n                if (!arg) {\n                    return arg;\n                }\n                switch (typeof arg) {\n                    case 'object':\n                        if (typeof arg['type'] === 'number') {\n                            const specialArg = arg;\n                            switch (specialArg.type) {\n                                case SpecialArgType.CB:\n                                    const cbId = arg.id;\n                                    return function () {\n                                        let i;\n                                        const fixedArgs = new Array(arguments.length);\n                                        let message, countdown = arguments.length;\n                                        function abortAndSendError(err) {\n                                            if (countdown > 0) {\n                                                countdown = -1;\n                                                message = {\n                                                    browserfsMessage: true,\n                                                    cbId: cbId,\n                                                    args: [apiErrorLocal2Remote(err)]\n                                                };\n                                                worker.postMessage(message);\n                                            }\n                                        }\n                                        for (i = 0; i < arguments.length; i++) {\n                                            // Capture i and argument.\n                                            ((i, arg) => {\n                                                argLocal2Remote(arg, fixedRequestArgs, (err, fixedArg) => {\n                                                    fixedArgs[i] = fixedArg;\n                                                    if (err) {\n                                                        abortAndSendError(err);\n                                                    }\n                                                    else if (--countdown === 0) {\n                                                        message = {\n                                                            browserfsMessage: true,\n                                                            cbId: cbId,\n                                                            args: fixedArgs\n                                                        };\n                                                        worker.postMessage(message);\n                                                    }\n                                                });\n                                            })(i, arguments[i]);\n                                        }\n                                        if (arguments.length === 0) {\n                                            message = {\n                                                browserfsMessage: true,\n                                                cbId: cbId,\n                                                args: fixedArgs\n                                            };\n                                            worker.postMessage(message);\n                                        }\n                                    };\n                                case SpecialArgType.API_ERROR:\n                                    return apiErrorRemote2Local(specialArg);\n                                case SpecialArgType.STATS:\n                                    return statsRemote2Local(specialArg);\n                                case SpecialArgType.FILEFLAG:\n                                    return fileFlagRemote2Local(specialArg);\n                                case SpecialArgType.BUFFER:\n                                    return bufferRemote2Local(specialArg);\n                                case SpecialArgType.ERROR:\n                                    return errorRemote2Local(specialArg);\n                                default:\n                                    // No idea what this is.\n                                    return arg;\n                            }\n                        }\n                        else {\n                            return arg;\n                        }\n                    default:\n                        return arg;\n                }\n            }\n            worker.addEventListener('message', (e) => {\n                const request = e.data;\n                if (isAPIRequest(request)) {\n                    const args = request.args, fixedArgs = new Array(args.length);\n                    switch (request.method) {\n                        case 'close':\n                        case 'sync':\n                            (() => {\n                                // File descriptor-relative methods.\n                                const remoteCb = args[1];\n                                fdConverter.applyFdAPIRequest(request, (err) => {\n                                    // Send response.\n                                    const response = {\n                                        browserfsMessage: true,\n                                        cbId: remoteCb.id,\n                                        args: err ? [apiErrorLocal2Remote(err)] : []\n                                    };\n                                    worker.postMessage(response);\n                                });\n                            })();\n                            break;\n                        case 'probe':\n                            (() => {\n                                const rootFs = fs.getRootFS(), remoteCb = args[1], probeResponse = {\n                                    type: SpecialArgType.PROBE,\n                                    isReadOnly: rootFs.isReadOnly(),\n                                    supportsLinks: rootFs.supportsLinks(),\n                                    supportsProps: rootFs.supportsProps()\n                                }, response = {\n                                    browserfsMessage: true,\n                                    cbId: remoteCb.id,\n                                    args: [probeResponse]\n                                };\n                                worker.postMessage(response);\n                            })();\n                            break;\n                        default:\n                            // File system methods.\n                            for (let i = 0; i < args.length; i++) {\n                                fixedArgs[i] = argRemote2Local(args[i], fixedArgs);\n                            }\n                            const rootFS = fs.getRootFS();\n                            rootFS[request.method].apply(rootFS, fixedArgs);\n                            break;\n                    }\n                }\n            });\n        }\n        getName() {\n            return WorkerFS.Name;\n        }\n        isReadOnly() { return this._isReadOnly; }\n        supportsSynch() { return false; }\n        supportsLinks() { return this._supportLinks; }\n        supportsProps() { return this._supportProps; }\n        rename(oldPath, newPath, cb) {\n            this._rpc('rename', arguments);\n        }\n        stat(p, isLstat, cb) {\n            this._rpc('stat', arguments);\n        }\n        open(p, flag, mode, cb) {\n            this._rpc('open', arguments);\n        }\n        unlink(p, cb) {\n            this._rpc('unlink', arguments);\n        }\n        rmdir(p, cb) {\n            this._rpc('rmdir', arguments);\n        }\n        mkdir(p, mode, cb) {\n            this._rpc('mkdir', arguments);\n        }\n        readdir(p, cb) {\n            this._rpc('readdir', arguments);\n        }\n        exists(p, cb) {\n            this._rpc('exists', arguments);\n        }\n        realpath(p, cache, cb) {\n            this._rpc('realpath', arguments);\n        }\n        truncate(p, len, cb) {\n            this._rpc('truncate', arguments);\n        }\n        readFile(fname, encoding, flag, cb) {\n            this._rpc('readFile', arguments);\n        }\n        writeFile(fname, data, encoding, flag, mode, cb) {\n            this._rpc('writeFile', arguments);\n        }\n        appendFile(fname, data, encoding, flag, mode, cb) {\n            this._rpc('appendFile', arguments);\n        }\n        chmod(p, isLchmod, mode, cb) {\n            this._rpc('chmod', arguments);\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            this._rpc('chown', arguments);\n        }\n        utimes(p, atime, mtime, cb) {\n            this._rpc('utimes', arguments);\n        }\n        link(srcpath, dstpath, cb) {\n            this._rpc('link', arguments);\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            this._rpc('symlink', arguments);\n        }\n        readlink(p, cb) {\n            this._rpc('readlink', arguments);\n        }\n        syncClose(method, fd, cb) {\n            this._worker.postMessage({\n                browserfsMessage: true,\n                method: method,\n                args: [fd.toRemoteArg(), this._callbackConverter.toRemoteArg(cb)]\n            });\n        }\n        /**\n         * Called once both local and remote sides are set up.\n         */\n        _initialize(cb) {\n            if (!this._isInitialized) {\n                const message = {\n                    browserfsMessage: true,\n                    method: 'probe',\n                    args: [this._argLocal2Remote(emptyBuffer()), this._callbackConverter.toRemoteArg((probeResponse) => {\n                            this._isInitialized = true;\n                            this._isReadOnly = probeResponse.isReadOnly;\n                            this._supportLinks = probeResponse.supportsLinks;\n                            this._supportProps = probeResponse.supportsProps;\n                            cb();\n                        })]\n                };\n                this._worker.postMessage(message);\n            }\n            else {\n                cb();\n            }\n        }\n        _argRemote2Local(arg) {\n            if (!arg) {\n                return arg;\n            }\n            switch (typeof arg) {\n                case 'object':\n                    if (typeof arg['type'] === 'number') {\n                        const specialArg = arg;\n                        switch (specialArg.type) {\n                            case SpecialArgType.API_ERROR:\n                                return apiErrorRemote2Local(specialArg);\n                            case SpecialArgType.FD:\n                                const fdArg = specialArg;\n                                return new WorkerFile(this, fdArg.path, FileFlag.getFileFlag(fdArg.flag), Stats.fromBuffer(transferrableObjectToBuffer(fdArg.stat)), fdArg.id, transferrableObjectToBuffer(fdArg.data));\n                            case SpecialArgType.STATS:\n                                return statsRemote2Local(specialArg);\n                            case SpecialArgType.FILEFLAG:\n                                return fileFlagRemote2Local(specialArg);\n                            case SpecialArgType.BUFFER:\n                                return bufferRemote2Local(specialArg);\n                            case SpecialArgType.ERROR:\n                                return errorRemote2Local(specialArg);\n                            default:\n                                return arg;\n                        }\n                    }\n                    else {\n                        return arg;\n                    }\n                default:\n                    return arg;\n            }\n        }\n        _rpc(methodName, args) {\n            const fixedArgs = new Array(args.length);\n            for (let i = 0; i < args.length; i++) {\n                fixedArgs[i] = this._argLocal2Remote(args[i]);\n            }\n            const message = {\n                browserfsMessage: true,\n                method: methodName,\n                args: fixedArgs\n            };\n            this._worker.postMessage(message);\n        }\n        /**\n         * Converts a local argument into a remote argument. Public so WorkerFile objects can call it.\n         */\n        _argLocal2Remote(arg) {\n            if (!arg) {\n                return arg;\n            }\n            switch (typeof arg) {\n                case \"object\":\n                    if (arg instanceof Stats) {\n                        return statsLocal2Remote(arg);\n                    }\n                    else if (arg instanceof ApiError) {\n                        return apiErrorLocal2Remote(arg);\n                    }\n                    else if (arg instanceof WorkerFile) {\n                        return arg.toRemoteArg();\n                    }\n                    else if (arg instanceof FileFlag) {\n                        return fileFlagLocal2Remote(arg);\n                    }\n                    else if (arg instanceof Buffer) {\n                        return bufferLocal2Remote(arg);\n                    }\n                    else if (arg instanceof Error) {\n                        return errorLocal2Remote(arg);\n                    }\n                    else {\n                        return \"Unknown argument\";\n                    }\n                case \"function\":\n                    return this._callbackConverter.toRemoteArg(arg);\n                default:\n                    return arg;\n            }\n        }\n    }\n    WorkerFS.Name = \"WorkerFS\";\n    WorkerFS.Options = {\n        worker: {\n            type: \"object\",\n            description: \"The target worker that you want to connect to, or the current worker if in a worker context.\",\n            validator: function (v, cb) {\n                // Check for a `postMessage` function.\n                if (v['postMessage']) {\n                    cb();\n                }\n                else {\n                    cb(new ApiError(ErrorCode.EINVAL, `option must be a Web Worker instance.`));\n                }\n            }\n        }\n    };\n\n    return WorkerFS;\n});"]}