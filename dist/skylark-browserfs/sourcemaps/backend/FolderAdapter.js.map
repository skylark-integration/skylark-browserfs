{"version":3,"sources":["backend/FolderAdapter.js"],"names":["define","file_system","path","api_error","BaseFileSystem","ApiError","FolderAdapter","[object Object]","folder","wrapped","super","this","_folder","_wrapped","opts","cb","fa","_initialize","e","getName","isReadOnly","supportsProps","supportsSynch","exists","ENOENT","mkdir","translateError","err","p","relative","message","replace","wrapFunction","name","wrapFirst","wrapSecond","slice","length","arguments","join","apply","Name","Options","type","description","forEach","prototype"],"mappings":";;;;;;;AAAAA,QACI,sBACA,eACA,qBACD,SAAUC,EAAaC,EAAMC,GAC5B,aAEA,MAAMC,eAAEA,GAAmBH,GACrBI,SAAEA,GAAaF,QAoBfG,UAAsBF,EACxBG,YAAYC,EAAQC,GAChBC,QACAC,KAAKC,QAAUJ,EACfG,KAAKE,SAAWJ,EAKpBF,cAAcO,EAAMC,GAChB,MAAMC,EAAK,IAAIV,EAAcQ,EAAKN,OAAQM,EAAKL,SAC/CO,EAAGC,YAAY,SAAUC,GACjBA,EACAH,EAAGG,GAGHH,EAAG,KAAMC,KAIrBT,qBACI,OAAO,EAEXA,UAAY,OAAOI,KAAKE,SAASM,UACjCZ,aAAe,OAAOI,KAAKE,SAASO,aACpCb,gBAAkB,OAAOI,KAAKE,SAASQ,gBACvCd,gBAAkB,OAAOI,KAAKE,SAASS,gBACvCf,gBAAkB,OAAO,EAKzBA,YAAYQ,GACRJ,KAAKE,SAASU,OAAOZ,KAAKC,QAAUW,IAC5BA,EACAR,IAEKJ,KAAKE,SAASO,aACnBL,EAAGV,EAASmB,OAAOb,KAAKC,UAGxBD,KAAKE,SAASY,MAAMd,KAAKC,QAAS,IAAOG,MAmBzD,SAASW,EAAelB,EAAQU,GAC5B,GAAU,OAANA,GAA2B,iBAANA,EAAgB,CACrC,MAAMS,EAAMT,EACZ,IAAIU,EAAID,EAAIzB,KACR0B,IACAA,EAAI,IAAM1B,EAAK2B,SAASrB,EAAQoB,GAChCD,EAAIG,QAAUH,EAAIG,QAAQC,QAAQJ,EAAIzB,KAAM0B,GAC5CD,EAAIzB,KAAO0B,GAGnB,OAAOV,EAqBX,SAASc,EAAaC,EAAMC,EAAWC,GACnC,MAAoC,SAAhCF,EAAKG,MAAMH,EAAKI,OAAS,GAElB,WAnBf,IAAsB7B,EAAQO,EA6BlB,OATIuB,UAAUD,OAAS,IACfH,IACAI,UAAU,GAAKpC,EAAKqC,KAAK5B,KAAKC,QAAS0B,UAAU,KAEjDH,IACAG,UAAU,GAAKpC,EAAKqC,KAAK5B,KAAKC,QAAS0B,UAAU,KAErDA,UAAUA,UAAUD,OAAS,IA3BvB7B,EA2ByCG,KAAKC,QA1B9C,mBADQG,EA2B+CuB,UAAUA,UAAUD,OAAS,IAzB3F,SAAUV,GACTW,UAAUD,OAAS,IACnBC,UAAU,GAAKZ,EAAelB,EAAQmB,IAE1CZ,EAAGyB,MAAM,KAAMF,YAIZvB,IAmBIJ,KAAKE,SAASoB,GAAMO,MAAM7B,KAAKE,SAAUyB,YAK7C,WACH,IAOI,OANIJ,IACAI,UAAU,GAAKpC,EAAKqC,KAAK5B,KAAKC,QAAS0B,UAAU,KAEjDH,IACAG,UAAU,GAAKpC,EAAKqC,KAAK5B,KAAKC,QAAS0B,UAAU,KAE9C3B,KAAKE,SAASoB,GAAMO,MAAM7B,KAAKE,SAAUyB,WAEpD,MAAOpB,GACH,MAAMQ,EAAef,KAAKC,QAASM,KAmBnD,OA7FAZ,EAAcmC,KAAO,gBACrBnC,EAAcoC,SACVlC,QACImC,KAAM,SACNC,YAAa,2CAEjBnC,SACIkC,KAAM,SACNC,YAAa,6BAwEpB,YAAa,OAAQ,WAAY,OAAQ,WAAY,SAAU,aAC5D,QAAS,YAAa,QAAS,YAAa,UAAW,cAAe,SACtE,aAAc,WAAY,eAAgB,WAAY,eAAgB,WACtE,eAAgB,YAAa,gBAAiB,aAAc,iBAC5D,QAAS,YAAa,QAAS,YAAa,SAAU,aAAc,WACpE,gBAAgBC,QAASZ,IACzB3B,EAAcwC,UAAUb,GAAQD,EAAaC,GAAM,GAAM,MAG5D,SAAU,aAAc,OAAQ,WAAY,UAAW,eAAeY,QAASZ,IAC5E3B,EAAcwC,UAAUb,GAAQD,EAAaC,GAAM,GAAM,KAGtD3B","file":"../../backend/FolderAdapter.js","sourcesContent":["define([\n    '../core/file_system',\n    '../libs/path',\n    '../core/api_error'\n], function (file_system, path, api_error) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError } = api_error;\n\n    /**\n     * The FolderAdapter file system wraps a file system, and scopes all interactions to a subfolder of that file system.\n     *\n     * Example: Given a file system `foo` with folder `bar` and file `bar/baz`...\n     *\n     * ```javascript\n     * BrowserFS.configure({\n     *   fs: \"FolderAdapter\",\n     *   options: {\n     *     folder: \"bar\",\n     *     wrapped: foo\n     *   }\n     * }, function(e) {\n     *   var fs = BrowserFS.BFSRequire('fs');\n     *   fs.readdirSync('/'); // ['baz']\n     * });\n     * ```\n     */\n    class FolderAdapter extends BaseFileSystem {\n        constructor(folder, wrapped) {\n            super();\n            this._folder = folder;\n            this._wrapped = wrapped;\n        }\n        /**\n         * Creates a FolderAdapter instance with the given options.\n         */\n        static Create(opts, cb) {\n            const fa = new FolderAdapter(opts.folder, opts.wrapped);\n            fa._initialize(function (e) {\n                if (e) {\n                    cb(e);\n                }\n                else {\n                    cb(null, fa);\n                }\n            });\n        }\n        static isAvailable() {\n            return true;\n        }\n        getName() { return this._wrapped.getName(); }\n        isReadOnly() { return this._wrapped.isReadOnly(); }\n        supportsProps() { return this._wrapped.supportsProps(); }\n        supportsSynch() { return this._wrapped.supportsSynch(); }\n        supportsLinks() { return false; }\n        /**\n         * Initialize the file system. Ensures that the wrapped file system\n         * has the given folder.\n         */\n        _initialize(cb) {\n            this._wrapped.exists(this._folder, (exists) => {\n                if (exists) {\n                    cb();\n                }\n                else if (this._wrapped.isReadOnly()) {\n                    cb(ApiError.ENOENT(this._folder));\n                }\n                else {\n                    this._wrapped.mkdir(this._folder, 0x1ff, cb);\n                }\n            });\n        }\n    }\n    FolderAdapter.Name = \"FolderAdapter\";\n    FolderAdapter.Options = {\n        folder: {\n            type: \"string\",\n            description: \"The folder to use as the root directory\"\n        },\n        wrapped: {\n            type: \"object\",\n            description: \"The file system to wrap\"\n        }\n    };\n    /**\n     * @hidden\n     */\n    function translateError(folder, e) {\n        if (e !== null && typeof e === 'object') {\n            const err = e;\n            let p = err.path;\n            if (p) {\n                p = '/' + path.relative(folder, p);\n                err.message = err.message.replace(err.path, p);\n                err.path = p;\n            }\n        }\n        return e;\n    }\n    /**\n     * @hidden\n     */\n    function wrapCallback(folder, cb) {\n        if (typeof cb === 'function') {\n            return function (err) {\n                if (arguments.length > 0) {\n                    arguments[0] = translateError(folder, err);\n                }\n                cb.apply(null, arguments);\n            };\n        }\n        else {\n            return cb;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function wrapFunction(name, wrapFirst, wrapSecond) {\n        if (name.slice(name.length - 4) !== 'Sync') {\n            // Async function. Translate error in callback.\n            return function () {\n                if (arguments.length > 0) {\n                    if (wrapFirst) {\n                        arguments[0] = path.join(this._folder, arguments[0]);\n                    }\n                    if (wrapSecond) {\n                        arguments[1] = path.join(this._folder, arguments[1]);\n                    }\n                    arguments[arguments.length - 1] = wrapCallback(this._folder, arguments[arguments.length - 1]);\n                }\n                return this._wrapped[name].apply(this._wrapped, arguments);\n            };\n        }\n        else {\n            // Sync function. Translate error in catch.\n            return function () {\n                try {\n                    if (wrapFirst) {\n                        arguments[0] = path.join(this._folder, arguments[0]);\n                    }\n                    if (wrapSecond) {\n                        arguments[1] = path.join(this._folder, arguments[1]);\n                    }\n                    return this._wrapped[name].apply(this._wrapped, arguments);\n                }\n                catch (e) {\n                    throw translateError(this._folder, e);\n                }\n            };\n        }\n    }\n    // First argument is a path.\n    ['diskSpace', 'stat', 'statSync', 'open', 'openSync', 'unlink', 'unlinkSync',\n        'rmdir', 'rmdirSync', 'mkdir', 'mkdirSync', 'readdir', 'readdirSync', 'exists',\n        'existsSync', 'realpath', 'realpathSync', 'truncate', 'truncateSync', 'readFile',\n        'readFileSync', 'writeFile', 'writeFileSync', 'appendFile', 'appendFileSync',\n        'chmod', 'chmodSync', 'chown', 'chownSync', 'utimes', 'utimesSync', 'readlink',\n        'readlinkSync'].forEach((name) => {\n        FolderAdapter.prototype[name] = wrapFunction(name, true, false);\n    });\n    // First and second arguments are paths.\n    ['rename', 'renameSync', 'link', 'linkSync', 'symlink', 'symlinkSync'].forEach((name) => {\n        FolderAdapter.prototype[name] = wrapFunction(name, true, true);\n    });\n\n    return FolderAdapter;\n});"]}