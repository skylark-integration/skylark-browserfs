{"version":3,"sources":["backend/HTML5FS.js"],"names":["define","async","preload_file","file_system","api_error","file_flag","node_fs_stats","path","global","util","BaseFileSystem","ApiError","ErrorCode","ActionType","Stats","FileType","asyncEach","each","buffer2ArrayBuffer","arrayBuffer2Buffer","PreloadFile","_getFS","webkitRequestFileSystem","requestFileSystem","convertError","err","p","expectedDir","name","EEXIST","FileError","ENOSPC","ENOENT","EACCES","EPERM","ENOTDIR","EISDIR","EINVAL","HTML5FSFile","[object Object]","fs","entry","flag","stat","contents","super","this","_entry","cb","isDirty","createWriter","writer","buffer","getBuffer","blob","Blob","length","size","onwriteend","onerror","truncate","resetDirty","getPath","write","sync","HTML5FS","type","PERSISTENT","opts","_allocate","e","Name","mainCb","_readdir","entries","succ","error","fullPath","isDirectory","removeRecursively","remove","er","oldPath","newPath","semaphore","successCount","root","currentPath","success","file","dirname","getDirectory","parentDir","basename","moveTo","unlink","rename","getFile","isLstat","create","loadAsDir","dir","DIRECTORY","failedToLoad","FILE","flags","mode","isExclusive","pathNotExistsAction","CREATE_FILE","exclusive","reader","FileReader","onloadend","event","bfsFile","_makeFile","result","ev","readAsArrayBuffer","_remove","readdir","files","ENOTEMPTY","rv","push","data","ArrayBuffer","stats","list","dirEntry","createReader","readEntries","results","concat","Array","prototype","slice","call","errorCallback","navigator","webkitPersistentStorage","requestQuota","TEMPORARY","webkitTemporaryStorage","TypeError","webkitStorageInfo","_requestQuota","granted","isFile","Options","optional","description"],"mappings":"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","file":"../../backend/HTML5FS.js","sourcesContent":["define([\n    \"skylark-langx-async\",\n    '../generic/preload_file',\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/node_fs_stats',\n    '../libs/path',\n    '../core/global',\n    '../core/util'\n], function (async,preload_file, file_system, api_error, file_flag, node_fs_stats, path, global, util) {\n    'use strict';\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode } = api_error;\n    const { ActionType } = file_flag;\n    const { Stats, FileType } = node_fs_stats;\n    const asyncEach = async.each;\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = util;\n\n    const { PreloadFile} = preload_file;\n\n    /**\n     * @hidden\n     */\n    function isDirectoryEntry(entry) {\n        return entry.isDirectory;\n    }\n    /**\n     * @hidden\n     */\n    const _getFS = global.webkitRequestFileSystem || global.requestFileSystem || null;\n    /**\n     * @hidden\n     */\n    function _requestQuota(type, size, success, errorCallback) {\n        // We cast navigator and window to '<any>' because everything here is\n        // nonstandard functionality, despite the fact that Chrome has the only\n        // implementation of the HTML5FS and is likely driving the standardization\n        // process. Thus, these objects defined off of navigator and window are not\n        // present in the DefinitelyTyped TypeScript typings for FileSystem.\n        if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {\n            switch (type) {\n                case global.PERSISTENT:\n                    navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);\n                    break;\n                case global.TEMPORARY:\n                    navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);\n                    break;\n                default:\n                    errorCallback(new TypeError(`Invalid storage type: ${type}`));\n                    break;\n            }\n        }\n        else {\n            global.webkitStorageInfo.requestQuota(type, size, success, errorCallback);\n        }\n    }\n    /**\n     * @hidden\n     */\n    function _toArray(list) {\n        return Array.prototype.slice.call(list || [], 0);\n    }\n    /**\n     * Converts the given DOMError into an appropriate ApiError.\n     * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n     * @hidden\n     */\n    function convertError(err, p, expectedDir) {\n        switch (err.name) {\n            /* The user agent failed to create a file or directory due to the existence of a file or\n                directory with the same path.  */\n            case \"PathExistsError\":\n                return ApiError.EEXIST(p);\n            /* The operation failed because it would cause the application to exceed its storage quota.  */\n            case 'QuotaExceededError':\n                return ApiError.FileError(ErrorCode.ENOSPC, p);\n            /*  A required file or directory could not be found at the time an operation was processed.   */\n            case 'NotFoundError':\n                return ApiError.ENOENT(p);\n            /* This is a security error code to be used in situations not covered by any other error codes.\n                - A required file was unsafe for access within a Web application\n                - Too many calls are being made on filesystem resources */\n            case 'SecurityError':\n                return ApiError.FileError(ErrorCode.EACCES, p);\n            /* The modification requested was illegal. Examples of invalid modifications include moving a\n                directory into its own child, moving a file into its parent directory without changing its name,\n                or copying a directory to a path occupied by a file.  */\n            case 'InvalidModificationError':\n                return ApiError.FileError(ErrorCode.EPERM, p);\n            /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type\n                [e.g. is a DirectoryEntry when the user requested a FileEntry].  */\n            case 'TypeMismatchError':\n                return ApiError.FileError(expectedDir ? ErrorCode.ENOTDIR : ErrorCode.EISDIR, p);\n            /* A path or URL supplied to the API was malformed.  */\n            case \"EncodingError\":\n            /* An operation depended on state cached in an interface object, but that state that has changed\n                since it was read from disk.  */\n            case \"InvalidStateError\":\n            /* The user attempted to write to a file or directory which could not be modified due to the state\n                of the underlying filesystem.  */\n            case \"NoModificationAllowedError\":\n            default:\n                return ApiError.FileError(ErrorCode.EINVAL, p);\n        }\n    }\n    // A note about getFile and getDirectory options:\n    // These methods are called at numerous places in this file, and are passed\n    // some combination of these two options:\n    //   - create: If true, the entry will be created if it doesn't exist.\n    //             If false, an error will be thrown if it doesn't exist.\n    //   - exclusive: If true, only create the entry if it doesn't already exist,\n    //                and throw an error if it does.\n    class HTML5FSFile extends PreloadFile {\n        constructor(fs, entry, path, flag, stat, contents) {\n            super(fs, path, flag, stat, contents);\n            this._entry = entry;\n        }\n        sync(cb) {\n            if (!this.isDirty()) {\n                return cb();\n            }\n            this._entry.createWriter((writer) => {\n                const buffer = this.getBuffer();\n                const blob = new Blob([buffer2ArrayBuffer(buffer)]);\n                const length = blob.size;\n                writer.onwriteend = (err) => {\n                    writer.onwriteend = null;\n                    writer.onerror = null;\n                    writer.truncate(length);\n                    this.resetDirty();\n                    cb();\n                };\n                writer.onerror = (err) => {\n                    cb(convertError(err, this.getPath(), false));\n                };\n                writer.write(blob);\n            });\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n    }\n    /**\n     * A read-write filesystem backed by the HTML5 FileSystem API.\n     *\n     * As the HTML5 FileSystem is only implemented in Blink, this interface is\n     * only available in Chrome.\n     */\n    class HTML5FS extends BaseFileSystem {\n        /**\n         * @param size storage quota to request, in megabytes. Allocated value may be less.\n         * @param type window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\n         */\n        constructor(size = 5, type = global.PERSISTENT) {\n            super();\n            // Convert MB to bytes.\n            this.size = 1024 * 1024 * size;\n            this.type = type;\n        }\n        /**\n         * Creates an HTML5FS instance with the given options.\n         */\n        static Create(opts, cb) {\n            const fs = new HTML5FS(opts.size, opts.type);\n            fs._allocate((e) => e ? cb(e) : cb(null, fs));\n        }\n        static isAvailable() {\n            return !!_getFS;\n        }\n        getName() {\n            return HTML5FS.Name;\n        }\n        isReadOnly() {\n            return false;\n        }\n        supportsSymlinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return false;\n        }\n        /**\n         * Deletes everything in the FS. Used for testing.\n         * Karma clears the storage after you quit it but not between runs of the test\n         * suite, and the tests expect an empty FS every time.\n         */\n        empty(mainCb) {\n            // Get a list of all entries in the root directory to delete them\n            this._readdir('/', (err, entries) => {\n                if (err) {\n                    mainCb(err);\n                }\n                else {\n                    // Called when every entry has been operated on\n                    const finished = (er) => {\n                        if (err) {\n                            mainCb(err);\n                        }\n                        else {\n                            mainCb();\n                        }\n                    };\n                    // Removes files and recursively removes directories\n                    const deleteEntry = (entry, cb) => {\n                        const succ = () => {\n                            cb();\n                        };\n                        const error = (err) => {\n                            cb(convertError(err, entry.fullPath, !entry.isDirectory));\n                        };\n                        if (isDirectoryEntry(entry)) {\n                            entry.removeRecursively(succ, error);\n                        }\n                        else {\n                            entry.remove(succ, error);\n                        }\n                    };\n                    // Loop through the entries and remove them, then call the callback\n                    // when they're all finished.\n                    asyncEach(entries, deleteEntry, finished);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            let semaphore = 2;\n            let successCount = 0;\n            const root = this.fs.root;\n            let currentPath = oldPath;\n            const error = (err) => {\n                if (--semaphore <= 0) {\n                    cb(convertError(err, currentPath, false));\n                }\n            };\n            const success = (file) => {\n                if (++successCount === 2) {\n                    return cb(new ApiError(ErrorCode.EINVAL, \"Something was identified as both a file and a directory. This should never happen.\"));\n                }\n                // SPECIAL CASE: If newPath === oldPath, and the path exists, then\n                // this operation trivially succeeds.\n                if (oldPath === newPath) {\n                    return cb();\n                }\n                // Get the new parent directory.\n                currentPath = path.dirname(newPath);\n                root.getDirectory(currentPath, {}, (parentDir) => {\n                    currentPath = path.basename(newPath);\n                    file.moveTo(parentDir, currentPath, (entry) => { cb(); }, (err) => {\n                        // SPECIAL CASE: If oldPath is a directory, and newPath is a\n                        // file, rename should delete the file and perform the move.\n                        if (file.isDirectory) {\n                            currentPath = newPath;\n                            // Unlink only works on files. Try to delete newPath.\n                            this.unlink(newPath, (e) => {\n                                if (e) {\n                                    // newPath is probably a directory.\n                                    error(err);\n                                }\n                                else {\n                                    // Recur, now that newPath doesn't exist.\n                                    this.rename(oldPath, newPath, cb);\n                                }\n                            });\n                        }\n                        else {\n                            error(err);\n                        }\n                    });\n                }, error);\n            };\n            // We don't know if oldPath is a *file* or a *directory*, and there's no\n            // way to stat items. So launch both requests, see which one succeeds.\n            root.getFile(oldPath, {}, success, error);\n            root.getDirectory(oldPath, {}, success, error);\n        }\n        stat(path, isLstat, cb) {\n            // Throw an error if the entry doesn't exist, because then there's nothing\n            // to stat.\n            const opts = {\n                create: false\n            };\n            // Called when the path has been successfully loaded as a file.\n            const loadAsFile = (entry) => {\n                const fileFromEntry = (file) => {\n                    const stat = new Stats(FileType.FILE, file.size);\n                    cb(null, stat);\n                };\n                entry.file(fileFromEntry, failedToLoad);\n            };\n            // Called when the path has been successfully loaded as a directory.\n            const loadAsDir = (dir) => {\n                // Directory entry size can't be determined from the HTML5 FS API, and is\n                // implementation-dependant anyway, so a dummy value is used.\n                const size = 4096;\n                const stat = new Stats(FileType.DIRECTORY, size);\n                cb(null, stat);\n            };\n            // Called when the path couldn't be opened as a directory or a file.\n            const failedToLoad = (err) => {\n                cb(convertError(err, path, false /* Unknown / irrelevant */));\n            };\n            // Called when the path couldn't be opened as a file, but might still be a\n            // directory.\n            const failedToLoadAsFile = () => {\n                this.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);\n            };\n            // No method currently exists to determine whether a path refers to a\n            // directory or a file, so this implementation tries both and uses the first\n            // one that succeeds.\n            this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);\n        }\n        open(p, flags, mode, cb) {\n            // XXX: err is a DOMError\n            const error = (err) => {\n                if (err.name === 'InvalidModificationError' && flags.isExclusive()) {\n                    cb(ApiError.EEXIST(p));\n                }\n                else {\n                    cb(convertError(err, p, false));\n                }\n            };\n            this.fs.root.getFile(p, {\n                create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,\n                exclusive: flags.isExclusive()\n            }, (entry) => {\n                // Try to fetch corresponding file.\n                entry.file((file) => {\n                    const reader = new FileReader();\n                    reader.onloadend = (event) => {\n                        const bfsFile = this._makeFile(p, entry, flags, file, reader.result);\n                        cb(null, bfsFile);\n                    };\n                    reader.onerror = (ev) => {\n                        error(reader.error);\n                    };\n                    reader.readAsArrayBuffer(file);\n                }, error);\n            }, error);\n        }\n        unlink(path, cb) {\n            this._remove(path, cb, true);\n        }\n        rmdir(path, cb) {\n            // Check if directory is non-empty, first.\n            this.readdir(path, (e, files) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (files.length > 0) {\n                    cb(ApiError.ENOTEMPTY(path));\n                }\n                else {\n                    this._remove(path, cb, false);\n                }\n            });\n        }\n        mkdir(path, mode, cb) {\n            // Create the directory, but throw an error if it already exists, as per\n            // mkdir(1)\n            const opts = {\n                create: true,\n                exclusive: true\n            };\n            const success = (dir) => {\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            this.fs.root.getDirectory(path, opts, success, error);\n        }\n        /**\n         * Map _readdir's list of `FileEntry`s to their names and return that.\n         */\n        readdir(path, cb) {\n            this._readdir(path, (e, entries) => {\n                if (entries) {\n                    const rv = [];\n                    for (const entry of entries) {\n                        rv.push(entry.name);\n                    }\n                    cb(null, rv);\n                }\n                else {\n                    return cb(e);\n                }\n            });\n        }\n        /**\n         * Returns a BrowserFS object representing a File.\n         */\n        _makeFile(path, entry, flag, stat, data = new ArrayBuffer(0)) {\n            const stats = new Stats(FileType.FILE, stat.size);\n            const buffer = arrayBuffer2Buffer(data);\n            return new HTML5FSFile(this, entry, path, flag, stats, buffer);\n        }\n        /**\n         * Returns an array of `FileEntry`s. Used internally by empty and readdir.\n         */\n        _readdir(path, cb) {\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            // Grab the requested directory.\n            this.fs.root.getDirectory(path, { create: false }, (dirEntry) => {\n                const reader = dirEntry.createReader();\n                let entries = [];\n                // Call the reader.readEntries() until no more results are returned.\n                const readEntries = () => {\n                    reader.readEntries(((results) => {\n                        if (results.length) {\n                            entries = entries.concat(_toArray(results));\n                            readEntries();\n                        }\n                        else {\n                            cb(null, entries);\n                        }\n                    }), error);\n                };\n                readEntries();\n            }, error);\n        }\n        /**\n         * Requests a storage quota from the browser to back this FS.\n         */\n        _allocate(cb) {\n            const success = (fs) => {\n                this.fs = fs;\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, \"/\", true));\n            };\n            if (this.type === global.PERSISTENT) {\n                _requestQuota(this.type, this.size, (granted) => {\n                    _getFS(this.type, granted, success, error);\n                }, error);\n            }\n            else {\n                _getFS(this.type, this.size, success, error);\n            }\n        }\n        /**\n         * Delete a file or directory from the file system\n         * isFile should reflect which call was made to remove the it (`unlink` or\n         * `rmdir`). If this doesn't match what's actually at `path`, an error will be\n         * returned\n         */\n        _remove(path, cb, isFile) {\n            const success = (entry) => {\n                const succ = () => {\n                    cb();\n                };\n                const err = (err) => {\n                    cb(convertError(err, path, !isFile));\n                };\n                entry.remove(succ, err);\n            };\n            const error = (err) => {\n                cb(convertError(err, path, !isFile));\n            };\n            // Deleting the entry, so don't create it\n            const opts = {\n                create: false\n            };\n            if (isFile) {\n                this.fs.root.getFile(path, opts, success, error);\n            }\n            else {\n                this.fs.root.getDirectory(path, opts, success, error);\n            }\n        }\n    }\n    HTML5FS.Name = \"HTML5FS\";\n    HTML5FS.Options = {\n        size: {\n            type: \"number\",\n            optional: true,\n            description: \"Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5.\"\n        },\n        type: {\n            type: \"number\",\n            optional: true,\n            description: \"window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\"\n        }\n    };\n\n    HTML5FS.HTML5FSFile = HTML5FSFile;\n\n    return HTML5FS;\n});"]}