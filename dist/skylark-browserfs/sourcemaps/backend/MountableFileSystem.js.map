{"version":3,"sources":["backend/MountableFileSystem.js"],"names":["define","file_system","InMemory","api_error","fs","path","util","BaseFileSystem","InMemoryFileSystem","ApiError","ErrorCode","mkdirpSync","MountableFileSystem","[object Object]","rootFs","super","this","mountList","mntMap","opts","cb","Create","e","imfs","Object","keys","forEach","mountPoint","mount","resolve","EINVAL","push","sort","a","b","length","splice","indexOf","readdirSync","rmdirSync","dirname","len","i","substr","Name","err","realPath","index","message","oldPath","newPath","fs1rv","_getFs","fs2rv","rename","standardizeError","readFile","data","writeFile","unlink","renameSync","readFileSync","writeFileSync","unlinkSync","p","fsInfo","rv","rv2","concat","filter","val","readdir","files","cache","mountedPath","realpathSync","join","realpath","_containsMountPt","ENOTEMPTY","rmdir","mountPoints","pt","slice","defineFcn","name","isSync","numArgs","args","apply","Options","fsCmdMap","cmds","fnName","prototype"],"mappings":"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","file":"../../backend/MountableFileSystem.js","sourcesContent":["define([\n    '../core/file_system',\n    './InMemory',\n    '../core/api_error',\n    '../core/node_fs',\n    '../libs/path',\n    '../core/util'\n], function (file_system, InMemory, api_error, fs, path, util) {\n    'use strict';\n    const { BaseFileSystem } = file_system;\n    const {InMemoryFileSystem}  = InMemory;\n    const { ApiError, ErrorCode }  = api_error;\n    const { mkdirpSync }  = util;\n\n    /**\n     * The MountableFileSystem allows you to mount multiple backend types or\n     * multiple instantiations of the same backend into a single file system tree.\n     * The file systems do not need to know about each other; all interactions are\n     * automatically facilitated through this interface.\n     *\n     * For example, if a file system is mounted at /mnt/blah, and a request came in\n     * for /mnt/blah/foo.txt, the file system would see a request for /foo.txt.\n     *\n     * You can mount file systems when you configure the file system:\n     * ```javascript\n     * BrowserFS.configure({\n     *   fs: \"MountableFileSystem\",\n     *   options: {\n     *     '/data': { fs: 'HTTPRequest', options: { index: \"http://mysite.com/files/index.json\" } },\n     *     '/home': { fs: 'LocalStorage' }\n     *   }\n     * }, function(e) {\n     *\n     * });\n     * ```\n     *\n     * For advanced users, you can also mount file systems *after* MFS is constructed:\n     * ```javascript\n     * BrowserFS.FileSystem.HTTPRequest.Create({\n     *   index: \"http://mysite.com/files/index.json\"\n     * }, function(e, xhrfs) {\n     *   BrowserFS.FileSystem.MountableFileSystem.Create({\n     *     '/data': xhrfs\n     *   }, function(e, mfs) {\n     *     BrowserFS.initialize(mfs);\n     *\n     *     // Added after-the-fact...\n     *     BrowserFS.FileSystem.LocalStorage.Create(function(e, lsfs) {\n     *       mfs.mount('/home', lsfs);\n     *     });\n     *   });\n     * });\n     * ```\n     *\n     * Since MountableFileSystem simply proxies requests to mounted file systems, it supports all of the operations that the mounted file systems support.\n     *\n     * With no mounted file systems, `MountableFileSystem` acts as a simple `InMemory` filesystem.\n     */\n    class MountableFileSystem extends BaseFileSystem {\n        /**\n         * Creates a new, empty MountableFileSystem.\n         */\n        constructor(rootFs) {\n            super();\n            // Contains the list of mount points in mntMap, sorted by string length in decreasing order.\n            // Ensures that we scan the most specific mount points for a match first, which lets us\n            // nest mount points.\n            this.mountList = [];\n            this.mntMap = {};\n            this.rootFs = rootFs;\n        }\n        /**\n         * Creates a MountableFileSystem instance with the given options.\n         */\n        static Create(opts, cb) {\n            InMemoryFileSystem.Create({}, (e, imfs) => {\n                if (imfs) {\n                    const fs = new MountableFileSystem(imfs);\n                    try {\n                        Object.keys(opts).forEach((mountPoint) => {\n                            fs.mount(mountPoint, opts[mountPoint]);\n                        });\n                    }\n                    catch (e) {\n                        return cb(e);\n                    }\n                    cb(null, fs);\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        static isAvailable() {\n            return true;\n        }\n        /**\n         * Mounts the file system at the given mount point.\n         */\n        mount(mountPoint, fs) {\n            if (mountPoint[0] !== '/') {\n                mountPoint = `/${mountPoint}`;\n            }\n            mountPoint = path.resolve(mountPoint);\n            if (this.mntMap[mountPoint]) {\n                throw new ApiError(ErrorCode.EINVAL, \"Mount point \" + mountPoint + \" is already taken.\");\n            }\n            mkdirpSync(mountPoint, 0x1ff, this.rootFs);\n            this.mntMap[mountPoint] = fs;\n            this.mountList.push(mountPoint);\n            this.mountList = this.mountList.sort((a, b) => b.length - a.length);\n        }\n        umount(mountPoint) {\n            if (mountPoint[0] !== '/') {\n                mountPoint = `/${mountPoint}`;\n            }\n            mountPoint = path.resolve(mountPoint);\n            if (!this.mntMap[mountPoint]) {\n                throw new ApiError(ErrorCode.EINVAL, \"Mount point \" + mountPoint + \" is already unmounted.\");\n            }\n            delete this.mntMap[mountPoint];\n            this.mountList.splice(this.mountList.indexOf(mountPoint), 1);\n            while (mountPoint !== '/') {\n                if (this.rootFs.readdirSync(mountPoint).length === 0) {\n                    this.rootFs.rmdirSync(mountPoint);\n                    mountPoint = path.dirname(mountPoint);\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        /**\n         * Returns the file system that the path points to.\n         */\n        _getFs(path) {\n            const mountList = this.mountList, len = mountList.length;\n            for (let i = 0; i < len; i++) {\n                const mountPoint = mountList[i];\n                // We know path is normalized, so it is a substring of the mount point.\n                if (mountPoint.length <= path.length && path.indexOf(mountPoint) === 0) {\n                    path = path.substr(mountPoint.length > 1 ? mountPoint.length : 0);\n                    if (path === '') {\n                        path = '/';\n                    }\n                    return { fs: this.mntMap[mountPoint], path: path, mountPoint: mountPoint };\n                }\n            }\n            // Query our root file system.\n            return { fs: this.rootFs, path: path, mountPoint: '/' };\n        }\n        // Global information methods\n        getName() {\n            return MountableFileSystem.Name;\n        }\n        diskSpace(path, cb) {\n            cb(0, 0);\n        }\n        isReadOnly() {\n            return false;\n        }\n        supportsLinks() {\n            // I'm not ready for cross-FS links yet.\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return true;\n        }\n        /**\n         * Fixes up error messages so they mention the mounted file location relative\n         * to the MFS root, not to the particular FS's root.\n         * Mutates the input error, and returns it.\n         */\n        standardizeError(err, path, realPath) {\n            const index = err.message.indexOf(path);\n            if (index !== -1) {\n                err.message = err.message.substr(0, index) + realPath + err.message.substr(index + path.length);\n                err.path = realPath;\n            }\n            return err;\n        }\n        // The following methods involve multiple file systems, and thus have custom\n        // logic.\n        // Note that we go through the Node API to use its robust default argument\n        // processing.\n        rename(oldPath, newPath, cb) {\n            // Scenario 1: old and new are on same FS.\n            const fs1rv = this._getFs(oldPath);\n            const fs2rv = this._getFs(newPath);\n            if (fs1rv.fs === fs2rv.fs) {\n                return fs1rv.fs.rename(fs1rv.path, fs2rv.path, (e) => {\n                    if (e) {\n                        this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);\n                    }\n                    cb(e);\n                });\n            }\n            // Scenario 2: Different file systems.\n            // Read old file, write new file, delete old file.\n            return fs.readFile(oldPath, function (err, data) {\n                if (err) {\n                    return cb(err);\n                }\n                fs.writeFile(newPath, data, function (err) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    fs.unlink(oldPath, cb);\n                });\n            });\n        }\n        renameSync(oldPath, newPath) {\n            // Scenario 1: old and new are on same FS.\n            const fs1rv = this._getFs(oldPath);\n            const fs2rv = this._getFs(newPath);\n            if (fs1rv.fs === fs2rv.fs) {\n                try {\n                    return fs1rv.fs.renameSync(fs1rv.path, fs2rv.path);\n                }\n                catch (e) {\n                    this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);\n                    throw e;\n                }\n            }\n            // Scenario 2: Different file systems.\n            const data = fs.readFileSync(oldPath);\n            fs.writeFileSync(newPath, data);\n            return fs.unlinkSync(oldPath);\n        }\n        readdirSync(p) {\n            const fsInfo = this._getFs(p);\n            // If null, rootfs did not have the directory\n            // (or the target FS is the root fs).\n            let rv = null;\n            // Mount points are all defined in the root FS.\n            // Ensure that we list those, too.\n            if (fsInfo.fs !== this.rootFs) {\n                try {\n                    rv = this.rootFs.readdirSync(p);\n                }\n                catch (e) {\n                    // Ignore.\n                }\n            }\n            try {\n                const rv2 = fsInfo.fs.readdirSync(fsInfo.path);\n                if (rv === null) {\n                    return rv2;\n                }\n                else {\n                    // Filter out duplicates.\n                    return rv2.concat(rv.filter((val) => rv2.indexOf(val) === -1));\n                }\n            }\n            catch (e) {\n                if (rv === null) {\n                    throw this.standardizeError(e, fsInfo.path, p);\n                }\n                else {\n                    // The root FS had something.\n                    return rv;\n                }\n            }\n        }\n        readdir(p, cb) {\n            const fsInfo = this._getFs(p);\n            fsInfo.fs.readdir(fsInfo.path, (err, files) => {\n                if (fsInfo.fs !== this.rootFs) {\n                    try {\n                        const rv = this.rootFs.readdirSync(p);\n                        if (files) {\n                            // Filter out duplicates.\n                            files = files.concat(rv.filter((val) => files.indexOf(val) === -1));\n                        }\n                        else {\n                            files = rv;\n                        }\n                    }\n                    catch (e) {\n                        // Root FS and target FS did not have directory.\n                        if (err) {\n                            return cb(this.standardizeError(err, fsInfo.path, p));\n                        }\n                    }\n                }\n                else if (err) {\n                    // Root FS and target FS are the same, and did not have directory.\n                    return cb(this.standardizeError(err, fsInfo.path, p));\n                }\n                cb(null, files);\n            });\n        }\n        realpathSync(p, cache) {\n            const fsInfo = this._getFs(p);\n            try {\n                const mountedPath = fsInfo.fs.realpathSync(fsInfo.path, {});\n                // resolve is there to remove any trailing slash that may be present\n                return path.resolve(path.join(fsInfo.mountPoint, mountedPath));\n            }\n            catch (e) {\n                throw this.standardizeError(e, fsInfo.path, p);\n            }\n        }\n        realpath(p, cache, cb) {\n            const fsInfo = this._getFs(p);\n            fsInfo.fs.realpath(fsInfo.path, {}, (err, rv) => {\n                if (err) {\n                    cb(this.standardizeError(err, fsInfo.path, p));\n                }\n                else {\n                    // resolve is there to remove any trailing slash that may be present\n                    cb(null, path.resolve(path.join(fsInfo.mountPoint, rv)));\n                }\n            });\n        }\n        rmdirSync(p) {\n            const fsInfo = this._getFs(p);\n            if (this._containsMountPt(p)) {\n                throw ApiError.ENOTEMPTY(p);\n            }\n            else {\n                try {\n                    fsInfo.fs.rmdirSync(fsInfo.path);\n                }\n                catch (e) {\n                    throw this.standardizeError(e, fsInfo.path, p);\n                }\n            }\n        }\n        rmdir(p, cb) {\n            const fsInfo = this._getFs(p);\n            if (this._containsMountPt(p)) {\n                cb(ApiError.ENOTEMPTY(p));\n            }\n            else {\n                fsInfo.fs.rmdir(fsInfo.path, (err) => {\n                    cb(err ? this.standardizeError(err, fsInfo.path, p) : null);\n                });\n            }\n        }\n        /**\n         * Returns true if the given path contains a mount point.\n         */\n        _containsMountPt(p) {\n            const mountPoints = this.mountList, len = mountPoints.length;\n            for (let i = 0; i < len; i++) {\n                const pt = mountPoints[i];\n                if (pt.length >= p.length && pt.slice(0, p.length) === p) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    MountableFileSystem.Name = \"MountableFileSystem\";\n    MountableFileSystem.Options = {};\n    /**\n     * Tricky: Define all of the functions that merely forward arguments to the\n     * relevant file system, or return/throw an error.\n     * Take advantage of the fact that the *first* argument is always the path, and\n     * the *last* is the callback function (if async).\n     * @todo Can use numArgs to make proxying more efficient.\n     * @hidden\n     */\n    function defineFcn(name, isSync, numArgs) {\n        if (isSync) {\n            return function (...args) {\n                const path = args[0];\n                const rv = this._getFs(path);\n                args[0] = rv.path;\n                try {\n                    return rv.fs[name].apply(rv.fs, args);\n                }\n                catch (e) {\n                    this.standardizeError(e, rv.path, path);\n                    throw e;\n                }\n            };\n        }\n        else {\n            return function (...args) {\n                const path = args[0];\n                const rv = this._getFs(path);\n                args[0] = rv.path;\n                if (typeof args[args.length - 1] === 'function') {\n                    const cb = args[args.length - 1];\n                    args[args.length - 1] = (...args) => {\n                        if (args.length > 0 && args[0] instanceof ApiError) {\n                            this.standardizeError(args[0], rv.path, path);\n                        }\n                        cb.apply(null, args);\n                    };\n                }\n                return rv.fs[name].apply(rv.fs, args);\n            };\n        }\n    }\n    /**\n     * @hidden\n     */\n    const fsCmdMap = [\n        // 1 arg functions\n        ['exists', 'unlink', 'readlink'],\n        // 2 arg functions\n        ['stat', 'mkdir', 'truncate'],\n        // 3 arg functions\n        ['open', 'readFile', 'chmod', 'utimes'],\n        // 4 arg functions\n        ['chown'],\n        // 5 arg functions\n        ['writeFile', 'appendFile']\n    ];\n    for (let i = 0; i < fsCmdMap.length; i++) {\n        const cmds = fsCmdMap[i];\n        for (const fnName of cmds) {\n            MountableFileSystem.prototype[fnName] = defineFcn(fnName, false, i + 1);\n            MountableFileSystem.prototype[fnName + 'Sync'] = defineFcn(fnName + 'Sync', true, i + 1);\n        }\n    }\n\n\n    return MountableFileSystem;\n});"]}