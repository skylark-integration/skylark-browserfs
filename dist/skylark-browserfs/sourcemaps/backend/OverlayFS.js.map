{"version":3,"sources":["backend/OverlayFS.js"],"names":["define","file_system","api_error","file_flag","node_fs_stats","preload_file","LockedFS","path","BaseFileSystem","ApiError","ErrorCode","FileFlag","ActionType","Stats","PreloadFile","deletionLogPath","makeModeWritable","mode","getFlag","f","getFileFlag","OverlayFile","[object Object]","fs","flag","stats","data","super","cb","this","isDirty","_fs","_syncAsync","err","resetDirty","_syncSync","sync","syncSync","UnlockedOverlayFS","writable","readable","_isInitialized","_initializeCallbacks","_deletedFiles","_deleteLog","_deleteLogUpdatePending","_deleteLogUpdateNeeded","_deleteLogError","_writable","_readable","isReadOnly","EINVAL","file","createParentDirectoriesAsync","getPath","writeFile","getBuffer","getStats","createParentDirectories","writeFileSync","OverlayFS","Name","callbackArray","end","e","forEach","push","length","readFile","errno","ENOENT","_reparseDeletionLog","supportsSynch","supportsProps","log","updateLog","oldPath","newPath","checkInitAsync","checkPathAsync","EPERM","stat","oldErr","oldStats","newErr","newStats","self","copyDirContents","files","shift","oldFile","resolve","newFile","rename","isDirectory","exists","mkdir","mkdirErr","readdir","ENOTDIR","readdirErr","ENOTEMPTY","EISDIR","unlink","checkInitialized","checkPath","statSync","existsSync","readdirSync","renameSync","mkdirSync","name","readFileSync","unlinkSync","p","isLstat","clone","oldStat","pathExistsAction","TRUNCATE_FILE","open","NOP","readFileErr","size","EEXIST","pathNotExistsAction","CREATE_FILE","openSync","buf","writableExists","readableExists","deletePath","rmdirLower","rmdir","rmdirSync","dirStats","wFiles","code","rFiles","seenMap","filtered","concat","filter","fPath","result","contents","fileP","existsWritable","existsReadable","isLchmod","operateOnWritableAsync","chmod","operateOnWritable","chmodSync","uid","gid","chown","isLchown","chownSync","atime","mtime","utimes","utimesSync","addition","split","slice","parent","dirname","toCreate","statDone","EBUSY","createParents","dir","pop","reverse","copyToWritable","copyToWritableAsync","pStats","opts","_initialize","isAvailable","getFSUnlocked","getOverlayedFileSystems","Options","type","description"],"mappings":"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","file":"../../backend/OverlayFS.js","sourcesContent":["define([\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/node_fs_stats',\n    '../generic/preload_file',\n    '../generic/locked_fs',\n    '../libs/path'\n], function (file_system, api_error, file_flag, node_fs_stats, preload_file, LockedFS, path) {\n\n    'use strict';\n\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode }  = api_error;\n    const { FileFlag, ActionType }  = file_flag;\n    const { Stats }  = node_fs_stats;\n    const {PreloadFile}  = preload_file;\n\n    /**\n     * @hidden\n     */\n    const deletionLogPath = '/.deletedFiles.log';\n    /**\n     * Given a read-only mode, makes it writable.\n     * @hidden\n     */\n    function makeModeWritable(mode) {\n        return 0o222 | mode;\n    }\n    /**\n     * @hidden\n     */\n    function getFlag(f) {\n        return FileFlag.getFileFlag(f);\n    }\n    /**\n     * Overlays a RO file to make it writable.\n     */\n    class OverlayFile extends PreloadFile {\n        constructor(fs, path, flag, stats, data) {\n            super(fs, path, flag, stats, data);\n        }\n        sync(cb) {\n            if (!this.isDirty()) {\n                cb(null);\n                return;\n            }\n            this._fs._syncAsync(this, (err) => {\n                this.resetDirty();\n                cb(err);\n            });\n        }\n        syncSync() {\n            if (this.isDirty()) {\n                this._fs._syncSync(this);\n                this.resetDirty();\n            }\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n        closeSync() {\n            this.syncSync();\n        }\n    }\n    /**\n     * *INTERNAL, DO NOT USE DIRECTLY!*\n     *\n     * Core OverlayFS class that contains no locking whatsoever. We wrap these objects\n     * in a LockedFS to prevent races.\n     */\n    class UnlockedOverlayFS extends BaseFileSystem {\n        constructor(writable, readable) {\n            super();\n            this._isInitialized = false;\n            this._initializeCallbacks = [];\n            this._deletedFiles = {};\n            this._deleteLog = '';\n            // If 'true', we have scheduled a delete log update.\n            this._deleteLogUpdatePending = false;\n            // If 'true', a delete log update is needed after the scheduled delete log\n            // update finishes.\n            this._deleteLogUpdateNeeded = false;\n            // If there was an error updating the delete log...\n            this._deleteLogError = null;\n            this._writable = writable;\n            this._readable = readable;\n            if (this._writable.isReadOnly()) {\n                throw new ApiError(ErrorCode.EINVAL, \"Writable file system must be writable.\");\n            }\n        }\n        static isAvailable() {\n            return true;\n        }\n        getOverlayedFileSystems() {\n            return {\n                readable: this._readable,\n                writable: this._writable\n            };\n        }\n        _syncAsync(file, cb) {\n            this.createParentDirectoriesAsync(file.getPath(), (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                this._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);\n            });\n        }\n        _syncSync(file) {\n            this.createParentDirectories(file.getPath());\n            this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);\n        }\n        getName() {\n            return OverlayFS.Name;\n        }\n        /**\n         * **INTERNAL METHOD**\n         *\n         * Called once to load up metadata stored on the writable file system.\n         */\n        _initialize(cb) {\n            const callbackArray = this._initializeCallbacks;\n            const end = (e) => {\n                this._isInitialized = !e;\n                this._initializeCallbacks = [];\n                callbackArray.forEach(((cb) => cb(e)));\n            };\n            // if we're already initialized, immediately invoke the callback\n            if (this._isInitialized) {\n                return cb();\n            }\n            callbackArray.push(cb);\n            // The first call to initialize initializes, the rest wait for it to complete.\n            if (callbackArray.length !== 1) {\n                return;\n            }\n            // Read deletion log, process into metadata.\n            this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), (err, data) => {\n                if (err) {\n                    // ENOENT === Newly-instantiated file system, and thus empty log.\n                    if (err.errno !== ErrorCode.ENOENT) {\n                        return end(err);\n                    }\n                }\n                else {\n                    this._deleteLog = data;\n                }\n                this._reparseDeletionLog();\n                end();\n            });\n        }\n        isReadOnly() { return false; }\n        supportsSynch() { return this._readable.supportsSynch() && this._writable.supportsSynch(); }\n        supportsLinks() { return false; }\n        supportsProps() { return this._readable.supportsProps() && this._writable.supportsProps(); }\n        getDeletionLog() {\n            return this._deleteLog;\n        }\n        restoreDeletionLog(log) {\n            this._deleteLog = log;\n            this._reparseDeletionLog();\n            this.updateLog('');\n        }\n        rename(oldPath, newPath, cb) {\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {\n                return;\n            }\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\n                return cb(ApiError.EPERM('Cannot rename deletion log.'));\n            }\n            // nothing to do if paths match\n            if (oldPath === newPath) {\n                return cb();\n            }\n            this.stat(oldPath, false, (oldErr, oldStats) => {\n                if (oldErr) {\n                    return cb(oldErr);\n                }\n                return this.stat(newPath, false, (newErr, newStats) => {\n                    const self = this;\n                    // precondition: both oldPath and newPath exist and are dirs.\n                    // decreases: |files|\n                    // Need to move *every file/folder* currently stored on\n                    // readable to its new location on writable.\n                    function copyDirContents(files) {\n                        const file = files.shift();\n                        if (!file) {\n                            return cb();\n                        }\n                        const oldFile = path.resolve(oldPath, file);\n                        const newFile = path.resolve(newPath, file);\n                        // Recursion! Should work for any nested files / folders.\n                        self.rename(oldFile, newFile, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            copyDirContents(files);\n                        });\n                    }\n                    let mode = 0o777;\n                    // from linux's rename(2) manpage: oldpath can specify a\n                    // directory.  In this case, newpath must either not exist, or\n                    // it must specify an empty directory.\n                    if (oldStats.isDirectory()) {\n                        if (newErr) {\n                            if (newErr.errno !== ErrorCode.ENOENT) {\n                                return cb(newErr);\n                            }\n                            return this._writable.exists(oldPath, (exists) => {\n                                // simple case - both old and new are on the writable layer\n                                if (exists) {\n                                    return this._writable.rename(oldPath, newPath, cb);\n                                }\n                                this._writable.mkdir(newPath, mode, (mkdirErr) => {\n                                    if (mkdirErr) {\n                                        return cb(mkdirErr);\n                                    }\n                                    this._readable.readdir(oldPath, (err, files) => {\n                                        if (err) {\n                                            return cb();\n                                        }\n                                        copyDirContents(files);\n                                    });\n                                });\n                            });\n                        }\n                        mode = newStats.mode;\n                        if (!newStats.isDirectory()) {\n                            return cb(ApiError.ENOTDIR(newPath));\n                        }\n                        this.readdir(newPath, (readdirErr, files) => {\n                            if (files && files.length) {\n                                return cb(ApiError.ENOTEMPTY(newPath));\n                            }\n                            this._readable.readdir(oldPath, (err, files) => {\n                                if (err) {\n                                    return cb();\n                                }\n                                copyDirContents(files);\n                            });\n                        });\n                    }\n                    if (newStats && newStats.isDirectory()) {\n                        return cb(ApiError.EISDIR(newPath));\n                    }\n                    this.readFile(oldPath, null, getFlag('r'), (err, data) => {\n                        if (err) {\n                            return cb(err);\n                        }\n                        return this.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            return this.unlink(oldPath, cb);\n                        });\n                    });\n                });\n            });\n        }\n        renameSync(oldPath, newPath) {\n            this.checkInitialized();\n            this.checkPath(oldPath);\n            this.checkPath(newPath);\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\n                throw ApiError.EPERM('Cannot rename deletion log.');\n            }\n            // Write newPath using oldPath's contents, delete oldPath.\n            const oldStats = this.statSync(oldPath, false);\n            if (oldStats.isDirectory()) {\n                // Optimization: Don't bother moving if old === new.\n                if (oldPath === newPath) {\n                    return;\n                }\n                let mode = 0o777;\n                if (this.existsSync(newPath)) {\n                    const stats = this.statSync(newPath, false);\n                    mode = stats.mode;\n                    if (stats.isDirectory()) {\n                        if (this.readdirSync(newPath).length > 0) {\n                            throw ApiError.ENOTEMPTY(newPath);\n                        }\n                    }\n                    else {\n                        throw ApiError.ENOTDIR(newPath);\n                    }\n                }\n                // Take care of writable first. Move any files there, or create an empty directory\n                // if it doesn't exist.\n                if (this._writable.existsSync(oldPath)) {\n                    this._writable.renameSync(oldPath, newPath);\n                }\n                else if (!this._writable.existsSync(newPath)) {\n                    this._writable.mkdirSync(newPath, mode);\n                }\n                // Need to move *every file/folder* currently stored on readable to its new location\n                // on writable.\n                if (this._readable.existsSync(oldPath)) {\n                    this._readable.readdirSync(oldPath).forEach((name) => {\n                        // Recursion! Should work for any nested files / folders.\n                        this.renameSync(path.resolve(oldPath, name), path.resolve(newPath, name));\n                    });\n                }\n            }\n            else {\n                if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {\n                    throw ApiError.EISDIR(newPath);\n                }\n                this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);\n            }\n            if (oldPath !== newPath && this.existsSync(oldPath)) {\n                this.unlinkSync(oldPath);\n            }\n        }\n        stat(p, isLstat, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this._writable.stat(p, isLstat, (err, stat) => {\n                if (err && err.errno === ErrorCode.ENOENT) {\n                    if (this._deletedFiles[p]) {\n                        cb(ApiError.ENOENT(p));\n                    }\n                    this._readable.stat(p, isLstat, (err, stat) => {\n                        if (stat) {\n                            // Make the oldStat's mode writable. Preserve the topmost\n                            // part of the mode, which specifies if it is a file or a\n                            // directory.\n                            stat = Stats.clone(stat);\n                            stat.mode = makeModeWritable(stat.mode);\n                        }\n                        cb(err, stat);\n                    });\n                }\n                else {\n                    cb(err, stat);\n                }\n            });\n        }\n        statSync(p, isLstat) {\n            this.checkInitialized();\n            try {\n                return this._writable.statSync(p, isLstat);\n            }\n            catch (e) {\n                if (this._deletedFiles[p]) {\n                    throw ApiError.ENOENT(p);\n                }\n                const oldStat = Stats.clone(this._readable.statSync(p, isLstat));\n                // Make the oldStat's mode writable. Preserve the topmost part of the\n                // mode, which specifies if it is a file or a directory.\n                oldStat.mode = makeModeWritable(oldStat.mode);\n                return oldStat;\n            }\n        }\n        open(p, flag, mode, cb) {\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\n                return;\n            }\n            this.stat(p, false, (err, stats) => {\n                if (stats) {\n                    switch (flag.pathExistsAction()) {\n                        case ActionType.TRUNCATE_FILE:\n                            return this.createParentDirectoriesAsync(p, (err) => {\n                                if (err) {\n                                    return cb(err);\n                                }\n                                this._writable.open(p, flag, mode, cb);\n                            });\n                        case ActionType.NOP:\n                            return this._writable.exists(p, (exists) => {\n                                if (exists) {\n                                    this._writable.open(p, flag, mode, cb);\n                                }\n                                else {\n                                    // at this point we know the stats object we got is from\n                                    // the readable FS.\n                                    stats = Stats.clone(stats);\n                                    stats.mode = mode;\n                                    this._readable.readFile(p, null, getFlag('r'), (readFileErr, data) => {\n                                        if (readFileErr) {\n                                            return cb(readFileErr);\n                                        }\n                                        if (stats.size === -1) {\n                                            stats.size = data.length;\n                                        }\n                                        const f = new OverlayFile(this, p, flag, stats, data);\n                                        cb(null, f);\n                                    });\n                                }\n                            });\n                        default:\n                            return cb(ApiError.EEXIST(p));\n                    }\n                }\n                else {\n                    switch (flag.pathNotExistsAction()) {\n                        case ActionType.CREATE_FILE:\n                            return this.createParentDirectoriesAsync(p, (err) => {\n                                if (err) {\n                                    return cb(err);\n                                }\n                                return this._writable.open(p, flag, mode, cb);\n                            });\n                        default:\n                            return cb(ApiError.ENOENT(p));\n                    }\n                }\n            });\n        }\n        openSync(p, flag, mode) {\n            this.checkInitialized();\n            this.checkPath(p);\n            if (p === deletionLogPath) {\n                throw ApiError.EPERM('Cannot open deletion log.');\n            }\n            if (this.existsSync(p)) {\n                switch (flag.pathExistsAction()) {\n                    case ActionType.TRUNCATE_FILE:\n                        this.createParentDirectories(p);\n                        return this._writable.openSync(p, flag, mode);\n                    case ActionType.NOP:\n                        if (this._writable.existsSync(p)) {\n                            return this._writable.openSync(p, flag, mode);\n                        }\n                        else {\n                            // Create an OverlayFile.\n                            const buf = this._readable.readFileSync(p, null, getFlag('r'));\n                            const stats = Stats.clone(this._readable.statSync(p, false));\n                            stats.mode = mode;\n                            return new OverlayFile(this, p, flag, stats, buf);\n                        }\n                    default:\n                        throw ApiError.EEXIST(p);\n                }\n            }\n            else {\n                switch (flag.pathNotExistsAction()) {\n                    case ActionType.CREATE_FILE:\n                        this.createParentDirectories(p);\n                        return this._writable.openSync(p, flag, mode);\n                    default:\n                        throw ApiError.ENOENT(p);\n                }\n            }\n        }\n        unlink(p, cb) {\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\n                return;\n            }\n            this.exists(p, (exists) => {\n                if (!exists) {\n                    return cb(ApiError.ENOENT(p));\n                }\n                this._writable.exists(p, (writableExists) => {\n                    if (writableExists) {\n                        return this._writable.unlink(p, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            this.exists(p, (readableExists) => {\n                                if (readableExists) {\n                                    this.deletePath(p);\n                                }\n                                cb(null);\n                            });\n                        });\n                    }\n                    else {\n                        // if this only exists on the readable FS, add it to the\n                        // delete map.\n                        this.deletePath(p);\n                        cb(null);\n                    }\n                });\n            });\n        }\n        unlinkSync(p) {\n            this.checkInitialized();\n            this.checkPath(p);\n            if (this.existsSync(p)) {\n                if (this._writable.existsSync(p)) {\n                    this._writable.unlinkSync(p);\n                }\n                // if it still exists add to the delete log\n                if (this.existsSync(p)) {\n                    this.deletePath(p);\n                }\n            }\n            else {\n                throw ApiError.ENOENT(p);\n            }\n        }\n        rmdir(p, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            const rmdirLower = () => {\n                this.readdir(p, (err, files) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    if (files.length) {\n                        return cb(ApiError.ENOTEMPTY(p));\n                    }\n                    this.deletePath(p);\n                    cb(null);\n                });\n            };\n            this.exists(p, (exists) => {\n                if (!exists) {\n                    return cb(ApiError.ENOENT(p));\n                }\n                this._writable.exists(p, (writableExists) => {\n                    if (writableExists) {\n                        this._writable.rmdir(p, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            this._readable.exists(p, (readableExists) => {\n                                if (readableExists) {\n                                    rmdirLower();\n                                }\n                                else {\n                                    cb();\n                                }\n                            });\n                        });\n                    }\n                    else {\n                        rmdirLower();\n                    }\n                });\n            });\n        }\n        rmdirSync(p) {\n            this.checkInitialized();\n            if (this.existsSync(p)) {\n                if (this._writable.existsSync(p)) {\n                    this._writable.rmdirSync(p);\n                }\n                if (this.existsSync(p)) {\n                    // Check if directory is empty.\n                    if (this.readdirSync(p).length > 0) {\n                        throw ApiError.ENOTEMPTY(p);\n                    }\n                    else {\n                        this.deletePath(p);\n                    }\n                }\n            }\n            else {\n                throw ApiError.ENOENT(p);\n            }\n        }\n        mkdir(p, mode, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.exists(p, (exists) => {\n                if (exists) {\n                    return cb(ApiError.EEXIST(p));\n                }\n                // The below will throw should any of the parent directories\n                // fail to exist on _writable.\n                this.createParentDirectoriesAsync(p, (err) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    this._writable.mkdir(p, mode, cb);\n                });\n            });\n        }\n        mkdirSync(p, mode) {\n            this.checkInitialized();\n            if (this.existsSync(p)) {\n                throw ApiError.EEXIST(p);\n            }\n            else {\n                // The below will throw should any of the parent directories fail to exist\n                // on _writable.\n                this.createParentDirectories(p);\n                this._writable.mkdirSync(p, mode);\n            }\n        }\n        readdir(p, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.stat(p, false, (err, dirStats) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (!dirStats.isDirectory()) {\n                    return cb(ApiError.ENOTDIR(p));\n                }\n                this._writable.readdir(p, (err, wFiles) => {\n                    if (err && err.code !== 'ENOENT') {\n                        return cb(err);\n                    }\n                    else if (err || !wFiles) {\n                        wFiles = [];\n                    }\n                    this._readable.readdir(p, (err, rFiles) => {\n                        // if the directory doesn't exist on the lower FS set rFiles\n                        // here to simplify the following code.\n                        if (err || !rFiles) {\n                            rFiles = [];\n                        }\n                        // Readdir in both, check delete log on read-only file system's files, merge, return.\n                        const seenMap = {};\n                        const filtered = wFiles.concat(rFiles.filter((fPath) => !this._deletedFiles[`${p}/${fPath}`])).filter((fPath) => {\n                            // Remove duplicates.\n                            const result = !seenMap[fPath];\n                            seenMap[fPath] = true;\n                            return result;\n                        });\n                        cb(null, filtered);\n                    });\n                });\n            });\n        }\n        readdirSync(p) {\n            this.checkInitialized();\n            const dirStats = this.statSync(p, false);\n            if (!dirStats.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n            // Readdir in both, check delete log on RO file system's listing, merge, return.\n            let contents = [];\n            try {\n                contents = contents.concat(this._writable.readdirSync(p));\n            }\n            catch (e) {\n                // NOP.\n            }\n            try {\n                contents = contents.concat(this._readable.readdirSync(p).filter((fPath) => !this._deletedFiles[`${p}/${fPath}`]));\n            }\n            catch (e) {\n                // NOP.\n            }\n            const seenMap = {};\n            return contents.filter((fileP) => {\n                const result = !seenMap[fileP];\n                seenMap[fileP] = true;\n                return result;\n            });\n        }\n        exists(p, cb) {\n            // Cannot pass an error back to callback, so throw an exception instead\n            // if not initialized.\n            this.checkInitialized();\n            this._writable.exists(p, (existsWritable) => {\n                if (existsWritable) {\n                    return cb(true);\n                }\n                this._readable.exists(p, (existsReadable) => {\n                    cb(existsReadable && this._deletedFiles[p] !== true);\n                });\n            });\n        }\n        existsSync(p) {\n            this.checkInitialized();\n            return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);\n        }\n        chmod(p, isLchmod, mode, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.operateOnWritableAsync(p, (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                else {\n                    this._writable.chmod(p, isLchmod, mode, cb);\n                }\n            });\n        }\n        chmodSync(p, isLchmod, mode) {\n            this.checkInitialized();\n            this.operateOnWritable(p, () => {\n                this._writable.chmodSync(p, isLchmod, mode);\n            });\n        }\n        chown(p, isLchmod, uid, gid, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.operateOnWritableAsync(p, (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                else {\n                    this._writable.chown(p, isLchmod, uid, gid, cb);\n                }\n            });\n        }\n        chownSync(p, isLchown, uid, gid) {\n            this.checkInitialized();\n            this.operateOnWritable(p, () => {\n                this._writable.chownSync(p, isLchown, uid, gid);\n            });\n        }\n        utimes(p, atime, mtime, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.operateOnWritableAsync(p, (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                else {\n                    this._writable.utimes(p, atime, mtime, cb);\n                }\n            });\n        }\n        utimesSync(p, atime, mtime) {\n            this.checkInitialized();\n            this.operateOnWritable(p, () => {\n                this._writable.utimesSync(p, atime, mtime);\n            });\n        }\n        deletePath(p) {\n            this._deletedFiles[p] = true;\n            this.updateLog(`d${p}\\n`);\n        }\n        updateLog(addition) {\n            this._deleteLog += addition;\n            if (this._deleteLogUpdatePending) {\n                this._deleteLogUpdateNeeded = true;\n            }\n            else {\n                this._deleteLogUpdatePending = true;\n                this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 0o644, (e) => {\n                    this._deleteLogUpdatePending = false;\n                    if (e) {\n                        this._deleteLogError = e;\n                    }\n                    else if (this._deleteLogUpdateNeeded) {\n                        this._deleteLogUpdateNeeded = false;\n                        this.updateLog('');\n                    }\n                });\n            }\n        }\n        _reparseDeletionLog() {\n            this._deletedFiles = {};\n            this._deleteLog.split('\\n').forEach((path) => {\n                // If the log entry begins w/ 'd', it's a deletion.\n                this._deletedFiles[path.slice(1)] = path.slice(0, 1) === 'd';\n            });\n        }\n        checkInitialized() {\n            if (!this._isInitialized) {\n                throw new ApiError(ErrorCode.EPERM, \"OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.\");\n            }\n            else if (this._deleteLogError !== null) {\n                const e = this._deleteLogError;\n                this._deleteLogError = null;\n                throw e;\n            }\n        }\n        checkInitAsync(cb) {\n            if (!this._isInitialized) {\n                cb(new ApiError(ErrorCode.EPERM, \"OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.\"));\n                return false;\n            }\n            else if (this._deleteLogError !== null) {\n                const e = this._deleteLogError;\n                this._deleteLogError = null;\n                cb(e);\n                return false;\n            }\n            return true;\n        }\n        checkPath(p) {\n            if (p === deletionLogPath) {\n                throw ApiError.EPERM(p);\n            }\n        }\n        checkPathAsync(p, cb) {\n            if (p === deletionLogPath) {\n                cb(ApiError.EPERM(p));\n                return true;\n            }\n            return false;\n        }\n        createParentDirectoriesAsync(p, cb) {\n            let parent = path.dirname(p);\n            const toCreate = [];\n            const self = this;\n            this._writable.stat(parent, false, statDone);\n            function statDone(err, stat) {\n                if (err) {\n                    if (parent === \"/\") {\n                        cb(new ApiError(ErrorCode.EBUSY, \"Invariant failed: root does not exist!\"));\n                    }\n                    else {\n                        toCreate.push(parent);\n                        parent = path.dirname(parent);\n                        self._writable.stat(parent, false, statDone);\n                    }\n                }\n                else {\n                    createParents();\n                }\n            }\n            function createParents() {\n                if (!toCreate.length) {\n                    return cb();\n                }\n                const dir = toCreate.pop();\n                self._readable.stat(dir, false, (err, stats) => {\n                    // stop if we couldn't read the dir\n                    if (!stats) {\n                        return cb();\n                    }\n                    self._writable.mkdir(dir, stats.mode, (err) => {\n                        if (err) {\n                            return cb(err);\n                        }\n                        createParents();\n                    });\n                });\n            }\n        }\n        /**\n         * With the given path, create the needed parent directories on the writable storage\n         * should they not exist. Use modes from the read-only storage.\n         */\n        createParentDirectories(p) {\n            let parent = path.dirname(p), toCreate = [];\n            while (!this._writable.existsSync(parent)) {\n                toCreate.push(parent);\n                parent = path.dirname(parent);\n            }\n            toCreate = toCreate.reverse();\n            toCreate.forEach((p) => {\n                this._writable.mkdirSync(p, this.statSync(p, false).mode);\n            });\n        }\n        /**\n         * Helper function:\n         * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.\n         * - Calls f to perform operation on writable.\n         */\n        operateOnWritable(p, f) {\n            if (this.existsSync(p)) {\n                if (!this._writable.existsSync(p)) {\n                    // File is on readable storage. Copy to writable storage before\n                    // changing its mode.\n                    this.copyToWritable(p);\n                }\n                f();\n            }\n            else {\n                throw ApiError.ENOENT(p);\n            }\n        }\n        operateOnWritableAsync(p, cb) {\n            this.exists(p, (exists) => {\n                if (!exists) {\n                    return cb(ApiError.ENOENT(p));\n                }\n                this._writable.exists(p, (existsWritable) => {\n                    if (existsWritable) {\n                        cb();\n                    }\n                    else {\n                        return this.copyToWritableAsync(p, cb);\n                    }\n                });\n            });\n        }\n        /**\n         * Copy from readable to writable storage.\n         * PRECONDITION: File does not exist on writable storage.\n         */\n        copyToWritable(p) {\n            const pStats = this.statSync(p, false);\n            if (pStats.isDirectory()) {\n                this._writable.mkdirSync(p, pStats.mode);\n            }\n            else {\n                this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);\n            }\n        }\n        copyToWritableAsync(p, cb) {\n            this.stat(p, false, (err, pStats) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (pStats.isDirectory()) {\n                    return this._writable.mkdir(p, pStats.mode, cb);\n                }\n                // need to copy file.\n                this._readable.readFile(p, null, getFlag('r'), (err, data) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    this.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);\n                });\n            });\n        }\n    }\n    /**\n     * OverlayFS makes a read-only filesystem writable by storing writes on a second,\n     * writable file system. Deletes are persisted via metadata stored on the writable\n     * file system.\n     */\n    class OverlayFS extends LockedFS {\n        /**\n         * @param writable The file system to write modified files to.\n         * @param readable The file system that initially populates this file system.\n         */\n        constructor(writable, readable) {\n            super(new UnlockedOverlayFS(writable, readable));\n        }\n        /**\n         * Constructs and initializes an OverlayFS instance with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                const fs = new OverlayFS(opts.writable, opts.readable);\n                fs._initialize((e) => {\n                    cb(e, fs);\n                });\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() {\n            return UnlockedOverlayFS.isAvailable();\n        }\n        getOverlayedFileSystems() {\n            return super.getFSUnlocked().getOverlayedFileSystems();\n        }\n        unwrap() {\n            return super.getFSUnlocked();\n        }\n        _initialize(cb) {\n            super.getFSUnlocked()._initialize(cb);\n        }\n    }\n    OverlayFS.Name = \"OverlayFS\";\n    OverlayFS.Options = {\n        writable: {\n            type: \"object\",\n            description: \"The file system to write modified files to.\"\n        },\n        readable: {\n            type: \"object\",\n            description: \"The file system that initially populates this file system.\"\n        }\n    };\n\n    return OverlayFS;\n});"]}