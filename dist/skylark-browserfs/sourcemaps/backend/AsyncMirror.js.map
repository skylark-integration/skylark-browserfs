{"version":3,"sources":["backend/AsyncMirror.js"],"names":["define","file_system","api_error","file_flag","preload_file","path","SynchronousFileSystem","ApiError","ErrorCode","FileFlag","PreloadFile","MirrorFile","[object Object]","fs","flag","stat","data","super","this","isDirty","_fs","_syncSync","resetDirty","syncSync","AsyncMirror","sync","async","_queue","_queueRunning","_isInitialized","_initializeCallbacks","_sync","_async","opts","cb","_initialize","e","Name","fd","writeFileSync","getPath","getBuffer","getFileFlag","getStats","mode","enqueueOp","apiMethod","arguments","getFlag","supportsProps","oldPath","newPath","renameSync","p","isLstat","statSync","openSync","closeSync","readFileSync","unlinkSync","rmdirSync","mkdirSync","readdirSync","existsSync","isLchmod","chmodSync","isLchown","uid","gid","chownSync","atime","mtime","utimesSync","userCb","callbacks","end","forEach","push","copyDirectory","readdir","err","files","i","copyNextFile","length","copyItem","join","copyFile","readFile","stats","isDirectory","op","doNextOp","Error","shift","args","apply","Options","type","description","validator","v","supportsSynch","EINVAL"],"mappings":"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","file":"../../backend/AsyncMirror.js","sourcesContent":["define([\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../generic/preload_file',\n    '../libs/path'\n], function (file_system, api_error, file_flag, preload_file, path) {\n    'use strict';\n\n\n    const  { SynchronousFileSystem } = file_system;\n    const { ApiError, ErrorCode } = api_error;\n    const { FileFlag } = file_flag;\n    const { PreloadFile} = preload_file;\n\n    /**\n     * We define our own file to interpose on syncSync() for mirroring purposes.\n     */\n    class MirrorFile extends PreloadFile {\n        constructor(fs, path, flag, stat, data) {\n            super(fs, path, flag, stat, data);\n        }\n        syncSync() {\n            if (this.isDirty()) {\n                this._fs._syncSync(this);\n                this.resetDirty();\n            }\n        }\n        closeSync() {\n            this.syncSync();\n        }\n    }\n    /**\n     * AsyncMirrorFS mirrors a synchronous filesystem into an asynchronous filesystem\n     * by:\n     *\n     * * Performing operations over the in-memory copy, while asynchronously pipelining them\n     *   to the backing store.\n     * * During application loading, the contents of the async file system can be reloaded into\n     *   the synchronous store, if desired.\n     *\n     * The two stores will be kept in sync. The most common use-case is to pair a synchronous\n     * in-memory filesystem with an asynchronous backing store.\n     *\n     * Example: Mirroring an IndexedDB file system to an in memory file system. Now, you can use\n     * IndexedDB synchronously.\n     *\n     * ```javascript\n     * BrowserFS.configure({\n     *   fs: \"AsyncMirror\",\n     *   options: {\n     *     sync: { fs: \"InMemory\" },\n     *     async: { fs: \"IndexedDB\" }\n     *   }\n     * }, function(e) {\n     *   // BrowserFS is initialized and ready-to-use!\n     * });\n     * ```\n     *\n     * Or, alternatively:\n     *\n     * ```javascript\n     * BrowserFS.FileSystem.IndexedDB.Create(function(e, idbfs) {\n     *   BrowserFS.FileSystem.InMemory.Create(function(e, inMemory) {\n     *     BrowserFS.FileSystem.AsyncMirror({\n     *       sync: inMemory, async: idbfs\n     *     }, function(e, mirrored) {\n     *       BrowserFS.initialize(mirrored);\n     *     });\n     *   });\n     * });\n     * ```\n     */\n    class AsyncMirror extends SynchronousFileSystem {\n        /**\n         * **Deprecated; use AsyncMirror.Create() method instead.**\n         *\n         * Mirrors the synchronous file system into the asynchronous file system.\n         *\n         * **IMPORTANT**: You must call `initialize` on the file system before it can be used.\n         * @param sync The synchronous file system to mirror the asynchronous file system to.\n         * @param async The asynchronous file system to mirror.\n         */\n        constructor(sync, async) {\n            super();\n            /**\n             * Queue of pending asynchronous operations.\n             */\n            this._queue = [];\n            this._queueRunning = false;\n            this._isInitialized = false;\n            this._initializeCallbacks = [];\n            this._sync = sync;\n            this._async = async;\n        }\n        /**\n         * Constructs and initializes an AsyncMirror file system with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                const fs = new AsyncMirror(opts.sync, opts.async);\n                fs._initialize((e) => {\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        cb(null, fs);\n                    }\n                });\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() {\n            return true;\n        }\n        getName() {\n            return AsyncMirror.Name;\n        }\n        _syncSync(fd) {\n            this._sync.writeFileSync(fd.getPath(), fd.getBuffer(), null, FileFlag.getFileFlag('w'), fd.getStats().mode);\n            this.enqueueOp({\n                apiMethod: 'writeFile',\n                arguments: [fd.getPath(), fd.getBuffer(), null, fd.getFlag(), fd.getStats().mode]\n            });\n        }\n        isReadOnly() { return false; }\n        supportsSynch() { return true; }\n        supportsLinks() { return false; }\n        supportsProps() { return this._sync.supportsProps() && this._async.supportsProps(); }\n        renameSync(oldPath, newPath) {\n            this._sync.renameSync(oldPath, newPath);\n            this.enqueueOp({\n                apiMethod: 'rename',\n                arguments: [oldPath, newPath]\n            });\n        }\n        statSync(p, isLstat) {\n            return this._sync.statSync(p, isLstat);\n        }\n        openSync(p, flag, mode) {\n            // Sanity check: Is this open/close permitted?\n            const fd = this._sync.openSync(p, flag, mode);\n            fd.closeSync();\n            return new MirrorFile(this, p, flag, this._sync.statSync(p, false), this._sync.readFileSync(p, null, FileFlag.getFileFlag('r')));\n        }\n        unlinkSync(p) {\n            this._sync.unlinkSync(p);\n            this.enqueueOp({\n                apiMethod: 'unlink',\n                arguments: [p]\n            });\n        }\n        rmdirSync(p) {\n            this._sync.rmdirSync(p);\n            this.enqueueOp({\n                apiMethod: 'rmdir',\n                arguments: [p]\n            });\n        }\n        mkdirSync(p, mode) {\n            this._sync.mkdirSync(p, mode);\n            this.enqueueOp({\n                apiMethod: 'mkdir',\n                arguments: [p, mode]\n            });\n        }\n        readdirSync(p) {\n            return this._sync.readdirSync(p);\n        }\n        existsSync(p) {\n            return this._sync.existsSync(p);\n        }\n        chmodSync(p, isLchmod, mode) {\n            this._sync.chmodSync(p, isLchmod, mode);\n            this.enqueueOp({\n                apiMethod: 'chmod',\n                arguments: [p, isLchmod, mode]\n            });\n        }\n        chownSync(p, isLchown, uid, gid) {\n            this._sync.chownSync(p, isLchown, uid, gid);\n            this.enqueueOp({\n                apiMethod: 'chown',\n                arguments: [p, isLchown, uid, gid]\n            });\n        }\n        utimesSync(p, atime, mtime) {\n            this._sync.utimesSync(p, atime, mtime);\n            this.enqueueOp({\n                apiMethod: 'utimes',\n                arguments: [p, atime, mtime]\n            });\n        }\n        /**\n         * Called once to load up files from async storage into sync storage.\n         */\n        _initialize(userCb) {\n            const callbacks = this._initializeCallbacks;\n            const end = (e) => {\n                this._isInitialized = !e;\n                this._initializeCallbacks = [];\n                callbacks.forEach((cb) => cb(e));\n            };\n            if (!this._isInitialized) {\n                // First call triggers initialization, the rest wait.\n                if (callbacks.push(userCb) === 1) {\n                    const copyDirectory = (p, mode, cb) => {\n                        if (p !== '/') {\n                            this._sync.mkdirSync(p, mode);\n                        }\n                        this._async.readdir(p, (err, files) => {\n                            let i = 0;\n                            // NOTE: This function must not be in a lexically nested statement,\n                            // such as an if or while statement. Safari refuses to run the\n                            // script since it is undefined behavior.\n                            function copyNextFile(err) {\n                                if (err) {\n                                    cb(err);\n                                }\n                                else if (i < files.length) {\n                                    copyItem(path.join(p, files[i]), copyNextFile);\n                                    i++;\n                                }\n                                else {\n                                    cb();\n                                }\n                            }\n                            if (err) {\n                                cb(err);\n                            }\n                            else {\n                                copyNextFile();\n                            }\n                        });\n                    }, copyFile = (p, mode, cb) => {\n                        this._async.readFile(p, null, FileFlag.getFileFlag('r'), (err, data) => {\n                            if (err) {\n                                cb(err);\n                            }\n                            else {\n                                try {\n                                    this._sync.writeFileSync(p, data, null, FileFlag.getFileFlag('w'), mode);\n                                }\n                                catch (e) {\n                                    err = e;\n                                }\n                                finally {\n                                    cb(err);\n                                }\n                            }\n                        });\n                    }, copyItem = (p, cb) => {\n                        this._async.stat(p, false, (err, stats) => {\n                            if (err) {\n                                cb(err);\n                            }\n                            else if (stats.isDirectory()) {\n                                copyDirectory(p, stats.mode, cb);\n                            }\n                            else {\n                                copyFile(p, stats.mode, cb);\n                            }\n                        });\n                    };\n                    copyDirectory('/', 0, end);\n                }\n            }\n            else {\n                userCb();\n            }\n        }\n        enqueueOp(op) {\n            this._queue.push(op);\n            if (!this._queueRunning) {\n                this._queueRunning = true;\n                const doNextOp = (err) => {\n                    if (err) {\n                        throw new Error(`WARNING: File system has desynchronized. Received following error: ${err}\\n$`);\n                    }\n                    if (this._queue.length > 0) {\n                        const op = this._queue.shift(), args = op.arguments;\n                        args.push(doNextOp);\n                        this._async[op.apiMethod].apply(this._async, args);\n                    }\n                    else {\n                        this._queueRunning = false;\n                    }\n                };\n                doNextOp();\n            }\n        }\n    }\n    AsyncMirror.Name = \"AsyncMirror\";\n    AsyncMirror.Options = {\n        sync: {\n            type: \"object\",\n            description: \"The synchronous file system to mirror the asynchronous file system to.\",\n            validator: (v, cb) => {\n                if (v && typeof (v['supportsSynch']) === \"function\" && v.supportsSynch()) {\n                    cb();\n                }\n                else {\n                    cb(new ApiError(ErrorCode.EINVAL, `'sync' option must be a file system that supports synchronous operations`));\n                }\n            }\n        },\n        async: {\n            type: \"object\",\n            description: \"The asynchronous file system to mirror.\"\n        }\n    };\n\n    return AsyncMirror;\n});"]}