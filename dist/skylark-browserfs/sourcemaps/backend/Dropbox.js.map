{"version":3,"sources":["backend/Dropbox.js"],"names":["define","buffers","preload_file","file_system","node_fs_stats","api_error","util","setImmediate","path","BaseFileSystem","Stats","FileType","ApiError","ErrorCode","arrayBuffer2Buffer","buffer2ArrayBuffer","dirname","PreloadFile","Buffer","FixPath","p","ExtractTheFuckingError","e","obj","error","obj2","reason","JSON","parse","GetErrorMessage","err","user_message","text","error_summary","Error","stringify","LookupErrorToError","msg","EBADF","ENOENT","EISDIR","ENOTDIR","EPERM","EIO","WriteErrorToError","ENOSPC","FilesDeleteWrapped","client","cb","arg","filesDeleteV2","then","catch","path_lookup","path_write","setTimeout","Math","random","DropboxFile","[object Object]","_fs","_path","_flag","_stat","contents","super","this","_syncFile","getPath","getBuffer","sync","DropboxFileSystem","_client","opts","Dropbox","Name","mainCb","readdir","paths","next","length","shift","oldPath","newPath","stat","stats","rename","relocationArg","from_path","to_path","filesMoveV2","from_lookup","from_write","to","isDirectory","unlink","isLstat","DIRECTORY","filesGetMetadata","ref","fileMetadata","FILE","size","flags","downloadArg","filesDownload","res","b","fileBlob","fr","FileReader","onload","ab","result","byteLength","readAsArrayBuffer","mode","fileData","alloc","commitInfo","Blob","type","filesUpload","metadata","createFile","ENOTEMPTY","parent","filesCreateFolderV2","mkdir","filesListFolder","ContinueReadingDir","previousEntries","newEntries","entries","map","path_display","filter","concat","has_more","cursor","filesListFolderContinue","ProcessListFolderError","d",".tag","Options","description"],"mappings":";;;;;;;AAAAA,QACI,kBACA,0BACA,sBACA,wBACA,oBACA,eAEA,0BACA,gBACD,SAAUC,EAAQC,EAAcC,EAAaC,EAAeC,EAAWC,EAAOC,EAAcC,GAC3F,aAEA,MAAMC,eAAEA,GAAmBN,GACrBO,MAAEA,EAAKC,SAAEA,GAAaP,GACtBQ,SAAEA,EAAQC,UAAEA,GAAcR,GAC1BS,mBAAEA,EAAkBC,mBAAEA,GAAwBT,GAE9CU,QAAEA,GAAaR,GAEfS,YAAEA,GAAef,GAEjBgB,OAACA,GAAUjB,EAQjB,SAASkB,EAAQC,GACb,MAAU,MAANA,EACO,GAGAA,EAQf,SAASC,EAAuBC,GAC5B,MAAMC,EAAMD,EAAEE,MACd,GAAID,EAAI,QAEJ,OAAOA,EAEN,GAAIA,EAAW,MAAG,CAEnB,MAAME,EAAOF,EAAIC,MACjB,OAAIC,EAAK,QACEA,EAEFA,EAAa,QAAKA,EAAa,OAAE,QAC/BA,EAAKC,OAGLD,EAGV,GAAqB,iBAAV,EAEZ,IACI,MAAMA,EAAOE,KAAKC,MAAML,GACxB,GAAIE,EAAY,OAAKA,EAAY,MAAU,QAAKA,EAAY,MAAU,OAAE,QACpE,OAAOA,EAAKD,MAAME,OAG1B,MAAOJ,IAIX,OAAOC,EAYX,SAASM,EAAgBC,GACrB,GAAIA,EAAkB,aAClB,OAAOA,EAAIC,aAAaC,KAEvB,GAAIF,EAAmB,cACxB,OAAOA,EAAIG,cAEV,GAA2B,iBAAfH,EAAS,MACtB,OAAOA,EAAIN,MAEV,GAA2B,iBAAfM,EAAS,MAEtB,OAAOD,EAAgBC,EAAIN,OAG3B,MAAM,IAAIU,4DAA4DP,KAAKQ,UAAUL,MAG7F,SAASM,EAAmBN,EAAKV,EAAGiB,GAChC,OAAQP,EAAI,SACR,IAAK,iBACD,OAAO,IAAIlB,EAASC,EAAUyB,MAAOD,EAAKjB,GAC9C,IAAK,YACD,OAAOR,EAAS2B,OAAOnB,GAC3B,IAAK,WACD,OAAOR,EAAS4B,OAAOpB,GAC3B,IAAK,aACD,OAAOR,EAAS6B,QAAQrB,GAC5B,IAAK,qBACD,OAAOR,EAAS8B,MAAMtB,GAC1B,IAAK,QACL,QACI,OAAO,IAAIR,EAASC,EAAU8B,IAAKN,EAAKjB,IAGpD,SAASwB,EAAkBd,EAAKV,EAAGiB,GAC/B,OAAQP,EAAI,SACR,IAAK,iBACL,IAAK,kBACD,OAAO,IAAIlB,EAASC,EAAUyB,MAAOD,EAAKjB,GAC9C,IAAK,WACL,IAAK,sBACL,IAAK,cACD,OAAOR,EAAS8B,MAAMtB,GAC1B,IAAK,qBACD,OAAO,IAAIR,EAASC,EAAUgC,OAAQR,GAC1C,IAAK,QACL,QACI,OAAO,IAAIzB,EAASC,EAAU8B,IAAKN,EAAKjB,IAGpD,SAAS0B,EAAmBC,EAAQ3B,EAAG4B,GACnC,MAAMC,GACFzC,KAAMW,EAAQC,IAElB2B,EAAOG,cAAcD,GAChBE,KAAK,KACNH,MACDI,MAAO9B,IACN,MAAMQ,EAAMT,EAAuBC,GACnC,OAAQQ,EAAI,SACR,IAAK,cACDkB,EAAGZ,EAAmBN,EAAIuB,YAAajC,EAAGS,EAAgBP,KAC1D,MACJ,IAAK,aACD0B,EAAGJ,EAAkBd,EAAIwB,WAAYlC,EAAGS,EAAgBP,KACxD,MACJ,IAAK,4BACDiC,WAAW,IAAMT,EAAmBC,EAAQ3B,EAAG4B,GAAK,IAAO,IAAOQ,KAAKC,UACvE,MACJ,IAAK,QACL,QACIT,EAAG,IAAIpC,EAASC,EAAU8B,IAAKd,EAAgBP,GAAIF,aAK7DsC,UAAoBzC,EACtB0C,YAAYC,EAAKC,EAAOC,EAAOC,EAAOC,GAClCC,MAAML,EAAKC,EAAOC,EAAOC,EAAOC,GAEpCL,KAAKX,GACDkB,KAAKN,IAAIO,UAAUD,KAAKE,UAAWF,KAAKG,YAAarB,GAEzDW,MAAMX,GACFkB,KAAKI,KAAKtB,UAQZuB,UAA0B9D,EAC5BkD,YAAYZ,GACRkB,QACAC,KAAKM,QAAUzB,EAMnBY,cAAcc,EAAMzB,GAChBA,EAAG,KAAM,IAAIuB,EAAkBE,EAAK1B,SAExCY,qBAEI,MAA0B,oBAAZe,QAElBf,UACI,OAAOY,EAAkBI,KAE7BhB,aACI,OAAO,EAIXA,mBACI,OAAO,EAEXA,gBACI,OAAO,EAEXA,gBACI,OAAO,EAMXA,MAAMiB,GACFV,KAAKW,QAAQ,IAAK,CAACvD,EAAGwD,KAClB,GAAIA,EAAO,CACP,MAAMC,EAAQzD,IACW,IAAjBwD,EAAME,OACNJ,IAGA9B,EAAmBoB,KAAKM,QAASM,EAAMG,QAASF,IAGxDA,SAGAH,EAAOtD,KAInBqC,OAAOuB,EAASC,EAASnC,GAGrBkB,KAAKkB,KAAKD,GAAS,EAAO,CAAC7D,EAAG+D,KAC1B,MAAMC,EAAS,KACX,MAAMC,GACFC,UAAWrE,EAAQ+D,GACnBO,QAAStE,EAAQgE,IAErBjB,KAAKM,QAAQkB,YAAYH,GACpBpC,KAAK,IAAMH,KACXI,MAAM,SAAU9B,GACjB,MAAMQ,EAAMT,EAAuBC,GACnC,OAAQQ,EAAI,SACR,IAAK,cACDkB,EAAGZ,EAAmBN,EAAI6D,YAAaT,EAASrD,EAAgBP,KAChE,MACJ,IAAK,aACD0B,EAAGJ,EAAkBd,EAAI8D,WAAYV,EAASrD,EAAgBP,KAC9D,MACJ,IAAK,KACD0B,EAAGJ,EAAkBd,EAAI+D,GAAIV,EAAStD,EAAgBP,KACtD,MACJ,IAAK,0BACL,IAAK,0BACD0B,EAAG,IAAIpC,EAASC,EAAU6B,MAAOb,EAAgBP,GAAI4D,IACrD,MACJ,IAAK,+BACL,IAAK,6BACDlC,EAAG,IAAIpC,EAASC,EAAUyB,MAAOT,EAAgBP,GAAI4D,IACrD,MACJ,IAAK,iBACDlC,EAAG,IAAIpC,EAASC,EAAUgC,OAAQhB,EAAgBP,GAAI4D,IACtD,MACJ,IAAK,QACL,QACIlC,EAAG,IAAIpC,EAASC,EAAU8B,IAAKd,EAAgBP,GAAI4D,QAK/D5D,EAEAgE,IAEKJ,IAAYC,EAEb7D,EACA0B,EAAGpC,EAAS2B,OAAO4C,IAGnBnC,IAGCqC,GAASA,EAAMS,cAEpB9C,EAAGpC,EAAS4B,OAAO2C,IAInBjB,KAAK6B,OAAOZ,EAAU7D,IACdA,EACA0B,EAAG1B,GAGHgE,QAMpB3B,KAAKnD,EAAMwF,EAAShD,GAChB,GAAa,MAATxC,EAKA,YAHAD,EAAa,WACTyC,EAAG,KAAM,IAAItC,EAAMC,EAASsF,UAAW,SAI/C,MAAMhD,GACFzC,KAAMW,EAAQX,IAElB0D,KAAKM,QAAQ0B,iBAAiBjD,GAAKE,KAAMgD,IACrC,OAAQA,EAAI,SACR,IAAK,OACD,MAAMC,EAAeD,EAErBnD,EAAG,KAAM,IAAItC,EAAMC,EAAS0F,KAAMD,EAAaE,OAC/C,MACJ,IAAK,SACDtD,EAAG,KAAM,IAAItC,EAAMC,EAASsF,UAAW,OACvC,MACJ,IAAK,UACDjD,EAAGpC,EAAS2B,OAAO/B,OAM5B4C,MAAO9B,IACN,MAAMQ,EAAMT,EAAuBC,GACnC,OAAQQ,EAAI,SACR,IAAK,OACDkB,EAAGZ,EAAmBN,EAAItB,KAAMA,EAAMqB,EAAgBP,KACtD,MACJ,QACI0B,EAAG,IAAIpC,EAASC,EAAU8B,IAAKd,EAAgBP,GAAId,OAKnEmD,SAASnD,EAAM+F,EAAOvD,GAClB,MAAMwD,GACFhG,KAAMW,EAAQX,IAElB0D,KAAKM,QAAQiC,cAAcD,GAAarD,KAAMuD,IAC1C,MAAMC,EAAID,EAAIE,SACRC,EAAK,IAAIC,WACfD,EAAGE,OAAS,MACR,MAAMC,EAAKH,EAAGI,OACdjE,EAAG,KAAM,IAAIU,EAAYQ,KAAM1D,EAAM+F,EAAO,IAAI7F,EAAMC,EAAS0F,KAAMW,EAAGE,YAAapG,EAAmBkG,OAE5GH,EAAGM,kBAAkBR,KACtBvD,MAAO9B,IACN,MAAMQ,EAAMT,EAAuBC,GACnC,OAAQQ,EAAI,SACR,IAAK,OAEDkB,EAAGZ,EADaN,EACctB,KAAMA,EAAMqB,EAAgBP,KAC1D,MACJ,IAAK,QACL,QACI0B,EAAG,IAAIpC,EAASC,EAAU8B,IAAKd,EAAgBP,GAAId,OAKnEmD,WAAWvC,EAAGmF,EAAOa,EAAMpE,GACvB,MAAMqE,EAAWnG,EAAOoG,MAAM,GAExBC,GACFvD,SAFS,IAAIwD,MAAMzG,EAAmBsG,KAAcI,KAAM,iBAG1DjH,KAAMW,EAAQC,IAElB8C,KAAKM,QAAQkD,YAAYH,GAAYpE,KAAMwE,IACvC3E,EAAG,KAAM,IAAIU,EAAYQ,KAAM9C,EAAGmF,EAAO,IAAI7F,EAAMC,EAAS0F,KAAM,GAAIgB,MACvEjE,MAAO9B,IACN,MAAMQ,EAAMT,EAAuBC,GAEnC,OAAQQ,EAAI,SACR,IAAK,OAEDkB,EAAGJ,EADad,EACatB,KAAKkB,OAAQN,EAAGS,EAAgBP,KAC7D,MACJ,IAAK,4BAEDiC,WAAW,IAAMW,KAAK0D,WAAWxG,EAAGmF,EAAOa,EAAMpE,GAAK,IAAO,IAAOQ,KAAKC,UACzE,MACJ,IAAK,QACL,QACIT,EAAG,IAAIpC,EAASC,EAAU8B,IAAKd,EAAgBP,GAAIF,OAQnEuC,OAAOnD,EAAMwC,GAETkB,KAAKkB,KAAK5E,GAAM,EAAO,CAACc,EAAG8D,KACnBA,EACIA,EAAKU,cACL9C,EAAGpC,EAAS4B,OAAOhC,IAGnBsC,EAAmBoB,KAAKM,QAAShE,EAAMwC,GAI3CA,EAAG1B,KAOfqC,MAAMnD,EAAMwC,GACRkB,KAAKW,QAAQrE,EAAM,CAACc,EAAGwD,KACfA,EACIA,EAAME,OAAS,EACfhC,EAAGpC,EAASiH,UAAUrH,IAGtBsC,EAAmBoB,KAAKM,QAAShE,EAAMwC,GAI3CA,EAAG1B,KAOfqC,MAAMvC,EAAGgG,EAAMpE,GAEX,MAAM8E,EAAS9G,EAAQI,GACvB8C,KAAKkB,KAAK0C,GAAQ,EAAO,CAACxG,EAAG+D,KACzB,GAAI/D,EACA0B,EAAG1B,QAEF,GAAI+D,IAAUA,EAAMS,cACrB9C,EAAGpC,EAAS6B,QAAQqF,QAEnB,CACD,MAAM7E,GACFzC,KAAMW,EAAQC,IAElB8C,KAAKM,QAAQuD,oBAAoB9E,GAAKE,KAAK,IAAMH,KAAMI,MAAO9B,IAEtC,8BADRD,EAAuBC,GAC3B,QAEJiC,WAAW,IAAMW,KAAK8D,MAAM5G,EAAGgG,EAAMpE,GAAK,IAAO,IAAOQ,KAAKC,UAG7DT,EAAGJ,EAAkBvB,EAAuBC,GAAGd,KAAMY,EAAGS,EAAgBP,UAS5FqC,QAAQnD,EAAMwC,GACV,MAAMC,GACFzC,KAAMW,EAAQX,IAElB0D,KAAKM,QAAQyD,gBAAgBhF,GAAKE,KAAMuD,KA0DhD,SAASwB,EAAmBnF,EAAQvC,EAAMkG,EAAKyB,EAAiBnF,GAC5D,MAAMoF,EAAa1B,EAAI2B,QAAQC,IAAKhH,GAAMA,EAAEiH,cAAcC,OAAQpH,KAAQA,GAC1E,MAAMiH,EAAUF,EAAgBM,OAAOL,GACvC,GAAK1B,EAAIgC,SAGJ,CACD,MAAMzF,GACF0F,OAAQjC,EAAIiC,QAEhB5F,EAAO6F,wBAAwB3F,GAAKE,KAAMuD,IACtCwB,EAAmBnF,EAAQvC,EAAMkG,EAAK2B,EAASrF,KAChDI,MAAO9B,IACNuH,EAAuBvH,EAAGd,EAAMwC,UATpCA,EAAG,KAAMqF,GA7DLH,CAAmBhE,KAAKM,QAAShE,EAAMkG,KAAS1D,KACjDI,MAAO9B,IACNuH,EAAuBvH,EAAGd,EAAMwC,KAMxCW,UAAUvC,EAAG0H,EAAG9F,GACZ,MACMC,GACFe,SAFS,IAAIwD,MAAMzG,EAAmB+H,KAAOrB,KAAM,iBAGnDjH,KAAMW,EAAQC,GACdgG,MACI2B,OAAQ,cAGhB7E,KAAKM,QAAQkD,YAAYzE,GAAKE,KAAK,KAC/BH,MACDI,MAAO9B,IACN,MAAMQ,EAAMT,EAAuBC,GACnC,OAAQQ,EAAI,SACR,IAAK,OAEDkB,EAAGJ,EADad,EACatB,KAAKkB,OAAQN,EAAGS,EAAgBP,KAC7D,MACJ,IAAK,4BACDiC,WAAW,IAAMW,KAAKC,UAAU/C,EAAG0H,EAAG9F,GAAK,IAAO,IAAOQ,KAAKC,UAC9D,MACJ,IAAK,QACL,QACIT,EAAG,IAAIpC,EAASC,EAAU8B,IAAKd,EAAgBP,GAAIF,QAavE,SAASyH,EAAuBvH,EAAGd,EAAMwC,GACrC,MAAMlB,EAAMT,EAAuBC,GACnC,OAAQQ,EAAI,SACR,IAAK,OAEDkB,EAAGZ,EADeN,EACctB,KAAMA,EAAMqB,EAAgBP,KAC5D,MACJ,IAAK,QACL,QACI0B,EAAG,IAAIpC,EAASC,EAAU8B,IAAKd,EAAgBP,GAAId,KAwB/D,OAxCA+D,EAAkBI,KAAO,YACzBJ,EAAkByE,SACdjG,QACI0E,KAAM,SACNwB,YAAa,sEAkCrB1E,EAAkBb,YAAcA,EAExBa","file":"../../backend/Dropbox.js","sourcesContent":["define([\n    '../libs/buffers',\n    '../generic/preload_file',\n    '../core/file_system',\n    '../core/node_fs_stats',\n    '../core/api_error',\n    '../core/util',\n///    'dropbox_bridge',\n    '../generic/setImmediate',\n    '../libs/path'\n], function (buffers,preload_file, file_system, node_fs_stats, api_error, util,  setImmediate, path) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { Stats, FileType } = node_fs_stats;\n    const { ApiError, ErrorCode } = api_error;\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer } =  util;\n///    const { Dropbox } =  dropbox_bridge;\n    const { dirname } =  path;\n\n    const { PreloadFile} = preload_file;\n\n    const {Buffer} = buffers;\n\n\n    /**\n     * Dropbox paths do not begin with a /, they just begin with a folder at the root node.\n     * Here, we strip the `/`.\n     * @param p An absolute path\n     */\n    function FixPath(p) {\n        if (p === '/') {\n            return '';\n        }\n        else {\n            return p;\n        }\n    }\n    /**\n     * HACK: Dropbox errors are FUBAR'd sometimes.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @param e\n     */\n    function ExtractTheFuckingError(e) {\n        const obj = e.error;\n        if (obj['.tag']) {\n            // Everything is OK.\n            return obj;\n        }\n        else if (obj['error']) {\n            // Terrible nested object bug.\n            const obj2 = obj.error;\n            if (obj2['.tag']) {\n                return obj2;\n            }\n            else if (obj2['reason'] && obj2['reason']['.tag']) {\n                return obj2.reason;\n            }\n            else {\n                return obj2;\n            }\n        }\n        else if (typeof (obj) === 'string') {\n            // Might be a fucking JSON object error.\n            try {\n                const obj2 = JSON.parse(obj);\n                if (obj2['error'] && obj2['error']['reason'] && obj2['error']['reason']['.tag']) {\n                    return obj2.error.reason;\n                }\n            }\n            catch (e) {\n                // Nope. Give up.\n            }\n        }\n        return obj;\n    }\n    /**\n     * Returns a user-facing error message given an error.\n     *\n     * HACK: Dropbox error messages sometimes lack a `user_message` field.\n     * Sometimes, they are even strings. Ugh.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/145\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/144\n     * @param err An error.\n     */\n    function GetErrorMessage(err) {\n        if (err['user_message']) {\n            return err.user_message.text;\n        }\n        else if (err['error_summary']) {\n            return err.error_summary;\n        }\n        else if (typeof (err.error) === \"string\") {\n            return err.error;\n        }\n        else if (typeof (err.error) === \"object\") {\n            // DROPBOX BUG: Sometimes, error is a nested error.\n            return GetErrorMessage(err.error);\n        }\n        else {\n            throw new Error(`Dropbox's servers gave us a garbage error message: ${JSON.stringify(err)}`);\n        }\n    }\n    function LookupErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n                return new ApiError(ErrorCode.EBADF, msg, p);\n            case 'not_found':\n                return ApiError.ENOENT(p);\n            case 'not_file':\n                return ApiError.EISDIR(p);\n            case 'not_folder':\n                return ApiError.ENOTDIR(p);\n            case 'restricted_content':\n                return ApiError.EPERM(p);\n            case 'other':\n            default:\n                return new ApiError(ErrorCode.EIO, msg, p);\n        }\n    }\n    function WriteErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n            case 'disallowed_name':\n                return new ApiError(ErrorCode.EBADF, msg, p);\n            case 'conflict':\n            case 'no_write_permission':\n            case 'team_folder':\n                return ApiError.EPERM(p);\n            case 'insufficient_space':\n                return new ApiError(ErrorCode.ENOSPC, msg);\n            case 'other':\n            default:\n                return new ApiError(ErrorCode.EIO, msg, p);\n        }\n    }\n    function FilesDeleteWrapped(client, p, cb) {\n        const arg = {\n            path: FixPath(p)\n        };\n        client.filesDeleteV2(arg)\n            .then(() => {\n            cb();\n        }).catch((e) => {\n            const err = ExtractTheFuckingError(e);\n            switch (err['.tag']) {\n                case 'path_lookup':\n                    cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));\n                    break;\n                case 'path_write':\n                    cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));\n                    break;\n                case 'too_many_write_operations':\n                    setTimeout(() => FilesDeleteWrapped(client, p, cb), 500 + (300 * (Math.random())));\n                    break;\n                case 'other':\n                default:\n                    cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));\n                    break;\n            }\n        });\n    }\n    class DropboxFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        sync(cb) {\n            this._fs._syncFile(this.getPath(), this.getBuffer(), cb);\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n    }\n    /**\n     * A read/write file system backed by Dropbox cloud storage.\n     *\n     * Uses the Dropbox V2 API, and the 2.x JS SDK.\n     */\n    class DropboxFileSystem extends BaseFileSystem {\n        constructor(client) {\n            super();\n            this._client = client;\n        }\n        /**\n         * Creates a new DropboxFileSystem instance with the given options.\n         * Must be given an *authenticated* Dropbox client from 2.x JS SDK.\n         */\n        static Create(opts, cb) {\n            cb(null, new DropboxFileSystem(opts.client));\n        }\n        static isAvailable() {\n            // Checks if the Dropbox library is loaded.\n            return typeof Dropbox !== 'undefined';\n        }\n        getName() {\n            return DropboxFileSystem.Name;\n        }\n        isReadOnly() {\n            return false;\n        }\n        // Dropbox doesn't support symlinks, properties, or synchronous calls\n        // TODO: does it???\n        supportsSymlinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return false;\n        }\n        /**\n         * Deletes *everything* in the file system. Mainly intended for unit testing!\n         * @param mainCb Called when operation completes.\n         */\n        empty(mainCb) {\n            this.readdir('/', (e, paths) => {\n                if (paths) {\n                    const next = (e) => {\n                        if (paths.length === 0) {\n                            mainCb();\n                        }\n                        else {\n                            FilesDeleteWrapped(this._client, paths.shift(), next);\n                        }\n                    };\n                    next();\n                }\n                else {\n                    mainCb(e);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            // Dropbox doesn't let you rename things over existing things, but POSIX does.\n            // So, we need to see if newPath exists...\n            this.stat(newPath, false, (e, stats) => {\n                const rename = () => {\n                    const relocationArg = {\n                        from_path: FixPath(oldPath),\n                        to_path: FixPath(newPath)\n                    };\n                    this._client.filesMoveV2(relocationArg)\n                        .then(() => cb())\n                        .catch(function (e) {\n                        const err = ExtractTheFuckingError(e);\n                        switch (err['.tag']) {\n                            case 'from_lookup':\n                                cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'from_write':\n                                cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'to':\n                                cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));\n                                break;\n                            case 'cant_copy_shared_folder':\n                            case 'cant_nest_shared_folder':\n                                cb(new ApiError(ErrorCode.EPERM, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'cant_move_folder_into_itself':\n                            case 'duplicated_or_nested_paths':\n                                cb(new ApiError(ErrorCode.EBADF, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'too_many_files':\n                                cb(new ApiError(ErrorCode.ENOSPC, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'other':\n                            default:\n                                cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), oldPath));\n                                break;\n                        }\n                    });\n                };\n                if (e) {\n                    // Doesn't exist. Proceed!\n                    rename();\n                }\n                else if (oldPath === newPath) {\n                    // NOP if the path exists. Error if it doesn't exist.\n                    if (e) {\n                        cb(ApiError.ENOENT(newPath));\n                    }\n                    else {\n                        cb();\n                    }\n                }\n                else if (stats && stats.isDirectory()) {\n                    // Exists, is a directory. Cannot rename over an existing directory.\n                    cb(ApiError.EISDIR(newPath));\n                }\n                else {\n                    // Exists, is a file, and differs from oldPath. Delete and rename.\n                    this.unlink(newPath, (e) => {\n                        if (e) {\n                            cb(e);\n                        }\n                        else {\n                            rename();\n                        }\n                    });\n                }\n            });\n        }\n        stat(path, isLstat, cb) {\n            if (path === '/') {\n                // Dropbox doesn't support querying the root directory.\n                setImmediate(function () {\n                    cb(null, new Stats(FileType.DIRECTORY, 4096));\n                });\n                return;\n            }\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesGetMetadata(arg).then((ref) => {\n                switch (ref['.tag']) {\n                    case 'file':\n                        const fileMetadata = ref;\n                        // TODO: Parse time fields.\n                        cb(null, new Stats(FileType.FILE, fileMetadata.size));\n                        break;\n                    case 'folder':\n                        cb(null, new Stats(FileType.DIRECTORY, 4096));\n                        break;\n                    case 'deleted':\n                        cb(ApiError.ENOENT(path));\n                        break;\n                    default:\n                        // Unknown.\n                        break;\n                }\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        cb(LookupErrorToError(err.path, path, GetErrorMessage(e)));\n                        break;\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        openFile(path, flags, cb) {\n            const downloadArg = {\n                path: FixPath(path)\n            };\n            this._client.filesDownload(downloadArg).then((res) => {\n                const b = res.fileBlob;\n                const fr = new FileReader();\n                fr.onload = () => {\n                    const ab = fr.result;\n                    cb(null, new DropboxFile(this, path, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));\n                };\n                fr.readAsArrayBuffer(b);\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const dpError = err;\n                        cb(LookupErrorToError(dpError.path, path, GetErrorMessage(e)));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        createFile(p, flags, mode, cb) {\n            const fileData = Buffer.alloc(0);\n            const blob = new Blob([buffer2ArrayBuffer(fileData)], { type: \"octet/stream\" });\n            const commitInfo = {\n                contents: blob,\n                path: FixPath(p)\n            };\n            this._client.filesUpload(commitInfo).then((metadata) => {\n                cb(null, new DropboxFile(this, p, flags, new Stats(FileType.FILE, 0), fileData));\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        // Retry in (500, 800) ms.\n                        setTimeout(() => this.createFile(p, flags, mode, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n        /**\n         * Delete a file\n         */\n        unlink(path, cb) {\n            // Must be a file. Check first.\n            this.stat(path, false, (e, stat) => {\n                if (stat) {\n                    if (stat.isDirectory()) {\n                        cb(ApiError.EISDIR(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Delete a directory\n         */\n        rmdir(path, cb) {\n            this.readdir(path, (e, paths) => {\n                if (paths) {\n                    if (paths.length > 0) {\n                        cb(ApiError.ENOTEMPTY(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Create a directory\n         */\n        mkdir(p, mode, cb) {\n            // Dropbox's create_folder is recursive. Check if parent exists.\n            const parent = dirname(p);\n            this.stat(parent, false, (e, stats) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (stats && !stats.isDirectory()) {\n                    cb(ApiError.ENOTDIR(parent));\n                }\n                else {\n                    const arg = {\n                        path: FixPath(p)\n                    };\n                    this._client.filesCreateFolderV2(arg).then(() => cb()).catch((e) => {\n                        const err = ExtractTheFuckingError(e);\n                        if (err['.tag'] === \"too_many_write_operations\") {\n                            // Retry in a bit.\n                            setTimeout(() => this.mkdir(p, mode, cb), 500 + (300 * (Math.random())));\n                        }\n                        else {\n                            cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Get the names of the files in a directory\n         */\n        readdir(path, cb) {\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesListFolder(arg).then((res) => {\n                ContinueReadingDir(this._client, path, res, [], cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n        /**\n         * (Internal) Syncs file to Dropbox.\n         */\n        _syncFile(p, d, cb) {\n            const blob = new Blob([buffer2ArrayBuffer(d)], { type: \"octet/stream\" });\n            const arg = {\n                contents: blob,\n                path: FixPath(p),\n                mode: {\n                    '.tag': 'overwrite'\n                }\n            };\n            this._client.filesUpload(arg).then(() => {\n                cb();\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        setTimeout(() => this._syncFile(p, d, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n    }\n    DropboxFileSystem.Name = \"DropboxV2\";\n    DropboxFileSystem.Options = {\n        client: {\n            type: \"object\",\n            description: \"An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK.\"\n        }\n    };\n    function ProcessListFolderError(e, path, cb) {\n        const err = ExtractTheFuckingError(e);\n        switch (err['.tag']) {\n            case 'path':\n                const pathError = err;\n                cb(LookupErrorToError(pathError.path, path, GetErrorMessage(e)));\n                break;\n            case 'other':\n            default:\n                cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));\n                break;\n        }\n    }\n    function ContinueReadingDir(client, path, res, previousEntries, cb) {\n        const newEntries = res.entries.map((e) => e.path_display).filter((p) => !!p);\n        const entries = previousEntries.concat(newEntries);\n        if (!res.has_more) {\n            cb(null, entries);\n        }\n        else {\n            const arg = {\n                cursor: res.cursor\n            };\n            client.filesListFolderContinue(arg).then((res) => {\n                ContinueReadingDir(client, path, res, entries, cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n    }\n\n    DropboxFileSystem.DropboxFile = DropboxFile;\n\n    return  DropboxFileSystem;\n    \n});"]}