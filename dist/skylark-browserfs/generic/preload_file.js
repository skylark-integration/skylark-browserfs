/**
 * skylark-browserfs - A version of browserfs that ported to running on skylarkjs.
 * @author 
 * @version v0.9.0
 * @link 
 * @license MIT
 */
define(["../libs/buffers","../core/file","../core/node_fs_stats","../core/api_error","../core/node_fs","../core/util"],function(t,s,e,i,r,h){"use strict";const{BaseFile:n}=s,{ApiError:o,ErrorCode:c}=i,{emptyBuffer:a}=h,{Buffer:f}=t;class l extends n{constructor(t,s,e,i,r){if(super(),this._pos=0,this._dirty=!1,this._fs=t,this._path=s,this._flag=e,this._stat=i,this._buffer=r||a(),this._stat.size!==this._buffer.length&&this._flag.isReadable())throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`)}getBuffer(){return this._buffer}getStats(){return this._stat}getFlag(){return this._flag}getPath(){return this._path}getPos(){return this._flag.isAppendable()?this._stat.size:this._pos}advancePos(t){return this._pos+=t}setPos(t){return this._pos=t}sync(t){try{this.syncSync(),t()}catch(s){t(s)}}syncSync(){throw new o(c.ENOTSUP)}close(t){try{this.closeSync(),t()}catch(s){t(s)}}closeSync(){throw new o(c.ENOTSUP)}stat(t){try{t(null,e.clone(this._stat))}catch(s){t(s)}}statSync(){return e.clone(this._stat)}truncate(t,s){try{this.truncateSync(t),this._flag.isSynchronous()&&!r.getRootFS().supportsSynch()&&this.sync(s),s()}catch(t){return s(t)}}truncateSync(t){if(this._dirty=!0,!this._flag.isWriteable())throw new o(c.EPERM,"File not opened with a writeable mode.");if(this._stat.mtimeMs=Date.now(),t>this._buffer.length){const s=f.alloc(t-this._buffer.length,0);return this.writeSync(s,0,s.length,this._buffer.length),void(this._flag.isSynchronous()&&r.getRootFS().supportsSynch()&&this.syncSync())}this._stat.size=t;const s=f.alloc(t);this._buffer.copy(s,0,0,t),this._buffer=s,this._flag.isSynchronous()&&r.getRootFS().supportsSynch()&&this.syncSync()}write(t,s,e,i,r){try{r(null,this.writeSync(t,s,e,i),t)}catch(t){r(t)}}writeSync(t,s,e,i){if(this._dirty=!0,void 0!==i&&null!==i||(i=this.getPos()),!this._flag.isWriteable())throw new o(c.EPERM,"File not opened with a writeable mode.");const r=i+e;if(r>this._stat.size&&(this._stat.size=r,r>this._buffer.length)){const t=f.alloc(r);this._buffer.copy(t),this._buffer=t}const h=t.copy(this._buffer,i,s,s+e);return this._stat.mtimeMs=Date.now(),this._flag.isSynchronous()?(this.syncSync(),h):(this.setPos(i+h),h)}read(t,s,e,i,r){try{r(null,this.readSync(t,s,e,i),t)}catch(t){r(t)}}readSync(t,s,e,i){if(!this._flag.isReadable())throw new o(c.EPERM,"File not opened with a readable mode.");void 0!==i&&null!==i||(i=this.getPos()),i+e>this._stat.size&&(e=this._stat.size-i);const r=this._buffer.copy(t,s,i,i+e);return this._stat.atimeMs=Date.now(),this._pos=i+e,r}chmod(t,s){try{this.chmodSync(t),s()}catch(t){s(t)}}chmodSync(t){if(!this._fs.supportsProps())throw new o(c.ENOTSUP);this._dirty=!0,this._stat.chmod(t),this.syncSync()}isDirty(){return this._dirty}resetDirty(){this._dirty=!1}}return{PreloadFile:l,NoSyncFile:class extends l{constructor(t,s,e,i,r){super(t,s,e,i,r)}sync(t){t()}syncSync(){}close(t){t()}closeSync(){}}}});
//# sourceMappingURL=../sourcemaps/generic/preload_file.js.map
