/**
 * skylark-browserfs - A version of browserfs that ported to running on skylarkjs.
 * @author 
 * @version v0.9.0
 * @link 
 * @license MIT
 */
define(["../libs/buffers","./api_error","./levenshtein","../libs/path"],function(e,t,r,n){"use strict";const{ErrorCode:i,ApiError:o}=t,{Buffer:f}=e;function s(e){return e instanceof Uint8Array?e:new Uint8Array(e)}function a(e){return e instanceof f?e:0===e.byteOffset&&e.byteLength===e.buffer.byteLength?u(e.buffer):f.from(e.buffer,e.byteOffset,e.byteLength)}function u(e){return f.from(e)}let c=null;function p(){return c||(c=f.alloc(0))}return{deprecationMessage:function(e,t,r){e&&console.warn(`[${t}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${t}.Create(${JSON.stringify(r)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`)},isIE:"undefined"!=typeof navigator&&!(!/(msie) ([\w.]+)/.exec(navigator.userAgent.toLowerCase())&&-1===navigator.userAgent.indexOf("Trident")),isWebWorker:"undefined"==typeof window,fail:function(){throw new Error("BFS has reached an impossible code path; please file a bug.")},mkdirpSync:function e(t,r,i){i.existsSync(t)||(e(n.dirname(t),r,i),i.mkdirSync(t,r))},buffer2ArrayBuffer:function(e){const t=s(e),r=t.byteOffset,n=t.byteLength;return 0===r&&n===t.buffer.byteLength?t.buffer:t.buffer.slice(r,r+n)},buffer2Uint8array:s,arrayish2Buffer:function(e){return e instanceof f?e:e instanceof Uint8Array?a(e):f.from(e)},uint8Array2Buffer:a,arrayBuffer2Buffer:u,copyingSlice:function(e,t=0,r=e.length){if(t<0||r<0||r>e.length||t>r)throw new TypeError(`Invalid slice bounds on buffer of length ${e.length}: [${t}, ${r}]`);if(0===e.length)return p();{const n=s(e),i=e[0],o=(i+1)%255;return e[0]=o,n[0]===o?(n[0]=i,a(n.slice(t,r))):(e[0]=i,a(n.subarray(t,r)))}},emptyBuffer:p,bufferValidator:function(e,t){f.isBuffer(e)?t():t(new o(i.EINVAL,"option must be a Buffer."))},checkOptions:function(e,t,n){const f=e.Options,s=e.Name;let a=0,u=!1,c=!1;function p(e){u||(e&&(u=!0,n(e)),0==--a&&c&&n())}for(const e in f)if(f.hasOwnProperty(e)){const c=f[e],d=t[e];if(void 0===d||null===d){if(!c.optional){const a=Object.keys(t).filter(e=>!(e in f)).map(t=>({str:t,distance:r(e,t)})).filter(e=>e.distance<5).sort((e,t)=>e.distance-t.distance);if(u)return;return u=!0,n(new o(i.EINVAL,`[${s}] Required option '${e}' not provided.${a.length>0?` You provided unrecognized option '${a[0].str}'; perhaps you meant to type '${e}'.`:""}\nOption description: ${c.description}`))}}else{let t=!1;if(!(t=Array.isArray(c.type)?-1!==c.type.indexOf(typeof d):typeof d===c.type)){if(u)return;return u=!0,n(new o(i.EINVAL,`[${s}] Value provided for option ${e} is not the proper type. Expected ${Array.isArray(c.type)?`one of {${c.type.join(", ")}}`:c.type}, but received ${typeof d}\nOption description: ${c.description}`))}c.validator&&(a++,c.validator(d,p))}}c=!0,0!==a||u||n()}}});
//# sourceMappingURL=../sourcemaps/core/util.js.map
