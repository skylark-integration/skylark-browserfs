/**
 * skylark-browserfs - A version of browserfs that ported to running on skylarkjs.
 * @author 
 * @version v0.9.0
 * @link 
 * @license MIT
 */
define(["../libs/buffers","./api_error","./file_flag","../libs/path","./node_fs_stats","../generic/setImmediate"],function(t,n,e,r,o,i){"use strict";const{ApiError:c,ErrorCode:s}=n,{FileFlag:a}=e,{Stats:l}=o,{Buffer:f}=t;let h=function(t,n){return t};function u(t,n){if("function"!=typeof t)throw new Error("Callback must be a function.");const e=h(t,n);switch(n){case 1:return function(t){i(function(){return e(t)})};case 2:return function(t,n){i(function(){return e(t,n)})};case 3:return function(t,n,r){i(function(){return e(t,n,r)})};default:throw new Error("Invalid invocation of wrapCb.")}}function d(t){if(t)return t;throw new c(s.EIO,"Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)")}function y(t,n){switch(typeof t){case"number":return t;case"string":const e=parseInt(t,8);return isNaN(e)?n:e;default:return n}}function w(t){if(t instanceof Date)return t;if("number"==typeof t)return new Date(1e3*t);throw new c(s.EINVAL,"Invalid time.")}function p(t){if(t.indexOf("\0")>=0)throw new c(s.EINVAL,"Path must be a string without null bytes.");if(""===t)throw new c(s.EINVAL,"Path must not be empty.");return r.resolve(t)}function m(t,n,e,r){switch(null===t?"null":typeof t){case"object":return{encoding:void 0!==t.encoding?t.encoding:n,flag:void 0!==t.flag?t.flag:e,mode:y(t.mode,r)};case"string":return{encoding:t,flag:e,mode:r};case"null":case"undefined":case"function":return{encoding:n,flag:e,mode:r};default:throw new TypeError(`"options" must be a string or an object, got ${typeof t} instead.`)}}function S(){}class g{constructor(){this.F_OK=0,this.R_OK=4,this.W_OK=2,this.X_OK=1,this.root=null,this.fdMap={},this.nextFd=100}initialize(t){if(!t.constructor.isAvailable())throw new c(s.EINVAL,"Tried to instantiate BrowserFS with an unavailable file system.");return this.root=t}_toUnixTimestamp(t){if("number"==typeof t)return t;if(t instanceof Date)return t.getTime()/1e3;throw new Error("Cannot parse time: "+t)}getRootFS(){return this.root?this.root:null}rename(t,n,e=S){const r=u(e,1);try{d(this.root).rename(p(t),p(n),r)}catch(t){r(t)}}renameSync(t,n){d(this.root).renameSync(p(t),p(n))}exists(t,n=S){const e=u(n,1);try{return d(this.root).exists(p(t),e)}catch(t){return e(!1)}}existsSync(t){try{return d(this.root).existsSync(p(t))}catch(t){return!1}}stat(t,n=S){const e=u(n,2);try{return d(this.root).stat(p(t),!1,e)}catch(t){return e(t)}}statSync(t){return d(this.root).statSync(p(t),!1)}lstat(t,n=S){const e=u(n,2);try{return d(this.root).stat(p(t),!0,e)}catch(t){return e(t)}}lstatSync(t){return d(this.root).statSync(p(t),!0)}truncate(t,n=0,e=S){let r=0;"function"==typeof n?e=n:"number"==typeof n&&(r=n);const o=u(e,1);try{if(r<0)throw new c(s.EINVAL);return d(this.root).truncate(p(t),r,o)}catch(t){return o(t)}}truncateSync(t,n=0){if(n<0)throw new c(s.EINVAL);return d(this.root).truncateSync(p(t),n)}unlink(t,n=S){const e=u(n,1);try{return d(this.root).unlink(p(t),e)}catch(t){return e(t)}}unlinkSync(t){return d(this.root).unlinkSync(p(t))}open(t,n,e,r=S){const o=y(e,420),i=u(r="function"==typeof e?e:r,2);try{d(this.root).open(p(t),a.getFileFlag(n),o,(t,n)=>{n?i(t,this.getFdForFile(n)):i(t)})}catch(t){i(t)}}openSync(t,n,e=420){return this.getFdForFile(d(this.root).openSync(p(t),a.getFileFlag(n),y(e,420)))}readFile(t,n={},e=S){const r=m(n,null,"r",null),o=u(e="function"==typeof n?n:e,2);try{const n=a.getFileFlag(r.flag);return n.isReadable()?d(this.root).readFile(p(t),r.encoding,n,o):o(new c(s.EINVAL,"Flag passed to readFile must allow for reading."))}catch(t){return o(t)}}readFileSync(t,n={}){const e=m(n,null,"r",null),r=a.getFileFlag(e.flag);if(!r.isReadable())throw new c(s.EINVAL,"Flag passed to readFile must allow for reading.");return d(this.root).readFileSync(p(t),e.encoding,r)}writeFile(t,n,e={},r=S){const o=m(e,"utf8","w",420),i=u(r="function"==typeof e?e:r,1);try{const e=a.getFileFlag(o.flag);return e.isWriteable()?d(this.root).writeFile(p(t),n,o.encoding,e,o.mode,i):i(new c(s.EINVAL,"Flag passed to writeFile must allow for writing."))}catch(t){return i(t)}}writeFileSync(t,n,e){const r=m(e,"utf8","w",420),o=a.getFileFlag(r.flag);if(!o.isWriteable())throw new c(s.EINVAL,"Flag passed to writeFile must allow for writing.");return d(this.root).writeFileSync(p(t),n,r.encoding,o,r.mode)}appendFile(t,n,e,r=S){const o=m(e,"utf8","a",420),i=u(r="function"==typeof e?e:r,1);try{const e=a.getFileFlag(o.flag);if(!e.isAppendable())return i(new c(s.EINVAL,"Flag passed to appendFile must allow for appending."));d(this.root).appendFile(p(t),n,o.encoding,e,o.mode,i)}catch(t){i(t)}}appendFileSync(t,n,e){const r=m(e,"utf8","a",420),o=a.getFileFlag(r.flag);if(!o.isAppendable())throw new c(s.EINVAL,"Flag passed to appendFile must allow for appending.");return d(this.root).appendFileSync(p(t),n,r.encoding,o,r.mode)}fstat(t,n=S){const e=u(n,2);try{this.fd2file(t).stat(e)}catch(t){e(t)}}fstatSync(t){return this.fd2file(t).statSync()}close(t,n=S){const e=u(n,1);try{this.fd2file(t).close(n=>{n||this.closeFd(t),e(n)})}catch(t){e(t)}}closeSync(t){this.fd2file(t).closeSync(),this.closeFd(t)}ftruncate(t,n,e=S){const r="number"==typeof n?n:0,o=u(e="function"==typeof n?n:e,1);try{const n=this.fd2file(t);if(r<0)throw new c(s.EINVAL);n.truncate(r,o)}catch(t){o(t)}}ftruncateSync(t,n=0){const e=this.fd2file(t);if(n<0)throw new c(s.EINVAL);e.truncateSync(n)}fsync(t,n=S){const e=u(n,1);try{this.fd2file(t).sync(e)}catch(t){e(t)}}fsyncSync(t){this.fd2file(t).syncSync()}fdatasync(t,n=S){const e=u(n,1);try{this.fd2file(t).datasync(e)}catch(t){e(t)}}fdatasyncSync(t){this.fd2file(t).datasyncSync()}write(t,n,e,r,o,i=S){let a,l,h,d=null;if("string"==typeof n){let t="utf8";switch(typeof e){case"function":i=e;break;case"number":d=e,t="string"==typeof r?r:"utf8",i="function"==typeof o?o:i;break;default:return(i="function"==typeof r?r:"function"==typeof o?o:i)(new c(s.EINVAL,"Invalid arguments."))}l=0,h=(a=f.from(n,t)).length}else a=n,l=e,h=r,d="number"==typeof o?o:null,i="function"==typeof o?o:i;const y=u(i,3);try{const n=this.fd2file(t);void 0!==d&&null!==d||(d=n.getPos()),n.write(a,l,h,d,y)}catch(t){y(t)}}writeSync(t,n,e,r,o){let i,c,s,a=0;if("string"==typeof n){s="number"==typeof e?e:null;const t="string"==typeof r?r:"utf8";a=0,c=(i=f.from(n,t)).length}else i=n,a=e,c=r,s="number"==typeof o?o:null;const l=this.fd2file(t);return void 0!==s&&null!==s||(s=l.getPos()),l.writeSync(i,a,c,s)}read(t,n,e,r,o,i=S){let c,s,a,l,h;if("number"==typeof n){a=n,c=e;const t=r;i="function"==typeof o?o:i,s=0,l=f.alloc(a),h=u((n,e,r)=>{if(n)return i(n);i(n,r.toString(t),e)},3)}else l=n,s=e,a=r,c=o,h=u(i,3);try{const n=this.fd2file(t);void 0!==c&&null!==c||(c=n.getPos()),n.read(l,s,a,c,h)}catch(t){h(t)}}readSync(t,n,e,r,o){let i,c,s,a,l=!1,h="utf8";"number"==typeof n?(s=n,a=e,h=r,c=0,i=f.alloc(s),l=!0):(i=n,c=e,s=r,a=o);const u=this.fd2file(t);void 0!==a&&null!==a||(a=u.getPos());const d=u.readSync(i,c,s,a);return l?[i.toString(h),d]:d}fchown(t,n,e,r=S){const o=u(r,1);try{this.fd2file(t).chown(n,e,o)}catch(t){o(t)}}fchownSync(t,n,e){this.fd2file(t).chownSync(n,e)}fchmod(t,n,e){const r=u(e,1);try{const e="string"==typeof n?parseInt(n,8):n;this.fd2file(t).chmod(e,r)}catch(t){r(t)}}fchmodSync(t,n){const e="string"==typeof n?parseInt(n,8):n;this.fd2file(t).chmodSync(e)}futimes(t,n,e,r=S){const o=u(r,1);try{const r=this.fd2file(t);"number"==typeof n&&(n=new Date(1e3*n)),"number"==typeof e&&(e=new Date(1e3*e)),r.utimes(n,e,o)}catch(t){o(t)}}futimesSync(t,n,e){this.fd2file(t).utimesSync(w(n),w(e))}rmdir(t,n=S){const e=u(n,1);try{t=p(t),d(this.root).rmdir(t,e)}catch(t){e(t)}}rmdirSync(t){return t=p(t),d(this.root).rmdirSync(t)}mkdir(t,n,e=S){"function"==typeof n&&(e=n,n=511);const r=u(e,1);try{t=p(t),d(this.root).mkdir(t,n,r)}catch(t){r(t)}}mkdirSync(t,n){d(this.root).mkdirSync(p(t),y(n,511))}readdir(t,n=S){const e=u(n,2);try{t=p(t),d(this.root).readdir(t,e)}catch(t){e(t)}}readdirSync(t){return t=p(t),d(this.root).readdirSync(t)}link(t,n,e=S){const r=u(e,1);try{t=p(t),n=p(n),d(this.root).link(t,n,r)}catch(t){r(t)}}linkSync(t,n){return t=p(t),n=p(n),d(this.root).linkSync(t,n)}symlink(t,n,e,r=S){const o="string"==typeof e?e:"file",i=u(r="function"==typeof e?e:r,1);try{if("file"!==o&&"dir"!==o)return i(new c(s.EINVAL,"Invalid type: "+o));t=p(t),n=p(n),d(this.root).symlink(t,n,o,i)}catch(t){i(t)}}symlinkSync(t,n,e){if(e){if("file"!==e&&"dir"!==e)throw new c(s.EINVAL,"Invalid type: "+e)}else e="file";return t=p(t),n=p(n),d(this.root).symlinkSync(t,n,e)}readlink(t,n=S){const e=u(n,2);try{t=p(t),d(this.root).readlink(t,e)}catch(t){e(t)}}readlinkSync(t){return t=p(t),d(this.root).readlinkSync(t)}chown(t,n,e,r=S){const o=u(r,1);try{t=p(t),d(this.root).chown(t,!1,n,e,o)}catch(t){o(t)}}chownSync(t,n,e){t=p(t),d(this.root).chownSync(t,!1,n,e)}lchown(t,n,e,r=S){const o=u(r,1);try{t=p(t),d(this.root).chown(t,!0,n,e,o)}catch(t){o(t)}}lchownSync(t,n,e){t=p(t),d(this.root).chownSync(t,!0,n,e)}chmod(t,n,e=S){const r=u(e,1);try{const e=y(n,-1);if(e<0)throw new c(s.EINVAL,"Invalid mode.");d(this.root).chmod(p(t),!1,e,r)}catch(t){r(t)}}chmodSync(t,n){const e=y(n,-1);if(e<0)throw new c(s.EINVAL,"Invalid mode.");t=p(t),d(this.root).chmodSync(t,!1,e)}lchmod(t,n,e=S){const r=u(e,1);try{const e=y(n,-1);if(e<0)throw new c(s.EINVAL,"Invalid mode.");d(this.root).chmod(p(t),!0,e,r)}catch(t){r(t)}}lchmodSync(t,n){const e=y(n,-1);if(e<1)throw new c(s.EINVAL,"Invalid mode.");d(this.root).chmodSync(p(t),!0,e)}utimes(t,n,e,r=S){const o=u(r,1);try{d(this.root).utimes(p(t),w(n),w(e),o)}catch(t){o(t)}}utimesSync(t,n,e){d(this.root).utimesSync(p(t),w(n),w(e))}realpath(t,n,e=S){const r="object"==typeof n?n:{},o=u("function"==typeof n?n:S,2);try{t=p(t),d(this.root).realpath(t,r,o)}catch(t){o(t)}}realpathSync(t,n={}){return t=p(t),d(this.root).realpathSync(t,n)}watchFile(t,n,e=S){throw new c(s.ENOTSUP)}unwatchFile(t,n=S){throw new c(s.ENOTSUP)}watch(t,n,e=S){throw new c(s.ENOTSUP)}access(t,n,e=S){throw new c(s.ENOTSUP)}accessSync(t,n){throw new c(s.ENOTSUP)}createReadStream(t,n){throw new c(s.ENOTSUP)}createWriteStream(t,n){throw new c(s.ENOTSUP)}wrapCallbacks(t){h=t}getFdForFile(t){const n=this.nextFd++;return this.fdMap[n]=t,n}fd2file(t){const n=this.fdMap[t];if(n)return n;throw new c(s.EBADF,"Invalid file descriptor.")}closeFd(t){delete this.fdMap[t]}}return g.Stats=l,g});
//# sourceMappingURL=../sourcemaps/core/FS.js.map
