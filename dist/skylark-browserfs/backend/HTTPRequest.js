/**
 * skylark-browserfs - A version of browserfs that ported to running on skylarkjs.
 * @author 
 * @version v0.9.0
 * @link 
 * @license MIT
 */
define(["../core/file_system","../core/api_error","../core/file_flag","../core/util","../core/node_fs_stats","../generic/preload_file","../generic/xhr","../generic/fetch","../generic/file_index"],function(e,t,n,i,r,s,l,o,a){"use strict";const{BaseFileSystem:c}=e,{ApiError:u,ErrorCode:h}=t,{ActionType:f}=n,{copyingSlice:d}=i,{Stats:y}=r,{NoSyncFile:S}=s,{xhrIsAvailable:_,asyncDownloadFile:g,syncDownloadFile:E,getFileSizeAsync:I,getFileSizeSync:p}=l,{fetchIsAvailable:F,fetchFileAsync:T,fetchFileSizeAsync:x}=o,{FileIndex:w,isFileInode:N,isDirInode:A}=a;function D(){throw new u(h.ENOTSUP,"Synchronous HTTP download methods are not available in this environment.")}class q extends c{constructor(e,t="",n=!1){super(),t.length>0&&"/"!==t.charAt(t.length-1)&&(t+="/"),this.prefixUrl=t,this._index=w.fromListing(e),!F||n&&_?(this._requestFileAsyncInternal=g,this._requestFileSizeAsyncInternal=I):(this._requestFileAsyncInternal=T,this._requestFileSizeAsyncInternal=x),_?(this._requestFileSyncInternal=E,this._requestFileSizeSyncInternal=p):(this._requestFileSyncInternal=D,this._requestFileSizeSyncInternal=D)}static Create(e,t){void 0===e.index&&(e.index="index.json"),"string"==typeof e.index?g(e.index,"json",(n,i)=>{n?t(n):t(null,new q(i,e.baseUrl))}):t(null,new q(e.index,e.baseUrl))}static isAvailable(){return _||F}empty(){this._index.fileIterator(function(e){e.fileData=null})}getName(){return q.Name}diskSpace(e,t){t(0,0)}isReadOnly(){return!0}supportsLinks(){return!1}supportsProps(){return!1}supportsSynch(){return _}preloadFile(e,t){const n=this._index.getInode(e);if(!N(n))throw u.EISDIR(e);{if(null===n)throw u.ENOENT(e);const i=n.getData();i.size=t.length,i.fileData=t}}stat(e,t,n){const i=this._index.getInode(e);if(null===i)return n(u.ENOENT(e));let r;N(i)?(r=i.getData()).size<0?this._requestFileSizeAsync(e,function(e,t){if(e)return n(e);r.size=t,n(null,y.clone(r))}):n(null,y.clone(r)):A(i)?(r=i.getStats(),n(null,r)):n(u.FileError(h.EINVAL,e))}statSync(e,t){const n=this._index.getInode(e);if(null===n)throw u.ENOENT(e);let i;if(N(n))(i=n.getData()).size<0&&(i.size=this._requestFileSizeSync(e));else{if(!A(n))throw u.FileError(h.EINVAL,e);i=n.getStats()}return i}open(e,t,n,i){if(t.isWriteable())return i(new u(h.EPERM,e));const r=this,s=this._index.getInode(e);if(null===s)return i(u.ENOENT(e));if(!N(s))return i(u.EISDIR(e));{const n=s.getData();switch(t.pathExistsAction()){case f.THROW_EXCEPTION:case f.TRUNCATE_FILE:return i(u.EEXIST(e));case f.NOP:if(n.fileData)return i(null,new S(r,e,t,y.clone(n),n.fileData));this._requestFileAsync(e,"buffer",function(s,l){return s?i(s):(n.size=l.length,n.fileData=l,i(null,new S(r,e,t,y.clone(n),l)))});break;default:return i(new u(h.EINVAL,"Invalid FileMode object."))}}}openSync(e,t,n){if(t.isWriteable())throw new u(h.EPERM,e);const i=this._index.getInode(e);if(null===i)throw u.ENOENT(e);if(!N(i))throw u.EISDIR(e);{const n=i.getData();switch(t.pathExistsAction()){case f.THROW_EXCEPTION:case f.TRUNCATE_FILE:throw u.EEXIST(e);case f.NOP:if(n.fileData)return new S(this,e,t,y.clone(n),n.fileData);const i=this._requestFileSync(e,"buffer");return n.size=i.length,n.fileData=i,new S(this,e,t,y.clone(n),i);default:throw new u(h.EINVAL,"Invalid FileMode object.")}}}readdir(e,t){try{t(null,this.readdirSync(e))}catch(e){t(e)}}readdirSync(e){const t=this._index.getInode(e);if(null===t)throw u.ENOENT(e);if(A(t))return t.getListing();throw u.ENOTDIR(e)}readFile(e,t,n,i){const r=i;this.open(e,n,420,function(e,n){if(e)return i(e);i=function(e,t){n.close(function(n){return e||(e=n),r(e,t)})};const s=n.getBuffer();null===t?i(e,d(s)):function(e,t,n){try{n(null,e.toString(t))}catch(e){n(e)}}(s,t,i)})}readFileSync(e,t,n){const i=this.openSync(e,n,420);try{const e=i.getBuffer();return null===t?d(e):e.toString(t)}finally{i.closeSync()}}_getHTTPPath(e){return"/"===e.charAt(0)&&(e=e.slice(1)),this.prefixUrl+e}_requestFileAsync(e,t,n){this._requestFileAsyncInternal(this._getHTTPPath(e),t,n)}_requestFileSync(e,t){return this._requestFileSyncInternal(this._getHTTPPath(e),t)}_requestFileSizeAsync(e,t){this._requestFileSizeAsyncInternal(this._getHTTPPath(e),t)}_requestFileSizeSync(e){return this._requestFileSizeSyncInternal(this._getHTTPPath(e))}}return q.Name="HTTPRequest",q.Options={index:{type:["string","object"],optional:!0,description:"URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`."},baseUrl:{type:"string",optional:!0,description:"Used as the URL prefix for fetched files. Default: Fetch files relative to the index."},preferXHR:{type:"boolean",optional:!0,description:"Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false"}},q});
//# sourceMappingURL=../sourcemaps/backend/HTTPRequest.js.map
