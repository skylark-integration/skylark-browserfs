/**
 * skylark-browserfs - A version of browserfs that ported to running on skylarkjs.
 * @author 
 * @version v0.9.0
 * @link 
 * @license MIT
 */
define(["../core/file_system","../core/api_error","../core/file_flag","../generic/preload_file","../libs/path"],function(e,s,t,n,i){"use strict";const{SynchronousFileSystem:r}=e,{ApiError:c,ErrorCode:u}=s,{FileFlag:h}=t,{PreloadFile:y}=n;class a extends y{constructor(e,s,t,n,i){super(e,s,t,n,i)}syncSync(){this.isDirty()&&(this._fs._syncSync(this),this.resetDirty())}closeSync(){this.syncSync()}}class o extends r{constructor(e,s){super(),this._queue=[],this._queueRunning=!1,this._isInitialized=!1,this._initializeCallbacks=[],this._sync=e,this._async=s}static Create(e,s){try{const t=new o(e.sync,e.async);t._initialize(e=>{e?s(e):s(null,t)})}catch(e){s(e)}}static isAvailable(){return!0}getName(){return o.Name}_syncSync(e){this._sync.writeFileSync(e.getPath(),e.getBuffer(),null,h.getFileFlag("w"),e.getStats().mode),this.enqueueOp({apiMethod:"writeFile",arguments:[e.getPath(),e.getBuffer(),null,e.getFlag(),e.getStats().mode]})}isReadOnly(){return!1}supportsSynch(){return!0}supportsLinks(){return!1}supportsProps(){return this._sync.supportsProps()&&this._async.supportsProps()}renameSync(e,s){this._sync.renameSync(e,s),this.enqueueOp({apiMethod:"rename",arguments:[e,s]})}statSync(e,s){return this._sync.statSync(e,s)}openSync(e,s,t){return this._sync.openSync(e,s,t).closeSync(),new a(this,e,s,this._sync.statSync(e,!1),this._sync.readFileSync(e,null,h.getFileFlag("r")))}unlinkSync(e){this._sync.unlinkSync(e),this.enqueueOp({apiMethod:"unlink",arguments:[e]})}rmdirSync(e){this._sync.rmdirSync(e),this.enqueueOp({apiMethod:"rmdir",arguments:[e]})}mkdirSync(e,s){this._sync.mkdirSync(e,s),this.enqueueOp({apiMethod:"mkdir",arguments:[e,s]})}readdirSync(e){return this._sync.readdirSync(e)}existsSync(e){return this._sync.existsSync(e)}chmodSync(e,s,t){this._sync.chmodSync(e,s,t),this.enqueueOp({apiMethod:"chmod",arguments:[e,s,t]})}chownSync(e,s,t,n){this._sync.chownSync(e,s,t,n),this.enqueueOp({apiMethod:"chown",arguments:[e,s,t,n]})}utimesSync(e,s,t){this._sync.utimesSync(e,s,t),this.enqueueOp({apiMethod:"utimes",arguments:[e,s,t]})}_initialize(e){const s=this._initializeCallbacks,t=e=>{this._isInitialized=!e,this._initializeCallbacks=[],s.forEach(s=>s(e))};if(this._isInitialized)e();else if(1===s.push(e)){const e=(e,s,t)=>{"/"!==e&&this._sync.mkdirSync(e,s),this._async.readdir(e,(s,r)=>{let c=0;s?t(s):function s(u){u?t(u):c<r.length?(n(i.join(e,r[c]),s),c++):t()}()})},s=(e,s,t)=>{this._async.readFile(e,null,h.getFileFlag("r"),(n,i)=>{if(n)t(n);else try{this._sync.writeFileSync(e,i,null,h.getFileFlag("w"),s)}catch(e){n=e}finally{t(n)}})},n=(t,n)=>{this._async.stat(t,!1,(i,r)=>{i?n(i):r.isDirectory()?e(t,r.mode,n):s(t,r.mode,n)})};e("/",0,t)}}enqueueOp(e){if(this._queue.push(e),!this._queueRunning){this._queueRunning=!0;const e=s=>{if(s)throw new Error(`WARNING: File system has desynchronized. Received following error: ${s}\n$`);if(this._queue.length>0){const s=this._queue.shift(),t=s.arguments;t.push(e),this._async[s.apiMethod].apply(this._async,t)}else this._queueRunning=!1};e()}}}return o.Name="AsyncMirror",o.Options={sync:{type:"object",description:"The synchronous file system to mirror the asynchronous file system to.",validator:(e,s)=>{e&&"function"==typeof e.supportsSynch&&e.supportsSynch()?s():s(new c(u.EINVAL,"'sync' option must be a file system that supports synchronous operations"))}},async:{type:"object",description:"The asynchronous file system to mirror."}},o});
//# sourceMappingURL=../sourcemaps/backend/AsyncMirror.js.map
