{"version":3,"sources":["skylark-browserfs.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-browserfs.js","sourcesContent":["define('skylark-browserfs/libs/process',[\r\n    \"skylark-langx-executive/process\"\r\n],function(process){\r\n  'use strict'\r\n    return process;\r\n});\ndefine('skylark-browserfs/libs/buffers',[\r\n  \"skylark-langx-binary/buffer\"\r\n],function(Buffer){\r\n  /*!\r\n   * The buffer module from node.js, for the browser.\r\n   *\r\n   * @author   Feross Aboukhadijeh <https://feross.org>\r\n   * @license  MIT\r\n   */\r\n  /* eslint-disable no-proto */\r\n\r\n  'use strict'\r\n\r\n  return {\r\n    Buffer\r\n  }\r\n\r\n});\ndefine('skylark-browserfs/core/api_error',[\n  '../libs/buffers'\n],function (buffers) {\n    const { Buffer } = buffers;\n\n    /**\n     * Standard libc error codes. Add more to this enum and ErrorStrings as they are\n     * needed.\n     * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html\n     */\n    var ErrorCode;\n    (function (ErrorCode) {\n        ErrorCode[ErrorCode[\"EPERM\"] = 1] = \"EPERM\";\n        ErrorCode[ErrorCode[\"ENOENT\"] = 2] = \"ENOENT\";\n        ErrorCode[ErrorCode[\"EIO\"] = 5] = \"EIO\";\n        ErrorCode[ErrorCode[\"EBADF\"] = 9] = \"EBADF\";\n        ErrorCode[ErrorCode[\"EACCES\"] = 13] = \"EACCES\";\n        ErrorCode[ErrorCode[\"EBUSY\"] = 16] = \"EBUSY\";\n        ErrorCode[ErrorCode[\"EEXIST\"] = 17] = \"EEXIST\";\n        ErrorCode[ErrorCode[\"ENOTDIR\"] = 20] = \"ENOTDIR\";\n        ErrorCode[ErrorCode[\"EISDIR\"] = 21] = \"EISDIR\";\n        ErrorCode[ErrorCode[\"EINVAL\"] = 22] = \"EINVAL\";\n        ErrorCode[ErrorCode[\"EFBIG\"] = 27] = \"EFBIG\";\n        ErrorCode[ErrorCode[\"ENOSPC\"] = 28] = \"ENOSPC\";\n        ErrorCode[ErrorCode[\"EROFS\"] = 30] = \"EROFS\";\n        ErrorCode[ErrorCode[\"ENOTEMPTY\"] = 39] = \"ENOTEMPTY\";\n        ErrorCode[ErrorCode[\"ENOTSUP\"] = 95] = \"ENOTSUP\";\n    })(ErrorCode || (ErrorCode = {}));\n\n    /* tslint:disable:variable-name */\n    /**\n     * Strings associated with each error code.\n     * @hidden\n     */\n    const ErrorStrings = {};\n    ErrorStrings[ErrorCode.EPERM] = 'Operation not permitted.';\n    ErrorStrings[ErrorCode.ENOENT] = 'No such file or directory.';\n    ErrorStrings[ErrorCode.EIO] = 'Input/output error.';\n    ErrorStrings[ErrorCode.EBADF] = 'Bad file descriptor.';\n    ErrorStrings[ErrorCode.EACCES] = 'Permission denied.';\n    ErrorStrings[ErrorCode.EBUSY] = 'Resource busy or locked.';\n    ErrorStrings[ErrorCode.EEXIST] = 'File exists.';\n    ErrorStrings[ErrorCode.ENOTDIR] = 'File is not a directory.';\n    ErrorStrings[ErrorCode.EISDIR] = 'File is a directory.';\n    ErrorStrings[ErrorCode.EINVAL] = 'Invalid argument.';\n    ErrorStrings[ErrorCode.EFBIG] = 'File is too big.';\n    ErrorStrings[ErrorCode.ENOSPC] = 'No space left on disk.';\n    ErrorStrings[ErrorCode.EROFS] = 'Cannot modify a read-only file system.';\n    ErrorStrings[ErrorCode.ENOTEMPTY] = 'Directory is not empty.';\n    ErrorStrings[ErrorCode.ENOTSUP] = 'Operation is not supported.';\n\n    /* tslint:enable:variable-name */\n    /**\n     * Represents a BrowserFS error. Passed back to applications after a failed\n     * call to the BrowserFS API.\n     */\n    class ApiError extends Error {\n        /**\n         * Represents a BrowserFS error. Passed back to applications after a failed\n         * call to the BrowserFS API.\n         *\n         * Error codes mirror those returned by regular Unix file operations, which is\n         * what Node returns.\n         * @constructor ApiError\n         * @param type The type of the error.\n         * @param [message] A descriptive error message.\n         */\n        constructor(type, message = ErrorStrings[type], path) {\n            super(message);\n            // Unsupported.\n            this.syscall = \"\";\n            this.errno = type;\n            this.code = ErrorCode[type];\n            this.path = path;\n            this.stack = new Error().stack;\n            this.message = `Error: ${this.code}: ${message}${this.path ? `, '${this.path}'` : ''}`;\n        }\n        static fromJSON(json) {\n            const err = new ApiError(0);\n            err.errno = json.errno;\n            err.code = json.code;\n            err.path = json.path;\n            err.stack = json.stack;\n            err.message = json.message;\n            return err;\n        }\n        /**\n         * Creates an ApiError object from a buffer.\n         */\n        static fromBuffer(buffer, i = 0) {\n            return ApiError.fromJSON(JSON.parse(buffer.toString('utf8', i + 4, i + 4 + buffer.readUInt32LE(i))));\n        }\n        static FileError(code, p) {\n            return new ApiError(code, ErrorStrings[code], p);\n        }\n        static ENOENT(path) {\n            return this.FileError(ErrorCode.ENOENT, path);\n        }\n        static EEXIST(path) {\n            return this.FileError(ErrorCode.EEXIST, path);\n        }\n        static EISDIR(path) {\n            return this.FileError(ErrorCode.EISDIR, path);\n        }\n        static ENOTDIR(path) {\n            return this.FileError(ErrorCode.ENOTDIR, path);\n        }\n        static EPERM(path) {\n            return this.FileError(ErrorCode.EPERM, path);\n        }\n        static ENOTEMPTY(path) {\n            return this.FileError(ErrorCode.ENOTEMPTY, path);\n        }\n        /**\n         * @return A friendly error message.\n         */\n        toString() {\n            return this.message;\n        }\n        toJSON() {\n            return {\n                errno: this.errno,\n                code: this.code,\n                path: this.path,\n                stack: this.stack,\n                message: this.message\n            };\n        }\n        /**\n         * Writes the API error into a buffer.\n         */\n        writeToBuffer(buffer = Buffer.alloc(this.bufferSize()), i = 0) {\n            const bytesWritten = buffer.write(JSON.stringify(this.toJSON()), i + 4);\n            buffer.writeUInt32LE(bytesWritten, i);\n            return buffer;\n        }\n        /**\n         * The size of the API error in buffer-form in bytes.\n         */\n        bufferSize() {\n            // 4 bytes for string length.\n            return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));\n        }\n    }\n\n    return {\n        ApiError,\n        ErrorCode,\n        ErrorStrings\n    };\n});\ndefine('skylark-browserfs/core/file_flag',['./api_error'], function (api_error) {\n    'use strict';\n\n  const { ErrorCode, ApiError } = api_error;\n\n  var ActionType;\n  (function (ActionType) {\n      // Indicates that the code should not do anything.\n      ActionType[ActionType[\"NOP\"] = 0] = \"NOP\";\n      // Indicates that the code should throw an exception.\n      ActionType[ActionType[\"THROW_EXCEPTION\"] = 1] = \"THROW_EXCEPTION\";\n      // Indicates that the code should truncate the file, but only if it is a file.\n      ActionType[ActionType[\"TRUNCATE_FILE\"] = 2] = \"TRUNCATE_FILE\";\n      // Indicates that the code should create the file.\n      ActionType[ActionType[\"CREATE_FILE\"] = 3] = \"CREATE_FILE\";\n  })(ActionType || (ActionType = {}));\n  /**\n   * Represents one of the following file flags. A convenience object.\n   *\n   * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\n   * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\n   * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\n   * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\n   * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n   * * `'wx'` - Like 'w' but opens the file in exclusive mode.\n   * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n   * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\n   * * `'a'` - Open file for appending. The file is created if it does not exist.\n   * * `'ax'` - Like 'a' but opens the file in exclusive mode.\n   * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\n   * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\n   *\n   * Exclusive mode ensures that the file path is newly created.\n   */\n  class FileFlag {\n      /**\n       * This should never be called directly.\n       * @param modeStr The string representing the mode\n       * @throw when the mode string is invalid\n       */\n      constructor(flagStr) {\n          this.flagStr = flagStr;\n          if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {\n              throw new ApiError(ErrorCode.EINVAL, \"Invalid flag: \" + flagStr);\n          }\n      }\n      /**\n       * Get an object representing the given file flag.\n       * @param modeStr The string representing the flag\n       * @return The FileFlag object representing the flag\n       * @throw when the flag string is invalid\n       */\n      static getFileFlag(flagStr) {\n          // Check cache first.\n          if (FileFlag.flagCache.hasOwnProperty(flagStr)) {\n              return FileFlag.flagCache[flagStr];\n          }\n          return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);\n      }\n      /**\n       * Get the underlying flag string for this flag.\n       */\n      getFlagString() {\n          return this.flagStr;\n      }\n      /**\n       * Returns true if the file is readable.\n       */\n      isReadable() {\n          return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;\n      }\n      /**\n       * Returns true if the file is writeable.\n       */\n      isWriteable() {\n          return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;\n      }\n      /**\n       * Returns true if the file mode should truncate.\n       */\n      isTruncating() {\n          return this.flagStr.indexOf('w') !== -1;\n      }\n      /**\n       * Returns true if the file is appendable.\n       */\n      isAppendable() {\n          return this.flagStr.indexOf('a') !== -1;\n      }\n      /**\n       * Returns true if the file is open in synchronous mode.\n       */\n      isSynchronous() {\n          return this.flagStr.indexOf('s') !== -1;\n      }\n      /**\n       * Returns true if the file is open in exclusive mode.\n       */\n      isExclusive() {\n          return this.flagStr.indexOf('x') !== -1;\n      }\n      /**\n       * Returns one of the static fields on this object that indicates the\n       * appropriate response to the path existing.\n       */\n      pathExistsAction() {\n          if (this.isExclusive()) {\n              return ActionType.THROW_EXCEPTION;\n          }\n          else if (this.isTruncating()) {\n              return ActionType.TRUNCATE_FILE;\n          }\n          else {\n              return ActionType.NOP;\n          }\n      }\n      /**\n       * Returns one of the static fields on this object that indicates the\n       * appropriate response to the path not existing.\n       */\n      pathNotExistsAction() {\n          if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {\n              return ActionType.CREATE_FILE;\n          }\n          else {\n              return ActionType.THROW_EXCEPTION;\n          }\n      }\n  }\n  // Contains cached FileMode instances.\n  FileFlag.flagCache = {};\n  // Array of valid mode strings.\n  FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];\n\n\n\n    return {\n        ActionType: ActionType,\n        FileFlag: FileFlag\n    };\n});\ndefine('skylark-browserfs/libs/path',[\r\n\t\"skylark-langx-paths\"\r\n],function(paths){\r\n  'use strict'\r\n\treturn paths;\r\n});\ndefine('skylark-browserfs/core/node_fs_stats',[\n    '../libs/buffers'\n],function (buffers) {\n    'use strict';\n    const { Buffer } = buffers;\n\n    /**\n     * Indicates the type of the given file. Applied to 'mode'.\n     */\n    var FileType;\n    (function (FileType) {\n        FileType[FileType[\"FILE\"] = 32768] = \"FILE\";\n        FileType[FileType[\"DIRECTORY\"] = 16384] = \"DIRECTORY\";\n        FileType[FileType[\"SYMLINK\"] = 40960] = \"SYMLINK\";\n    })(FileType || (FileType = {}));\n\n    /**\n     * Emulation of Node's `fs.Stats` object.\n     *\n     * Attribute descriptions are from `man 2 stat'\n     * @see http://nodejs.org/api/fs.html#fs_class_fs_stats\n     * @see http://man7.org/linux/man-pages/man2/stat.2.html\n     */\n    class Stats {\n        /**\n         * Provides information about a particular entry in the file system.\n         * @param itemType Type of the item (FILE, DIRECTORY, SYMLINK, or SOCKET)\n         * @param size Size of the item in bytes. For directories/symlinks,\n         *   this is normally the size of the struct that represents the item.\n         * @param mode Unix-style file mode (e.g. 0o644)\n         * @param atimeMs time of last access, in milliseconds since epoch\n         * @param mtimeMs time of last modification, in milliseconds since epoch\n         * @param ctimeMs time of last time file status was changed, in milliseconds since epoch\n         * @param birthtimeMs time of file creation, in milliseconds since epoch\n         */\n        constructor(itemType, size, mode, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {\n            /**\n             * UNSUPPORTED ATTRIBUTES\n             * I assume no one is going to need these details, although we could fake\n             * appropriate values if need be.\n             */\n            // ID of device containing file\n            this.dev = 0;\n            // inode number\n            this.ino = 0;\n            // device ID (if special file)\n            this.rdev = 0;\n            // number of hard links\n            this.nlink = 1;\n            // blocksize for file system I/O\n            this.blksize = 4096;\n            // @todo Maybe support these? atm, it's a one-user filesystem.\n            // user ID of owner\n            this.uid = 0;\n            // group ID of owner\n            this.gid = 0;\n            // XXX: Some file systems stash data on stats objects.\n            this.fileData = null;\n            this.size = size;\n            let currentTime = 0;\n            if (typeof (atimeMs) !== 'number') {\n                currentTime = Date.now();\n                atimeMs = currentTime;\n            }\n            if (typeof (mtimeMs) !== 'number') {\n                if (!currentTime) {\n                    currentTime = Date.now();\n                }\n                mtimeMs = currentTime;\n            }\n            if (typeof (ctimeMs) !== 'number') {\n                if (!currentTime) {\n                    currentTime = Date.now();\n                }\n                ctimeMs = currentTime;\n            }\n            if (typeof (birthtimeMs) !== 'number') {\n                if (!currentTime) {\n                    currentTime = Date.now();\n                }\n                birthtimeMs = currentTime;\n            }\n            this.atimeMs = atimeMs;\n            this.ctimeMs = ctimeMs;\n            this.mtimeMs = mtimeMs;\n            this.birthtimeMs = birthtimeMs;\n            if (!mode) {\n                switch (itemType) {\n                    case FileType.FILE:\n                        this.mode = 0x1a4;\n                        break;\n                    case FileType.DIRECTORY:\n                    default:\n                        this.mode = 0x1ff;\n                }\n            }\n            else {\n                this.mode = mode;\n            }\n            // number of 512B blocks allocated\n            this.blocks = Math.ceil(size / 512);\n            // Check if mode also includes top-most bits, which indicate the file's\n            // type.\n            if (this.mode < 0x1000) {\n                this.mode |= itemType;\n            }\n        }\n        static fromBuffer(buffer) {\n            const size = buffer.readUInt32LE(0), mode = buffer.readUInt32LE(4), atime = buffer.readDoubleLE(8), mtime = buffer.readDoubleLE(16), ctime = buffer.readDoubleLE(24);\n            return new Stats(mode & 0xF000, size, mode & 0xFFF, atime, mtime, ctime);\n        }\n        /**\n         * Clones the stats object.\n         */\n        static clone(s) {\n            return new Stats(s.mode & 0xF000, s.size, s.mode & 0xFFF, s.atimeMs, s.mtimeMs, s.ctimeMs, s.birthtimeMs);\n        }\n        get atime() {\n            return new Date(this.atimeMs);\n        }\n        get mtime() {\n            return new Date(this.mtimeMs);\n        }\n        get ctime() {\n            return new Date(this.ctimeMs);\n        }\n        get birthtime() {\n            return new Date(this.birthtimeMs);\n        }\n        toBuffer() {\n            const buffer = Buffer.alloc(32);\n            buffer.writeUInt32LE(this.size, 0);\n            buffer.writeUInt32LE(this.mode, 4);\n            buffer.writeDoubleLE(this.atime.getTime(), 8);\n            buffer.writeDoubleLE(this.mtime.getTime(), 16);\n            buffer.writeDoubleLE(this.ctime.getTime(), 24);\n            return buffer;\n        }\n        /**\n         * @return [Boolean] True if this item is a file.\n         */\n        isFile() {\n            return (this.mode & 0xF000) === FileType.FILE;\n        }\n        /**\n         * @return [Boolean] True if this item is a directory.\n         */\n        isDirectory() {\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\n        }\n        /**\n         * @return [Boolean] True if this item is a symbolic link (only valid through lstat)\n         */\n        isSymbolicLink() {\n            return (this.mode & 0xF000) === FileType.SYMLINK;\n        }\n        /**\n         * Change the mode of the file. We use this helper function to prevent messing\n         * up the type of the file, which is encoded in mode.\n         */\n        chmod(mode) {\n            this.mode = (this.mode & 0xF000) | mode;\n        }\n        // We don't support the following types of files.\n        isSocket() {\n            return false;\n        }\n        isBlockDevice() {\n            return false;\n        }\n        isCharacterDevice() {\n            return false;\n        }\n        isFIFO() {\n            return false;\n        }\n    }\n\n\n    return {\n        FileType,\n        Stats\n    }\n});\ndefine('skylark-browserfs/core/global',[],function () {\n    'use strict';\n    const toExport = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global;\n    return toExport;\n});\ndefine('skylark-browserfs/generic/setImmediate',['../core/global'], function (global) {\n    'use strict';\n    /**\n     * @hidden\n     */\n    let bfsSetImmediate;\n    if (typeof (setImmediate) !== \"undefined\") {\n        bfsSetImmediate = setImmediate;\n    }\n    else {\n        const gScope = global;\n        const timeouts = [];\n        const messageName = \"zero-timeout-message\";\n        const canUsePostMessage = function () {\n            if (typeof gScope.importScripts !== 'undefined' || !gScope.postMessage) {\n                return false;\n            }\n            let postMessageIsAsync = true;\n            const oldOnMessage = gScope.onmessage;\n            gScope.onmessage = function () {\n                postMessageIsAsync = false;\n            };\n            gScope.postMessage('', '*');\n            gScope.onmessage = oldOnMessage;\n            return postMessageIsAsync;\n        };\n        if (canUsePostMessage()) {\n            bfsSetImmediate = function (fn) {\n                timeouts.push(fn);\n                gScope.postMessage(messageName, \"*\");\n            };\n            const handleMessage = function (event) {\n                if (event.source === self && event.data === messageName) {\n                    if (event.stopPropagation) {\n                        event.stopPropagation();\n                    }\n                    else {\n                        event.cancelBubble = true;\n                    }\n                    if (timeouts.length > 0) {\n                        const fn = timeouts.shift();\n                        return fn();\n                    }\n                }\n            };\n            if (gScope.addEventListener) {\n                gScope.addEventListener('message', handleMessage, true);\n            }\n            else {\n                gScope.attachEvent('onmessage', handleMessage);\n            }\n        }\n        else if (gScope.MessageChannel) {\n            // WebWorker MessageChannel\n            const channel = new gScope.MessageChannel();\n            channel.port1.onmessage = (event) => {\n                if (timeouts.length > 0) {\n                    return timeouts.shift()();\n                }\n            };\n            bfsSetImmediate = (fn) => {\n                timeouts.push(fn);\n                channel.port2.postMessage('');\n            };\n        }\n        else {\n            bfsSetImmediate = function (fn) {\n                return setTimeout(fn, 0);\n            };\n        }\n    }\n\n    return bfsSetImmediate;\n});\ndefine('skylark-browserfs/core/FS',[\n    '../libs/buffers',\n    './api_error',\n    './file_flag',\n    '../libs/path',\n    './node_fs_stats',\n    '../generic/setImmediate'\n], function (buffers,api_error, file_flag, path, node_fs_stats, setImmediate) {\n    'use strict';\n\n    const { ApiError, ErrorCode } = api_error;\n    const { FileFlag } = file_flag;\n    const {Stats} = node_fs_stats;\n    const { Buffer } = buffers;\n\n    /** Used for unit testing. Defaults to a NOP. */\n    let wrapCbHook = function (cb, numArgs) {\n        return cb;\n    };\n    /**\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\n     * @hidden\n     */\n    function wrapCb(cb, numArgs) {\n        if (typeof cb !== 'function') {\n            throw new Error('Callback must be a function.');\n        }\n        const hookedCb = wrapCbHook(cb, numArgs);\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\n        // need to handle 1-3 arguments\n        switch (numArgs) {\n            case 1:\n                return function (arg1) {\n                    setImmediate(function () {\n                        return hookedCb(arg1);\n                    });\n                };\n            case 2:\n                return function (arg1, arg2) {\n                    setImmediate(function () {\n                        return hookedCb(arg1, arg2);\n                    });\n                };\n            case 3:\n                return function (arg1, arg2, arg3) {\n                    setImmediate(function () {\n                        return hookedCb(arg1, arg2, arg3);\n                    });\n                };\n            default:\n                throw new Error('Invalid invocation of wrapCb.');\n        }\n    }\n    /**\n     * @hidden\n     */\n    function assertRoot(fs) {\n        if (fs) {\n            return fs;\n        }\n        throw new ApiError(ErrorCode.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\n    }\n    /**\n     * @hidden\n     */\n    function normalizeMode(mode, def) {\n        switch (typeof mode) {\n            case 'number':\n                // (path, flag, mode, cb?)\n                return mode;\n            case 'string':\n                // (path, flag, modeString, cb?)\n                const trueMode = parseInt(mode, 8);\n                if (!isNaN(trueMode)) {\n                    return trueMode;\n                }\n                // Invalid string.\n                return def;\n            default:\n                return def;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function normalizeTime(time) {\n        if (time instanceof Date) {\n            return time;\n        }\n        else if (typeof time === 'number') {\n            return new Date(time * 1000);\n        }\n        else {\n            throw new ApiError(ErrorCode.EINVAL, `Invalid time.`);\n        }\n    }\n    /**\n     * @hidden\n     */\n    function normalizePath(p) {\n        // Node doesn't allow null characters in paths.\n        if (p.indexOf('\\u0000') >= 0) {\n            throw new ApiError(ErrorCode.EINVAL, 'Path must be a string without null bytes.');\n        }\n        else if (p === '') {\n            throw new ApiError(ErrorCode.EINVAL, 'Path must not be empty.');\n        }\n        return path.resolve(p);\n    }\n    /**\n     * @hidden\n     */\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\n        // typeof null === 'object' so special-case handing is needed.\n        switch (options === null ? 'null' : typeof options) {\n            case 'object':\n                return {\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\n                    mode: normalizeMode(options['mode'], defMode)\n                };\n            case 'string':\n                return {\n                    encoding: options,\n                    flag: defFlag,\n                    mode: defMode\n                };\n            case 'null':\n            case 'undefined':\n            case 'function':\n                return {\n                    encoding: defEnc,\n                    flag: defFlag,\n                    mode: defMode\n                };\n            default:\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\n        }\n    }\n    /**\n     * The default callback is a NOP.\n     * @hidden\n     * @private\n     */\n    function nopCb() {\n        // NOP.\n    }\n    /**\n     * The node frontend to all filesystems.\n     * This layer handles:\n     *\n     * * Sanity checking inputs.\n     * * Normalizing paths.\n     * * Resetting stack depth for asynchronous operations which may not go through\n     *   the browser by wrapping all input callbacks using `setImmediate`.\n     * * Performing the requested operation through the filesystem or the file\n     *   descriptor, as appropriate.\n     * * Handling optional arguments and setting default arguments.\n     * @see http://nodejs.org/api/fs.html\n     */\n    class FS {\n        constructor() {\n            /* tslint:enable:variable-name */\n            this.F_OK = 0;\n            this.R_OK = 4;\n            this.W_OK = 2;\n            this.X_OK = 1;\n            this.root = null;\n            this.fdMap = {};\n            this.nextFd = 100;\n        }\n        initialize(rootFS) {\n            if (!rootFS.constructor.isAvailable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\n            }\n            return this.root = rootFS;\n        }\n        /**\n         * converts Date or number to a fractional UNIX timestamp\n         * Grabbed from NodeJS sources (lib/fs.js)\n         */\n        _toUnixTimestamp(time) {\n            if (typeof time === 'number') {\n                return time;\n            }\n            else if (time instanceof Date) {\n                return time.getTime() / 1000;\n            }\n            throw new Error(\"Cannot parse time: \" + time);\n        }\n        /**\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\n         *   not been initialized.\n         */\n        getRootFS() {\n            if (this.root) {\n                return this.root;\n            }\n            else {\n                return null;\n            }\n        }\n        // FILE OR DIRECTORY METHODS\n        /**\n         * Asynchronous rename. No arguments other than a possible exception are given\n         * to the completion callback.\n         * @param oldPath\n         * @param newPath\n         * @param callback\n         */\n        rename(oldPath, newPath, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous rename.\n         * @param oldPath\n         * @param newPath\n         */\n        renameSync(oldPath, newPath) {\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\n        }\n        /**\n         * Test whether or not the given path exists by checking with the file system.\n         * Then call the callback argument with either true or false.\n         * @example Sample invocation\n         *   fs.exists('/etc/passwd', function (exists) {\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\n         *   });\n         * @param path\n         * @param callback\n         */\n        exists(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\n            }\n            catch (e) {\n                // Doesn't return an error. If something bad happens, we assume it just\n                // doesn't exist.\n                return newCb(false);\n            }\n        }\n        /**\n         * Test whether or not the given path exists by checking with the file system.\n         * @param path\n         * @return [boolean]\n         */\n        existsSync(path) {\n            try {\n                return assertRoot(this.root).existsSync(normalizePath(path));\n            }\n            catch (e) {\n                // Doesn't return an error. If something bad happens, we assume it just\n                // doesn't exist.\n                return false;\n            }\n        }\n        /**\n         * Asynchronous `stat`.\n         * @param path\n         * @param callback\n         */\n        stat(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `stat`.\n         * @param path\n         * @return [BrowserFS.node.fs.Stats]\n         */\n        statSync(path) {\n            return assertRoot(this.root).statSync(normalizePath(path), false);\n        }\n        /**\n         * Asynchronous `lstat`.\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n         * then the link itself is stat-ed, not the file that it refers to.\n         * @param path\n         * @param callback\n         */\n        lstat(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `lstat`.\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n         * then the link itself is stat-ed, not the file that it refers to.\n         * @param path\n         * @return [BrowserFS.node.fs.Stats]\n         */\n        lstatSync(path) {\n            return assertRoot(this.root).statSync(normalizePath(path), true);\n        }\n        truncate(path, arg2 = 0, cb = nopCb) {\n            let len = 0;\n            if (typeof arg2 === 'function') {\n                cb = arg2;\n            }\n            else if (typeof arg2 === 'number') {\n                len = arg2;\n            }\n            const newCb = wrapCb(cb, 1);\n            try {\n                if (len < 0) {\n                    throw new ApiError(ErrorCode.EINVAL);\n                }\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `truncate`.\n         * @param path\n         * @param len\n         */\n        truncateSync(path, len = 0) {\n            if (len < 0) {\n                throw new ApiError(ErrorCode.EINVAL);\n            }\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\n        }\n        /**\n         * Asynchronous `unlink`.\n         * @param path\n         * @param callback\n         */\n        unlink(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `unlink`.\n         * @param path\n         */\n        unlinkSync(path) {\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\n        }\n        open(path, flag, arg2, cb = nopCb) {\n            const mode = normalizeMode(arg2, 0x1a4);\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            const newCb = wrapCb(cb, 2);\n            try {\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\n                    if (file) {\n                        newCb(e, this.getFdForFile(file));\n                    }\n                    else {\n                        newCb(e);\n                    }\n                });\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous file open.\n         * @see http://www.manpagez.com/man/2/open/\n         * @param path\n         * @param flags\n         * @param mode defaults to `0644`\n         * @return [BrowserFS.File]\n         */\n        openSync(path, flag, mode = 0x1a4) {\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\n        }\n        readFile(filename, arg2 = {}, cb = nopCb) {\n            const options = normalizeOptions(arg2, null, 'r', null);\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            const newCb = wrapCb(cb, 2);\n            try {\n                const flag = FileFlag.getFileFlag(options['flag']);\n                if (!flag.isReadable()) {\n                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.'));\n                }\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        readFileSync(filename, arg2 = {}) {\n            const options = normalizeOptions(arg2, null, 'r', null);\n            const flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isReadable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.');\n            }\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\n        }\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                const flag = FileFlag.getFileFlag(options.flag);\n                if (!flag.isWriteable()) {\n                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.'));\n                }\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        writeFileSync(filename, data, arg3) {\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n            const flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isWriteable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.');\n            }\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n        }\n        appendFile(filename, data, arg3, cb = nopCb) {\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                const flag = FileFlag.getFileFlag(options.flag);\n                if (!flag.isAppendable()) {\n                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.'));\n                }\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        appendFileSync(filename, data, arg3) {\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n            const flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isAppendable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.');\n            }\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n        }\n        // FILE DESCRIPTOR METHODS\n        /**\n         * Asynchronous `fstat`.\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n         * specified by the file descriptor `fd`.\n         * @param fd\n         * @param callback\n         */\n        fstat(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                const file = this.fd2file(fd);\n                file.stat(newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `fstat`.\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n         * specified by the file descriptor `fd`.\n         * @param fd\n         * @return [BrowserFS.node.fs.Stats]\n         */\n        fstatSync(fd) {\n            return this.fd2file(fd).statSync();\n        }\n        /**\n         * Asynchronous close.\n         * @param fd\n         * @param callback\n         */\n        close(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                this.fd2file(fd).close((e) => {\n                    if (!e) {\n                        this.closeFd(fd);\n                    }\n                    newCb(e);\n                });\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous close.\n         * @param fd\n         */\n        closeSync(fd) {\n            this.fd2file(fd).closeSync();\n            this.closeFd(fd);\n        }\n        ftruncate(fd, arg2, cb = nopCb) {\n            const length = typeof arg2 === 'number' ? arg2 : 0;\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                const file = this.fd2file(fd);\n                if (length < 0) {\n                    throw new ApiError(ErrorCode.EINVAL);\n                }\n                file.truncate(length, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous ftruncate.\n         * @param fd\n         * @param len\n         */\n        ftruncateSync(fd, len = 0) {\n            const file = this.fd2file(fd);\n            if (len < 0) {\n                throw new ApiError(ErrorCode.EINVAL);\n            }\n            file.truncateSync(len);\n        }\n        /**\n         * Asynchronous fsync.\n         * @param fd\n         * @param callback\n         */\n        fsync(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                this.fd2file(fd).sync(newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous fsync.\n         * @param fd\n         */\n        fsyncSync(fd) {\n            this.fd2file(fd).syncSync();\n        }\n        /**\n         * Asynchronous fdatasync.\n         * @param fd\n         * @param callback\n         */\n        fdatasync(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                this.fd2file(fd).datasync(newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous fdatasync.\n         * @param fd\n         */\n        fdatasyncSync(fd) {\n            this.fd2file(fd).datasyncSync();\n        }\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\n            let buffer, offset, length, position = null;\n            if (typeof arg2 === 'string') {\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\n                let encoding = 'utf8';\n                switch (typeof arg3) {\n                    case 'function':\n                        // (fd, string, cb)\n                        cb = arg3;\n                        break;\n                    case 'number':\n                        // (fd, string, position, encoding?, cb?)\n                        position = arg3;\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\n                        break;\n                    default:\n                        // ...try to find the callback and get out of here!\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\n                        return cb(new ApiError(ErrorCode.EINVAL, 'Invalid arguments.'));\n                }\n                buffer = Buffer.from(arg2, encoding);\n                offset = 0;\n                length = buffer.length;\n            }\n            else {\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = typeof arg5 === 'number' ? arg5 : null;\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n            }\n            const newCb = wrapCb(cb, 3);\n            try {\n                const file = this.fd2file(fd);\n                if (position === undefined || position === null) {\n                    position = file.getPos();\n                }\n                file.write(buffer, offset, length, position, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        writeSync(fd, arg2, arg3, arg4, arg5) {\n            let buffer, offset = 0, length, position;\n            if (typeof arg2 === 'string') {\n                // Signature 1: (fd, string, [position?, [encoding?]])\n                position = typeof arg3 === 'number' ? arg3 : null;\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                offset = 0;\n                buffer = Buffer.from(arg2, encoding);\n                length = buffer.length;\n            }\n            else {\n                // Signature 2: (fd, buffer, offset, length, position?)\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = typeof arg5 === 'number' ? arg5 : null;\n            }\n            const file = this.fd2file(fd);\n            if (position === undefined || position === null) {\n                position = file.getPos();\n            }\n            return file.writeSync(buffer, offset, length, position);\n        }\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\n            let position, offset, length, buffer, newCb;\n            if (typeof arg2 === 'number') {\n                // legacy interface\n                // (fd, length, position, encoding, callback)\n                length = arg2;\n                position = arg3;\n                const encoding = arg4;\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n                offset = 0;\n                buffer = Buffer.alloc(length);\n                // XXX: Inefficient.\n                // Wrap the cb so we shelter upper layers of the API from these\n                // shenanigans.\n                newCb = wrapCb((err, bytesRead, buf) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    cb(err, buf.toString(encoding), bytesRead);\n                }, 3);\n            }\n            else {\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = arg5;\n                newCb = wrapCb(cb, 3);\n            }\n            try {\n                const file = this.fd2file(fd);\n                if (position === undefined || position === null) {\n                    position = file.getPos();\n                }\n                file.read(buffer, offset, length, position, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        readSync(fd, arg2, arg3, arg4, arg5) {\n            let shenanigans = false;\n            let buffer, offset, length, position, encoding = 'utf8';\n            if (typeof arg2 === 'number') {\n                length = arg2;\n                position = arg3;\n                encoding = arg4;\n                offset = 0;\n                buffer = Buffer.alloc(length);\n                shenanigans = true;\n            }\n            else {\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = arg5;\n            }\n            const file = this.fd2file(fd);\n            if (position === undefined || position === null) {\n                position = file.getPos();\n            }\n            const rv = file.readSync(buffer, offset, length, position);\n            if (!shenanigans) {\n                return rv;\n            }\n            else {\n                return [buffer.toString(encoding), rv];\n            }\n        }\n        /**\n         * Asynchronous `fchown`.\n         * @param fd\n         * @param uid\n         * @param gid\n         * @param callback\n         */\n        fchown(fd, uid, gid, callback = nopCb) {\n            const newCb = wrapCb(callback, 1);\n            try {\n                this.fd2file(fd).chown(uid, gid, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `fchown`.\n         * @param fd\n         * @param uid\n         * @param gid\n         */\n        fchownSync(fd, uid, gid) {\n            this.fd2file(fd).chownSync(uid, gid);\n        }\n        /**\n         * Asynchronous `fchmod`.\n         * @param fd\n         * @param mode\n         * @param callback\n         */\n        fchmod(fd, mode, cb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n                this.fd2file(fd).chmod(numMode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `fchmod`.\n         * @param fd\n         * @param mode\n         */\n        fchmodSync(fd, mode) {\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            this.fd2file(fd).chmodSync(numMode);\n        }\n        /**\n         * Change the file timestamps of a file referenced by the supplied file\n         * descriptor.\n         * @param fd\n         * @param atime\n         * @param mtime\n         * @param callback\n         */\n        futimes(fd, atime, mtime, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const file = this.fd2file(fd);\n                if (typeof atime === 'number') {\n                    atime = new Date(atime * 1000);\n                }\n                if (typeof mtime === 'number') {\n                    mtime = new Date(mtime * 1000);\n                }\n                file.utimes(atime, mtime, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Change the file timestamps of a file referenced by the supplied file\n         * descriptor.\n         * @param fd\n         * @param atime\n         * @param mtime\n         */\n        futimesSync(fd, atime, mtime) {\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\n        }\n        // DIRECTORY-ONLY METHODS\n        /**\n         * Asynchronous `rmdir`.\n         * @param path\n         * @param callback\n         */\n        rmdir(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).rmdir(path, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `rmdir`.\n         * @param path\n         */\n        rmdirSync(path) {\n            path = normalizePath(path);\n            return assertRoot(this.root).rmdirSync(path);\n        }\n        /**\n         * Asynchronous `mkdir`.\n         * @param path\n         * @param mode defaults to `0777`\n         * @param callback\n         */\n        mkdir(path, mode, cb = nopCb) {\n            if (typeof mode === 'function') {\n                cb = mode;\n                mode = 0x1ff;\n            }\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).mkdir(path, mode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `mkdir`.\n         * @param path\n         * @param mode defaults to `0777`\n         */\n        mkdirSync(path, mode) {\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\n        }\n        /**\n         * Asynchronous `readdir`. Reads the contents of a directory.\n         * The callback gets two arguments `(err, files)` where `files` is an array of\n         * the names of the files in the directory excluding `'.'` and `'..'`.\n         * @param path\n         * @param callback\n         */\n        readdir(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).readdir(path, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `readdir`. Reads the contents of a directory.\n         * @param path\n         * @return [String[]]\n         */\n        readdirSync(path) {\n            path = normalizePath(path);\n            return assertRoot(this.root).readdirSync(path);\n        }\n        // SYMLINK METHODS\n        /**\n         * Asynchronous `link`.\n         * @param srcpath\n         * @param dstpath\n         * @param callback\n         */\n        link(srcpath, dstpath, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                srcpath = normalizePath(srcpath);\n                dstpath = normalizePath(dstpath);\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `link`.\n         * @param srcpath\n         * @param dstpath\n         */\n        linkSync(srcpath, dstpath) {\n            srcpath = normalizePath(srcpath);\n            dstpath = normalizePath(dstpath);\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\n        }\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                if (type !== 'file' && type !== 'dir') {\n                    return newCb(new ApiError(ErrorCode.EINVAL, \"Invalid type: \" + type));\n                }\n                srcpath = normalizePath(srcpath);\n                dstpath = normalizePath(dstpath);\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `symlink`.\n         * @param srcpath\n         * @param dstpath\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\n         */\n        symlinkSync(srcpath, dstpath, type) {\n            if (!type) {\n                type = 'file';\n            }\n            else if (type !== 'file' && type !== 'dir') {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid type: \" + type);\n            }\n            srcpath = normalizePath(srcpath);\n            dstpath = normalizePath(dstpath);\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\n        }\n        /**\n         * Asynchronous readlink.\n         * @param path\n         * @param callback\n         */\n        readlink(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).readlink(path, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous readlink.\n         * @param path\n         * @return [String]\n         */\n        readlinkSync(path) {\n            path = normalizePath(path);\n            return assertRoot(this.root).readlinkSync(path);\n        }\n        // PROPERTY OPERATIONS\n        /**\n         * Asynchronous `chown`.\n         * @param path\n         * @param uid\n         * @param gid\n         * @param callback\n         */\n        chown(path, uid, gid, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `chown`.\n         * @param path\n         * @param uid\n         * @param gid\n         */\n        chownSync(path, uid, gid) {\n            path = normalizePath(path);\n            assertRoot(this.root).chownSync(path, false, uid, gid);\n        }\n        /**\n         * Asynchronous `lchown`.\n         * @param path\n         * @param uid\n         * @param gid\n         * @param callback\n         */\n        lchown(path, uid, gid, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `lchown`.\n         * @param path\n         * @param uid\n         * @param gid\n         */\n        lchownSync(path, uid, gid) {\n            path = normalizePath(path);\n            assertRoot(this.root).chownSync(path, true, uid, gid);\n        }\n        /**\n         * Asynchronous `chmod`.\n         * @param path\n         * @param mode\n         * @param callback\n         */\n        chmod(path, mode, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const numMode = normalizeMode(mode, -1);\n                if (numMode < 0) {\n                    throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n                }\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `chmod`.\n         * @param path\n         * @param mode\n         */\n        chmodSync(path, mode) {\n            const numMode = normalizeMode(mode, -1);\n            if (numMode < 0) {\n                throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n            }\n            path = normalizePath(path);\n            assertRoot(this.root).chmodSync(path, false, numMode);\n        }\n        /**\n         * Asynchronous `lchmod`.\n         * @param path\n         * @param mode\n         * @param callback\n         */\n        lchmod(path, mode, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const numMode = normalizeMode(mode, -1);\n                if (numMode < 0) {\n                    throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n                }\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `lchmod`.\n         * @param path\n         * @param mode\n         */\n        lchmodSync(path, mode) {\n            const numMode = normalizeMode(mode, -1);\n            if (numMode < 1) {\n                throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n            }\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\n        }\n        /**\n         * Change file timestamps of the file referenced by the supplied path.\n         * @param path\n         * @param atime\n         * @param mtime\n         * @param callback\n         */\n        utimes(path, atime, mtime, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Change file timestamps of the file referenced by the supplied path.\n         * @param path\n         * @param atime\n         * @param mtime\n         */\n        utimesSync(path, atime, mtime) {\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\n        }\n        realpath(path, arg2, cb = nopCb) {\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\n            const newCb = wrapCb(cb, 2);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).realpath(path, cache, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `realpath`.\n         * @param path\n         * @param cache An object literal of mapped paths that can be used to\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\n         *   known real paths.\n         * @return [String]\n         */\n        realpathSync(path, cache = {}) {\n            path = normalizePath(path);\n            return assertRoot(this.root).realpathSync(path, cache);\n        }\n        watchFile(filename, arg2, listener = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        unwatchFile(filename, listener = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        watch(filename, arg2, listener = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        access(path, arg2, cb = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        accessSync(path, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        createReadStream(path, options) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        createWriteStream(path, options) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\n         */\n        wrapCallbacks(cbWrapper) {\n            wrapCbHook = cbWrapper;\n        }\n        getFdForFile(file) {\n            const fd = this.nextFd++;\n            this.fdMap[fd] = file;\n            return fd;\n        }\n        fd2file(fd) {\n            const rv = this.fdMap[fd];\n            if (rv) {\n                return rv;\n            }\n            else {\n                throw new ApiError(ErrorCode.EBADF, 'Invalid file descriptor.');\n            }\n        }\n        closeFd(fd) {\n            delete this.fdMap[fd];\n        }\n    }\n    /* tslint:disable:variable-name */\n    // Exported fs.Stats.\n    FS.Stats = Stats;\n    //# sourceMappingURL=FS.js.map\n\n    return FS;\n});\ndefine('skylark-browserfs/core/node_fs',['./FS'], function (FS) {\n    'use strict';\n    let fs = new FS();\n    const _fsMock = {};\n    const fsProto = FS.prototype;\n    const keys = Object.getOwnPropertyNames(fsProto);\n    keys.forEach(key => {\n        if (typeof fs[key] === 'function') {\n            _fsMock[key] = function () {\n                return fs[key].apply(fs, arguments);\n            };\n        } else {\n            _fsMock[key] = fs[key];\n        }\n    });\n    _fsMock['changeFSModule'] = function (newFs) {\n        fs = newFs;\n    };\n    _fsMock['getFSModule'] = function () {\n        return fs;\n    };\n    _fsMock['FS'] = FS;\n    _fsMock['Stats'] = FS.Stats;\n\n    return _fsMock;\n});\ndefine('skylark-browserfs/core/levenshtein',[],function () {\n    'use strict';\n   \n    /*\n     * Levenshtein distance, from the `js-levenshtein` NPM module.\n     * Copied here to avoid complexity of adding another CommonJS module dependency.\n     */\n    function _min(d0, d1, d2, bx, ay) {\n        return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;\n    }\n\n    /**\n     * Calculates levenshtein distance.\n     * @param a\n     * @param b\n     */    \n     function levenshtein(a, b) {\n        if (a === b) {\n            return 0;\n        }\n        if (a.length > b.length) {\n            const tmp = a;\n            a = b;\n            b = tmp;\n        }\n        let la = a.length;\n        let lb = b.length;\n        while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n            la--;\n            lb--;\n        }\n        let offset = 0;\n        while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n            offset++;\n        }\n        la -= offset;\n        lb -= offset;\n        if (la === 0 || lb === 1) {\n            return lb;\n        }\n        const vector = new Array(la << 1);\n        for (let y = 0; y < la;) {\n            vector[la + y] = a.charCodeAt(offset + y);\n            vector[y] = ++y;\n        }\n        let x;\n        let d0;\n        let d1;\n        let d2;\n        let d3;\n        for (x = 0; x + 3 < lb;) {\n            const bx0 = b.charCodeAt(offset + (d0 = x));\n            const bx1 = b.charCodeAt(offset + (d1 = x + 1));\n            const bx2 = b.charCodeAt(offset + (d2 = x + 2));\n            const bx3 = b.charCodeAt(offset + (d3 = x + 3));\n            let dd = x += 4;\n            for (let y = 0; y < la;) {\n                const ay = vector[la + y];\n                const dy = vector[y];\n                d0 = _min(dy, d0, d1, bx0, ay);\n                d1 = _min(d0, d1, d2, bx1, ay);\n                d2 = _min(d1, d2, d3, bx2, ay);\n                dd = _min(d2, d3, dd, bx3, ay);\n                vector[y++] = dd;\n                d3 = d2;\n                d2 = d1;\n                d1 = d0;\n                d0 = dy;\n            }\n        }\n        let dd = 0;\n        for (; x < lb;) {\n            const bx0 = b.charCodeAt(offset + (d0 = x));\n            dd = ++x;\n            for (let y = 0; y < la; y++) {\n                const dy = vector[y];\n                vector[y] = dd = dy < d0 || dd < d0 ? dy > dd ? dd + 1 : dy + 1 : bx0 === vector[la + y] ? d0 : d0 + 1;\n                d0 = dy;\n            }\n        }\n        return dd;\n    }\n\n    return levenshtein;\n});\ndefine('skylark-browserfs/core/util',[\n    '../libs/buffers',\n    './api_error',\n    './levenshtein',\n    '../libs/path'\n], function (buffers,api_error, levenshtein, path) {\n    'use strict';\n\n    const { ErrorCode, ApiError } = api_error;\n    const {Buffer} = buffers;\n\n    function deprecationMessage(print, fsName, opts) {\n        if (print) {\n            // tslint:disable-next-line:no-console\n            console.warn(`[${fsName}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${fsName}.Create(${JSON.stringify(opts)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`);\n            // tslint:enable-next-line:no-console\n        }\n    }\n    /**\n     * Checks for any IE version, including IE11 which removed MSIE from the\n     * userAgent string.\n     * @hidden\n     */\n    const isIE = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\n    /**\n     * Check if we're in a web worker.\n     * @hidden\n     */\n    const isWebWorker = typeof window === \"undefined\";\n    /**\n     * Throws an exception. Called on code paths that should be impossible.\n     * @hidden\n     */\n    function fail() {\n        throw new Error(\"BFS has reached an impossible code path; please file a bug.\");\n    }\n    /**\n     * Synchronous recursive makedir.\n     * @hidden\n     */\n    function mkdirpSync(p, mode, fs) {\n        if (!fs.existsSync(p)) {\n            mkdirpSync(path.dirname(p), mode, fs);\n            fs.mkdirSync(p, mode);\n        }\n    }\n    /**\n     * Converts a buffer into an array buffer. Attempts to do so in a\n     * zero-copy manner, e.g. the array references the same memory.\n     * @hidden\n     */\n    function buffer2ArrayBuffer(buff) {\n        const u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;\n        if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\n            return u8.buffer;\n        }\n        else {\n            return u8.buffer.slice(u8offset, u8offset + u8Len);\n        }\n    }\n    /**\n     * Converts a buffer into a Uint8Array. Attempts to do so in a\n     * zero-copy manner, e.g. the array references the same memory.\n     * @hidden\n     */\n    function buffer2Uint8array(buff) {\n        if (buff instanceof Uint8Array) {\n            // BFS & Node v4.0 buffers *are* Uint8Arrays.\n            return buff;\n        }\n        else {\n            // Uint8Arrays can be constructed from arrayish numbers.\n            // At this point, we assume this isn't a BFS array.\n            return new Uint8Array(buff);\n        }\n    }\n    /**\n     * Converts the given arrayish object into a Buffer. Attempts to\n     * be zero-copy.\n     * @hidden\n     */\n    function arrayish2Buffer(arr) {\n        if (arr instanceof Buffer) {\n            return arr;\n        }\n        else if (arr instanceof Uint8Array) {\n            return uint8Array2Buffer(arr);\n        }\n        else {\n            return Buffer.from(arr);\n        }\n    }\n    /**\n     * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\n     * @hidden\n     */\n    function uint8Array2Buffer(u8) {\n        if (u8 instanceof Buffer) {\n            return u8;\n        }\n        else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\n            return arrayBuffer2Buffer(u8.buffer);\n        }\n        else {\n            return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);\n        }\n    }\n    /**\n     * Converts the given array buffer into a Buffer. Attempts to be\n     * zero-copy.\n     * @hidden\n     */\n    function arrayBuffer2Buffer(ab) {\n        return Buffer.from(ab);\n    }\n    /**\n     * Copies a slice of the given buffer\n     * @hidden\n     */\n    function copyingSlice(buff, start = 0, end = buff.length) {\n        if (start < 0 || end < 0 || end > buff.length || start > end) {\n            throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);\n        }\n        if (buff.length === 0) {\n            // Avoid s0 corner case in ArrayBuffer case.\n            return emptyBuffer();\n        }\n        else {\n            const u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;\n            buff[0] = newS0;\n            if (u8[0] === newS0) {\n                // Same memory. Revert & copy.\n                u8[0] = s0;\n                return uint8Array2Buffer(u8.slice(start, end));\n            }\n            else {\n                // Revert.\n                buff[0] = s0;\n                return uint8Array2Buffer(u8.subarray(start, end));\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    let emptyBuff = null;\n    /**\n     * Returns an empty buffer.\n     * @hidden\n     */\n    function emptyBuffer() {\n        if (emptyBuff) {\n            return emptyBuff;\n        }\n        return emptyBuff = Buffer.alloc(0);\n    }\n    /**\n     * Option validator for a Buffer file system option.\n     * @hidden\n     */\n    function bufferValidator(v, cb) {\n        if (Buffer.isBuffer(v)) {\n            cb();\n        }\n        else {\n            cb(new ApiError(ErrorCode.EINVAL, `option must be a Buffer.`));\n        }\n    }\n    /**\n     * Checks that the given options object is valid for the file system options.\n     * @hidden\n     */\n    function checkOptions(fsType, opts, cb) {\n        const optsInfo = fsType.Options;\n        const fsName = fsType.Name;\n        let pendingValidators = 0;\n        let callbackCalled = false;\n        let loopEnded = false;\n        function validatorCallback(e) {\n            if (!callbackCalled) {\n                if (e) {\n                    callbackCalled = true;\n                    cb(e);\n                }\n                pendingValidators--;\n                if (pendingValidators === 0 && loopEnded) {\n                    cb();\n                }\n            }\n        }\n        // Check for required options.\n        for (const optName in optsInfo) {\n            if (optsInfo.hasOwnProperty(optName)) {\n                const opt = optsInfo[optName];\n                const providedValue = opts[optName];\n                if (providedValue === undefined || providedValue === null) {\n                    if (!opt.optional) {\n                        // Required option, not provided.\n                        // Any incorrect options provided? Which ones are close to the provided one?\n                        // (edit distance 5 === close)\n                        const incorrectOptions = Object.keys(opts).filter((o) => !(o in optsInfo)).map((a) => {\n                            return { str: a, distance: levenshtein(optName, a) };\n                        }).filter((o) => o.distance < 5).sort((a, b) => a.distance - b.distance);\n                        // Validators may be synchronous.\n                        if (callbackCalled) {\n                            return;\n                        }\n                        callbackCalled = true;\n                        return cb(new ApiError(ErrorCode.EINVAL, `[${fsName}] Required option '${optName}' not provided.${incorrectOptions.length > 0 ? ` You provided unrecognized option '${incorrectOptions[0].str}'; perhaps you meant to type '${optName}'.` : ''}\\nOption description: ${opt.description}`));\n                    }\n                    // Else: Optional option, not provided. That is OK.\n                }\n                else {\n                    // Option provided! Check type.\n                    let typeMatches = false;\n                    if (Array.isArray(opt.type)) {\n                        typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;\n                    }\n                    else {\n                        typeMatches = typeof (providedValue) === opt.type;\n                    }\n                    if (!typeMatches) {\n                        // Validators may be synchronous.\n                        if (callbackCalled) {\n                            return;\n                        }\n                        callbackCalled = true;\n                        return cb(new ApiError(ErrorCode.EINVAL, `[${fsName}] Value provided for option ${optName} is not the proper type. Expected ${Array.isArray(opt.type) ? `one of {${opt.type.join(\", \")}}` : opt.type}, but received ${typeof (providedValue)}\\nOption description: ${opt.description}`));\n                    }\n                    else if (opt.validator) {\n                        pendingValidators++;\n                        opt.validator(providedValue, validatorCallback);\n                    }\n                    // Otherwise: All good!\n                }\n            }\n        }\n        loopEnded = true;\n        if (pendingValidators === 0 && !callbackCalled) {\n            cb();\n        }\n    }\n\n    return {\n        deprecationMessage: deprecationMessage,\n        isIE: isIE,\n        isWebWorker: isWebWorker,\n        fail: fail,\n        mkdirpSync: mkdirpSync,\n        buffer2ArrayBuffer: buffer2ArrayBuffer,\n        buffer2Uint8array: buffer2Uint8array,\n        arrayish2Buffer: arrayish2Buffer,\n        uint8Array2Buffer: uint8Array2Buffer,\n        arrayBuffer2Buffer: arrayBuffer2Buffer,\n        copyingSlice: copyingSlice,\n        emptyBuffer: emptyBuffer,\n        bufferValidator: bufferValidator,\n        checkOptions: checkOptions\n    };\n});\ndefine('skylark-browserfs/generic/emscripten_fs',[\n    '../core/node_fs',\n    '../core/util'\n], function (fs, util) {\n    'use strict';\n    const { uint8Array2Buffer } = util;\n\n    class BFSEmscriptenStreamOps {\n        constructor(fs) {\n            this.fs = fs;\n            this.nodefs = fs.getNodeFS();\n            this.FS = fs.getFS();\n            this.PATH = fs.getPATH();\n            this.ERRNO_CODES = fs.getERRNO_CODES();\n        }\n        open(stream) {\n            const path = this.fs.realPath(stream.node);\n            const FS = this.FS;\n            try {\n                if (FS.isFile(stream.node.mode)) {\n                    stream.nfd = this.nodefs.openSync(path, this.fs.flagsToPermissionString(stream.flags));\n                }\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        close(stream) {\n            const FS = this.FS;\n            try {\n                if (FS.isFile(stream.node.mode) && stream.nfd) {\n                    this.nodefs.closeSync(stream.nfd);\n                }\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        read(stream, buffer, offset, length, position) {\n            // Avoid copying overhead by reading directly into buffer.\n            try {\n                return this.nodefs.readSync(stream.nfd, uint8Array2Buffer(buffer), offset, length, position);\n            }\n            catch (e) {\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        write(stream, buffer, offset, length, position) {\n            // Avoid copying overhead.\n            try {\n                return this.nodefs.writeSync(stream.nfd, uint8Array2Buffer(buffer), offset, length, position);\n            }\n            catch (e) {\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        llseek(stream, offset, whence) {\n            let position = offset;\n            if (whence === 1) { // SEEK_CUR.\n                position += stream.position;\n            }\n            else if (whence === 2) { // SEEK_END.\n                if (this.FS.isFile(stream.node.mode)) {\n                    try {\n                        const stat = this.nodefs.fstatSync(stream.nfd);\n                        position += stat.size;\n                    }\n                    catch (e) {\n                        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n                    }\n                }\n            }\n            if (position < 0) {\n                throw new this.FS.ErrnoError(this.ERRNO_CODES.EINVAL);\n            }\n            stream.position = position;\n            return position;\n        }\n    }\n    class BFSEmscriptenNodeOps {\n        constructor(fs) {\n            this.fs = fs;\n            this.nodefs = fs.getNodeFS();\n            this.FS = fs.getFS();\n            this.PATH = fs.getPATH();\n            this.ERRNO_CODES = fs.getERRNO_CODES();\n        }\n        getattr(node) {\n            const path = this.fs.realPath(node);\n            let stat;\n            try {\n                stat = this.nodefs.lstatSync(path);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n            return {\n                dev: stat.dev,\n                ino: stat.ino,\n                mode: stat.mode,\n                nlink: stat.nlink,\n                uid: stat.uid,\n                gid: stat.gid,\n                rdev: stat.rdev,\n                size: stat.size,\n                atime: stat.atime,\n                mtime: stat.mtime,\n                ctime: stat.ctime,\n                blksize: stat.blksize,\n                blocks: stat.blocks\n            };\n        }\n        setattr(node, attr) {\n            const path = this.fs.realPath(node);\n            try {\n                if (attr.mode !== undefined) {\n                    this.nodefs.chmodSync(path, attr.mode);\n                    // update the common node structure mode as well\n                    node.mode = attr.mode;\n                }\n                if (attr.timestamp !== undefined) {\n                    const date = new Date(attr.timestamp);\n                    this.nodefs.utimesSync(path, date, date);\n                }\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                // Ignore not supported errors. Emscripten does utimesSync when it\n                // writes files, but never really requires the value to be set.\n                if (e.code !== \"ENOTSUP\") {\n                    throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n                }\n            }\n            if (attr.size !== undefined) {\n                try {\n                    this.nodefs.truncateSync(path, attr.size);\n                }\n                catch (e) {\n                    if (!e.code) {\n                        throw e;\n                    }\n                    throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n                }\n            }\n        }\n        lookup(parent, name) {\n            const path = this.PATH.join2(this.fs.realPath(parent), name);\n            const mode = this.fs.getMode(path);\n            return this.fs.createNode(parent, name, mode);\n        }\n        mknod(parent, name, mode, dev) {\n            const node = this.fs.createNode(parent, name, mode, dev);\n            // create the backing node for this in the fs root as well\n            const path = this.fs.realPath(node);\n            try {\n                if (this.FS.isDir(node.mode)) {\n                    this.nodefs.mkdirSync(path, node.mode);\n                }\n                else {\n                    this.nodefs.writeFileSync(path, '', { mode: node.mode });\n                }\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n            return node;\n        }\n        rename(oldNode, newDir, newName) {\n            const oldPath = this.fs.realPath(oldNode);\n            const newPath = this.PATH.join2(this.fs.realPath(newDir), newName);\n            try {\n                this.nodefs.renameSync(oldPath, newPath);\n                // This logic is missing from the original NodeFS,\n                // causing Emscripten's filesystem to think that the old file still exists.\n                oldNode.name = newName;\n                oldNode.parent = newDir;\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        unlink(parent, name) {\n            const path = this.PATH.join2(this.fs.realPath(parent), name);\n            try {\n                this.nodefs.unlinkSync(path);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        rmdir(parent, name) {\n            const path = this.PATH.join2(this.fs.realPath(parent), name);\n            try {\n                this.nodefs.rmdirSync(path);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        readdir(node) {\n            const path = this.fs.realPath(node);\n            try {\n                // Node does not list . and .. in directory listings,\n                // but Emscripten expects it.\n                const contents = this.nodefs.readdirSync(path);\n                contents.push('.', '..');\n                return contents;\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        symlink(parent, newName, oldPath) {\n            const newPath = this.PATH.join2(this.fs.realPath(parent), newName);\n            try {\n                this.nodefs.symlinkSync(oldPath, newPath);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        readlink(node) {\n            const path = this.fs.realPath(node);\n            try {\n                return this.nodefs.readlinkSync(path);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n    }\n    class BFSEmscriptenFS {\n        constructor(_FS = self['FS'], _PATH = self['PATH'], _ERRNO_CODES = self['ERRNO_CODES'], nodefs = fs) {\n            // This maps the integer permission modes from http://linux.die.net/man/3/open\n            // to node.js-specific file open permission strings at http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback\n            this.flagsToPermissionStringMap = {\n                0 /*O_RDONLY*/: 'r',\n                1 /*O_WRONLY*/: 'r+',\n                2 /*O_RDWR*/: 'r+',\n                64 /*O_CREAT*/: 'r',\n                65 /*O_WRONLY|O_CREAT*/: 'r+',\n                66 /*O_RDWR|O_CREAT*/: 'r+',\n                129 /*O_WRONLY|O_EXCL*/: 'rx+',\n                193 /*O_WRONLY|O_CREAT|O_EXCL*/: 'rx+',\n                514 /*O_RDWR|O_TRUNC*/: 'w+',\n                577 /*O_WRONLY|O_CREAT|O_TRUNC*/: 'w',\n                578 /*O_CREAT|O_RDWR|O_TRUNC*/: 'w+',\n                705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: 'wx',\n                706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: 'wx+',\n                1024 /*O_APPEND*/: 'a',\n                1025 /*O_WRONLY|O_APPEND*/: 'a',\n                1026 /*O_RDWR|O_APPEND*/: 'a+',\n                1089 /*O_WRONLY|O_CREAT|O_APPEND*/: 'a',\n                1090 /*O_RDWR|O_CREAT|O_APPEND*/: 'a+',\n                1153 /*O_WRONLY|O_EXCL|O_APPEND*/: 'ax',\n                1154 /*O_RDWR|O_EXCL|O_APPEND*/: 'ax+',\n                1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: 'ax',\n                1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: 'ax+',\n                4096 /*O_RDONLY|O_DSYNC*/: 'rs',\n                4098 /*O_RDWR|O_DSYNC*/: 'rs+'\n            };\n            this.nodefs = nodefs;\n            this.FS = _FS;\n            this.PATH = _PATH;\n            this.ERRNO_CODES = _ERRNO_CODES;\n            this.node_ops = new BFSEmscriptenNodeOps(this);\n            this.stream_ops = new BFSEmscriptenStreamOps(this);\n        }\n        mount(m) {\n            return this.createNode(null, '/', this.getMode(m.opts.root), 0);\n        }\n        createNode(parent, name, mode, dev) {\n            const FS = this.FS;\n            if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\n                throw new FS.ErrnoError(this.ERRNO_CODES.EINVAL);\n            }\n            const node = FS.createNode(parent, name, mode);\n            node.node_ops = this.node_ops;\n            node.stream_ops = this.stream_ops;\n            return node;\n        }\n        getMode(path) {\n            let stat;\n            try {\n                stat = this.nodefs.lstatSync(path);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n            return stat.mode;\n        }\n        realPath(node) {\n            const parts = [];\n            while (node.parent !== node) {\n                parts.push(node.name);\n                node = node.parent;\n            }\n            parts.push(node.mount.opts.root);\n            parts.reverse();\n            return this.PATH.join.apply(null, parts);\n        }\n        flagsToPermissionString(flags) {\n            let parsedFlags = (typeof flags === \"string\") ? parseInt(flags, 10) : flags;\n            parsedFlags &= 0x1FFF;\n            if (parsedFlags in this.flagsToPermissionStringMap) {\n                return this.flagsToPermissionStringMap[parsedFlags];\n            }\n            else {\n                return flags;\n            }\n        }\n        getNodeFS() {\n            return this.nodefs;\n        }\n        getFS() {\n            return this.FS;\n        }\n        getPATH() {\n            return this.PATH;\n        }\n        getERRNO_CODES() {\n            return this.ERRNO_CODES;\n        }\n    }\n\n    return BFSEmscriptenFS;\n});\ndefine('skylark-browserfs/core/file_system',[\n    '../libs/buffers',\n    './api_error',\n    './file_flag',\n    '../libs/path',\n    './util'\n], function (buffers,api_error, file_flag, path, util) {\n    'use strict';\n\n    const { ApiError, ErrorCode } = api_error;\n    const { FileFlag, ActionType } = file_flag;\n    const { fail } = util;\n\n    /**\n     * Basic filesystem class. Most filesystems should extend this class, as it\n     * provides default implementations for a handful of methods.\n     */\n    class BaseFileSystem {\n        supportsLinks() {\n            return false;\n        }\n        diskSpace(p, cb) {\n            cb(0, 0);\n        }\n        /**\n         * Opens the file at path p with the given flag. The file must exist.\n         * @param p The path to open.\n         * @param flag The flag to use when opening the file.\n         */\n        openFile(p, flag, cb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Create the file at path p with the given mode. Then, open it with the given\n         * flag.\n         */\n        createFile(p, flag, mode, cb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        open(p, flag, mode, cb) {\n            const mustBeFile = (e, stats) => {\n                if (e) {\n                    // File does not exist.\n                    switch (flag.pathNotExistsAction()) {\n                        case ActionType.CREATE_FILE:\n                            // Ensure parent exists.\n                            return this.stat(path.dirname(p), false, (e, parentStats) => {\n                                if (e) {\n                                    cb(e);\n                                }\n                                else if (parentStats && !parentStats.isDirectory()) {\n                                    cb(ApiError.ENOTDIR(path.dirname(p)));\n                                }\n                                else {\n                                    this.createFile(p, flag, mode, cb);\n                                }\n                            });\n                        case ActionType.THROW_EXCEPTION:\n                            return cb(ApiError.ENOENT(p));\n                        default:\n                            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n                    }\n                }\n                else {\n                    // File exists.\n                    if (stats && stats.isDirectory()) {\n                        return cb(ApiError.EISDIR(p));\n                    }\n                    switch (flag.pathExistsAction()) {\n                        case ActionType.THROW_EXCEPTION:\n                            return cb(ApiError.EEXIST(p));\n                        case ActionType.TRUNCATE_FILE:\n                            // NOTE: In a previous implementation, we deleted the file and\n                            // re-created it. However, this created a race condition if another\n                            // asynchronous request was trying to read the file, as the file\n                            // would not exist for a small period of time.\n                            return this.openFile(p, flag, (e, fd) => {\n                                if (e) {\n                                    cb(e);\n                                }\n                                else if (fd) {\n                                    fd.truncate(0, () => {\n                                        fd.sync(() => {\n                                            cb(null, fd);\n                                        });\n                                    });\n                                }\n                                else {\n                                    fail();\n                                }\n                            });\n                        case ActionType.NOP:\n                            return this.openFile(p, flag, cb);\n                        default:\n                            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n                    }\n                }\n            };\n            this.stat(p, false, mustBeFile);\n        }\n        rename(oldPath, newPath, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        renameSync(oldPath, newPath) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        stat(p, isLstat, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        statSync(p, isLstat) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Opens the file at path p with the given flag. The file must exist.\n         * @param p The path to open.\n         * @param flag The flag to use when opening the file.\n         * @return A File object corresponding to the opened file.\n         */\n        openFileSync(p, flag, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Create the file at path p with the given mode. Then, open it with the given\n         * flag.\n         */\n        createFileSync(p, flag, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        openSync(p, flag, mode) {\n            // Check if the path exists, and is a file.\n            let stats;\n            try {\n                stats = this.statSync(p, false);\n            }\n            catch (e) {\n                // File does not exist.\n                switch (flag.pathNotExistsAction()) {\n                    case ActionType.CREATE_FILE:\n                        // Ensure parent exists.\n                        const parentStats = this.statSync(path.dirname(p), false);\n                        if (!parentStats.isDirectory()) {\n                            throw ApiError.ENOTDIR(path.dirname(p));\n                        }\n                        return this.createFileSync(p, flag, mode);\n                    case ActionType.THROW_EXCEPTION:\n                        throw ApiError.ENOENT(p);\n                    default:\n                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n                }\n            }\n            // File exists.\n            if (stats.isDirectory()) {\n                throw ApiError.EISDIR(p);\n            }\n            switch (flag.pathExistsAction()) {\n                case ActionType.THROW_EXCEPTION:\n                    throw ApiError.EEXIST(p);\n                case ActionType.TRUNCATE_FILE:\n                    // Delete file.\n                    this.unlinkSync(p);\n                    // Create file. Use the same mode as the old file.\n                    // Node itself modifies the ctime when this occurs, so this action\n                    // will preserve that behavior if the underlying file system\n                    // supports those properties.\n                    return this.createFileSync(p, flag, stats.mode);\n                case ActionType.NOP:\n                    return this.openFileSync(p, flag, mode);\n                default:\n                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n            }\n        }\n        unlink(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        unlinkSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        rmdir(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        rmdirSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        mkdir(p, mode, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        mkdirSync(p, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        readdir(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        readdirSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        exists(p, cb) {\n            this.stat(p, null, function (err) {\n                cb(!err);\n            });\n        }\n        existsSync(p) {\n            try {\n                this.statSync(p, true);\n                return true;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        realpath(p, cache, cb) {\n            if (this.supportsLinks()) {\n                // The path could contain symlinks. Split up the path,\n                // resolve any symlinks, return the resolved string.\n                const splitPath = p.split(path.sep);\n                // TODO: Simpler to just pass through file, find sep and such.\n                for (let i = 0; i < splitPath.length; i++) {\n                    const addPaths = splitPath.slice(0, i + 1);\n                    splitPath[i] = path.join.apply(null, addPaths);\n                }\n            }\n            else {\n                // No symlinks. We just need to verify that it exists.\n                this.exists(p, function (doesExist) {\n                    if (doesExist) {\n                        cb(null, p);\n                    }\n                    else {\n                        cb(ApiError.ENOENT(p));\n                    }\n                });\n            }\n        }\n        realpathSync(p, cache) {\n            if (this.supportsLinks()) {\n                // The path could contain symlinks. Split up the path,\n                // resolve any symlinks, return the resolved string.\n                const splitPath = p.split(path.sep);\n                // TODO: Simpler to just pass through file, find sep and such.\n                for (let i = 0; i < splitPath.length; i++) {\n                    const addPaths = splitPath.slice(0, i + 1);\n                    splitPath[i] = path.join.apply(path, addPaths);\n                }\n                return splitPath.join(path.sep);\n            }\n            else {\n                // No symlinks. We just need to verify that it exists.\n                if (this.existsSync(p)) {\n                    return p;\n                }\n                else {\n                    throw ApiError.ENOENT(p);\n                }\n            }\n        }\n        truncate(p, len, cb) {\n            this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {\n                if (er) {\n                    return cb(er);\n                }\n                fd.truncate(len, (function (er) {\n                    fd.close((function (er2) {\n                        cb(er || er2);\n                    }));\n                }));\n            }));\n        }\n        truncateSync(p, len) {\n            const fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\n            // Need to safely close FD, regardless of whether or not truncate succeeds.\n            try {\n                fd.truncateSync(len);\n            }\n            catch (e) {\n                throw e;\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        readFile(fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, (err, fd) => {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (!err) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                fd.stat((err, stat) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    // Allocate buffer.\n                    const buf = Buffer.alloc(stat.size);\n                    fd.read(buf, 0, stat.size, 0, (err) => {\n                        if (err) {\n                            return cb(err);\n                        }\n                        else if (encoding === null) {\n                            return cb(err, buf);\n                        }\n                        try {\n                            cb(null, buf.toString(encoding));\n                        }\n                        catch (e) {\n                            cb(e);\n                        }\n                    });\n                });\n            });\n        }\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const stat = fd.statSync();\n                // Allocate buffer.\n                const buf = Buffer.alloc(stat.size);\n                fd.readSync(buf, 0, stat.size, 0);\n                fd.closeSync();\n                if (encoding === null) {\n                    return buf;\n                }\n                return buf.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        writeFile(fname, data, encoding, flag, mode, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err) {\n                    fd.close(function (err2) {\n                        oldCb(err ? err : err2);\n                    });\n                };\n                try {\n                    if (typeof data === 'string') {\n                        data = Buffer.from(data, encoding);\n                    }\n                }\n                catch (e) {\n                    return cb(e);\n                }\n                // Write into file.\n                fd.write(data, 0, data.length, 0, cb);\n            });\n        }\n        writeFileSync(fname, data, encoding, flag, mode) {\n            // Get file.\n            const fd = this.openSync(fname, flag, mode);\n            try {\n                if (typeof data === 'string') {\n                    data = Buffer.from(data, encoding);\n                }\n                // Write into file.\n                fd.writeSync(data, 0, data.length, 0);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        appendFile(fname, data, encoding, flag, mode, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            this.open(fname, flag, mode, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err) {\n                    fd.close(function (err2) {\n                        oldCb(err ? err : err2);\n                    });\n                };\n                if (typeof data === 'string') {\n                    data = Buffer.from(data, encoding);\n                }\n                fd.write(data, 0, data.length, null, cb);\n            });\n        }\n        appendFileSync(fname, data, encoding, flag, mode) {\n            const fd = this.openSync(fname, flag, mode);\n            try {\n                if (typeof data === 'string') {\n                    data = Buffer.from(data, encoding);\n                }\n                fd.writeSync(data, 0, data.length, null);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        chmod(p, isLchmod, mode, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        chmodSync(p, isLchmod, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        chownSync(p, isLchown, uid, gid) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        utimes(p, atime, mtime, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        utimesSync(p, atime, mtime) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        link(srcpath, dstpath, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        linkSync(srcpath, dstpath) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        symlinkSync(srcpath, dstpath, type) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        readlink(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        readlinkSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n    }\n    /**\n     * Implements the asynchronous API in terms of the synchronous API.\n     * @class SynchronousFileSystem\n     */\n    class SynchronousFileSystem extends BaseFileSystem {\n        supportsSynch() {\n            return true;\n        }\n        rename(oldPath, newPath, cb) {\n            try {\n                this.renameSync(oldPath, newPath);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        stat(p, isLstat, cb) {\n            try {\n                cb(null, this.statSync(p, isLstat));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        open(p, flags, mode, cb) {\n            try {\n                cb(null, this.openSync(p, flags, mode));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        unlink(p, cb) {\n            try {\n                this.unlinkSync(p);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        rmdir(p, cb) {\n            try {\n                this.rmdirSync(p);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        mkdir(p, mode, cb) {\n            try {\n                this.mkdirSync(p, mode);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readdir(p, cb) {\n            try {\n                cb(null, this.readdirSync(p));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        chmod(p, isLchmod, mode, cb) {\n            try {\n                this.chmodSync(p, isLchmod, mode);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            try {\n                this.chownSync(p, isLchown, uid, gid);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        utimes(p, atime, mtime, cb) {\n            try {\n                this.utimesSync(p, atime, mtime);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        link(srcpath, dstpath, cb) {\n            try {\n                this.linkSync(srcpath, dstpath);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            try {\n                this.symlinkSync(srcpath, dstpath, type);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readlink(p, cb) {\n            try {\n                cb(null, this.readlinkSync(p));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n    }\n\n\n    return {\n        BaseFileSystem: BaseFileSystem,\n        SynchronousFileSystem: SynchronousFileSystem\n    };\n});\ndefine('skylark-browserfs/core/file',['./api_error'], function (api_error) {\n    'use strict';\n\n    const { ApiError, ErrorCode } = api_error;\n    /**\n     * Base class that contains shared implementations of functions for the file\n     * object.\n     */\n    class BaseFile {\n        sync(cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        syncSync() {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        datasync(cb) {\n            this.sync(cb);\n        }\n        datasyncSync() {\n            return this.syncSync();\n        }\n        chown(uid, gid, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        chownSync(uid, gid) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        chmod(mode, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        chmodSync(mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        utimes(atime, mtime, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        utimesSync(atime, mtime) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n    }\n    return { BaseFile: BaseFile };\n});\ndefine('skylark-browserfs/generic/preload_file',[\n    '../libs/buffers',\n    '../core/file',\n    '../core/node_fs_stats',\n    '../core/api_error',\n    '../core/node_fs',\n    '../core/util'\n], function (buffers,file, Stats, api_error, fs, util) {\n    'use strict';\n\n    const { BaseFile } = file;\n    const { ApiError, ErrorCode } = api_error;\n    const { emptyBuffer } = util;\n    const { Buffer } = buffers;\n\n    /**\n     * An implementation of the File interface that operates on a file that is\n     * completely in-memory. PreloadFiles are backed by a Buffer.\n     *\n     * This is also an abstract class, as it lacks an implementation of 'sync' and\n     * 'close'. Each filesystem that wishes to use this file representation must\n     * extend this class and implement those two methods.\n     * @todo 'close' lever that disables functionality once closed.\n     */\n    class PreloadFile extends BaseFile {\n        /**\n         * Creates a file with the given path and, optionally, the given contents. Note\n         * that, if contents is specified, it will be mutated by the file!\n         * @param _fs The file system that created the file.\n         * @param _path\n         * @param _mode The mode that the file was opened using.\n         *   Dictates permissions and where the file pointer starts.\n         * @param _stat The stats object for the given file.\n         *   PreloadFile will mutate this object. Note that this object must contain\n         *   the appropriate mode that the file was opened as.\n         * @param contents A buffer containing the entire\n         *   contents of the file. PreloadFile will mutate this buffer. If not\n         *   specified, we assume it is a new file.\n         */\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super();\n            this._pos = 0;\n            this._dirty = false;\n            this._fs = _fs;\n            this._path = _path;\n            this._flag = _flag;\n            this._stat = _stat;\n            this._buffer = contents ? contents : emptyBuffer();\n            // Note: This invariant is *not* maintained once the file starts getting\n            // modified.\n            // Note: Only actually matters if file is readable, as writeable modes may\n            // truncate/append to file.\n            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\n                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\n            }\n        }\n        /**\n         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\n         */\n        getBuffer() {\n            return this._buffer;\n        }\n        /**\n         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\n         */\n        getStats() {\n            return this._stat;\n        }\n        getFlag() {\n            return this._flag;\n        }\n        /**\n         * Get the path to this file.\n         * @return [String] The path to the file.\n         */\n        getPath() {\n            return this._path;\n        }\n        /**\n         * Get the current file position.\n         *\n         * We emulate the following bug mentioned in the Node documentation:\n         * > On Linux, positional writes don't work when the file is opened in append\n         *   mode. The kernel ignores the position argument and always appends the data\n         *   to the end of the file.\n         * @return [Number] The current file position.\n         */\n        getPos() {\n            if (this._flag.isAppendable()) {\n                return this._stat.size;\n            }\n            return this._pos;\n        }\n        /**\n         * Advance the current file position by the indicated number of positions.\n         * @param [Number] delta\n         */\n        advancePos(delta) {\n            return this._pos += delta;\n        }\n        /**\n         * Set the file position.\n         * @param [Number] newPos\n         */\n        setPos(newPos) {\n            return this._pos = newPos;\n        }\n        /**\n         * **Core**: Asynchronous sync. Must be implemented by subclasses of this\n         * class.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        sync(cb) {\n            try {\n                this.syncSync();\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * **Core**: Synchronous sync.\n         */\n        syncSync() {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * **Core**: Asynchronous close. Must be implemented by subclasses of this\n         * class.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        close(cb) {\n            try {\n                this.closeSync();\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * **Core**: Synchronous close.\n         */\n        closeSync() {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Asynchronous `stat`.\n         * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb\n         */\n        stat(cb) {\n            try {\n                cb(null, Stats.clone(this._stat));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Synchronous `stat`.\n         */\n        statSync() {\n            return Stats.clone(this._stat);\n        }\n        /**\n         * Asynchronous truncate.\n         * @param [Number] len\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        truncate(len, cb) {\n            try {\n                this.truncateSync(len);\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\n                    this.sync(cb);\n                }\n                cb();\n            }\n            catch (e) {\n                return cb(e);\n            }\n        }\n        /**\n         * Synchronous truncate.\n         * @param [Number] len\n         */\n        truncateSync(len) {\n            this._dirty = true;\n            if (!this._flag.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n            }\n            this._stat.mtimeMs = Date.now();\n            if (len > this._buffer.length) {\n                const buf = Buffer.alloc(len - this._buffer.length, 0);\n                // Write will set @_stat.size for us.\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\n                    this.syncSync();\n                }\n                return;\n            }\n            this._stat.size = len;\n            // Truncate buffer to 'len'.\n            const newBuff = Buffer.alloc(len);\n            this._buffer.copy(newBuff, 0, 0, len);\n            this._buffer = newBuff;\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\n                this.syncSync();\n            }\n        }\n        /**\n         * Write buffer to the file.\n         * Note that it is unsafe to use fs.write multiple times on the same file\n         * without waiting for the callback.\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n         *  the file.\n         * @param [Number] offset Offset in the buffer to start reading data from.\n         * @param [Number] length The amount of bytes to write to the file.\n         * @param [Number] position Offset from the beginning of the file where this\n         *   data should be written. If position is null, the data will be written at\n         *   the current position.\n         * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]\n         *   cb The number specifies the number of bytes written into the file.\n         */\n        write(buffer, offset, length, position, cb) {\n            try {\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Write buffer to the file.\n         * Note that it is unsafe to use fs.writeSync multiple times on the same file\n         * without waiting for the callback.\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n         *  the file.\n         * @param [Number] offset Offset in the buffer to start reading data from.\n         * @param [Number] length The amount of bytes to write to the file.\n         * @param [Number] position Offset from the beginning of the file where this\n         *   data should be written. If position is null, the data will be written at\n         *   the current position.\n         * @return [Number]\n         */\n        writeSync(buffer, offset, length, position) {\n            this._dirty = true;\n            if (position === undefined || position === null) {\n                position = this.getPos();\n            }\n            if (!this._flag.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n            }\n            const endFp = position + length;\n            if (endFp > this._stat.size) {\n                this._stat.size = endFp;\n                if (endFp > this._buffer.length) {\n                    // Extend the buffer!\n                    const newBuff = Buffer.alloc(endFp);\n                    this._buffer.copy(newBuff);\n                    this._buffer = newBuff;\n                }\n            }\n            const len = buffer.copy(this._buffer, position, offset, offset + length);\n            this._stat.mtimeMs = Date.now();\n            if (this._flag.isSynchronous()) {\n                this.syncSync();\n                return len;\n            }\n            this.setPos(position + len);\n            return len;\n        }\n        /**\n         * Read data from the file.\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n         *   written to.\n         * @param [Number] offset The offset within the buffer where writing will\n         *   start.\n         * @param [Number] length An integer specifying the number of bytes to read.\n         * @param [Number] position An integer specifying where to begin reading from\n         *   in the file. If position is null, data will be read from the current file\n         *   position.\n         * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The\n         *   number is the number of bytes read\n         */\n        read(buffer, offset, length, position, cb) {\n            try {\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Read data from the file.\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n         *   written to.\n         * @param [Number] offset The offset within the buffer where writing will\n         *   start.\n         * @param [Number] length An integer specifying the number of bytes to read.\n         * @param [Number] position An integer specifying where to begin reading from\n         *   in the file. If position is null, data will be read from the current file\n         *   position.\n         * @return [Number]\n         */\n        readSync(buffer, offset, length, position) {\n            if (!this._flag.isReadable()) {\n                throw new ApiError(ErrorCode.EPERM, 'File not opened with a readable mode.');\n            }\n            if (position === undefined || position === null) {\n                position = this.getPos();\n            }\n            const endRead = position + length;\n            if (endRead > this._stat.size) {\n                length = this._stat.size - position;\n            }\n            const rv = this._buffer.copy(buffer, offset, position, position + length);\n            this._stat.atimeMs = Date.now();\n            this._pos = position + length;\n            return rv;\n        }\n        /**\n         * Asynchronous `fchmod`.\n         * @param [Number|String] mode\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        chmod(mode, cb) {\n            try {\n                this.chmodSync(mode);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Asynchronous `fchmod`.\n         * @param [Number] mode\n         */\n        chmodSync(mode) {\n            if (!this._fs.supportsProps()) {\n                throw new ApiError(ErrorCode.ENOTSUP);\n            }\n            this._dirty = true;\n            this._stat.chmod(mode);\n            this.syncSync();\n        }\n        isDirty() {\n            return this._dirty;\n        }\n        /**\n         * Resets the dirty bit. Should only be called after a sync has completed successfully.\n         */\n        resetDirty() {\n            this._dirty = false;\n        }\n    }\n    /**\n     * File class for the InMemory and XHR file systems.\n     * Doesn't sync to anything, so it works nicely for memory-only files.\n     */\n    class NoSyncFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        /**\n         * Asynchronous sync. Doesn't do anything, simply calls the cb.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        sync(cb) {\n            cb();\n        }\n        /**\n         * Synchronous sync. Doesn't do anything.\n         */\n        syncSync() {\n            // NOP.\n        }\n        /**\n         * Asynchronous close. Doesn't do anything, simply calls the cb.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        close(cb) {\n            cb();\n        }\n        /**\n         * Synchronous close. Doesn't do anything.\n         */\n        closeSync() {\n            // NOP.\n        }\n    }\n\n    return {\n        PreloadFile,\n        NoSyncFile\n    }\n});\ndefine('skylark-browserfs/backend/AsyncMirror',[\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../generic/preload_file',\n    '../libs/path'\n], function (file_system, api_error, file_flag, preload_file, path) {\n    'use strict';\n\n\n    const  { SynchronousFileSystem } = file_system;\n    const { ApiError, ErrorCode } = api_error;\n    const { FileFlag } = file_flag;\n    const { PreloadFile} = preload_file;\n\n    /**\n     * We define our own file to interpose on syncSync() for mirroring purposes.\n     */\n    class MirrorFile extends PreloadFile {\n        constructor(fs, path, flag, stat, data) {\n            super(fs, path, flag, stat, data);\n        }\n        syncSync() {\n            if (this.isDirty()) {\n                this._fs._syncSync(this);\n                this.resetDirty();\n            }\n        }\n        closeSync() {\n            this.syncSync();\n        }\n    }\n    /**\n     * AsyncMirrorFS mirrors a synchronous filesystem into an asynchronous filesystem\n     * by:\n     *\n     * * Performing operations over the in-memory copy, while asynchronously pipelining them\n     *   to the backing store.\n     * * During application loading, the contents of the async file system can be reloaded into\n     *   the synchronous store, if desired.\n     *\n     * The two stores will be kept in sync. The most common use-case is to pair a synchronous\n     * in-memory filesystem with an asynchronous backing store.\n     *\n     * Example: Mirroring an IndexedDB file system to an in memory file system. Now, you can use\n     * IndexedDB synchronously.\n     *\n     * ```javascript\n     * BrowserFS.configure({\n     *   fs: \"AsyncMirror\",\n     *   options: {\n     *     sync: { fs: \"InMemory\" },\n     *     async: { fs: \"IndexedDB\" }\n     *   }\n     * }, function(e) {\n     *   // BrowserFS is initialized and ready-to-use!\n     * });\n     * ```\n     *\n     * Or, alternatively:\n     *\n     * ```javascript\n     * BrowserFS.FileSystem.IndexedDB.Create(function(e, idbfs) {\n     *   BrowserFS.FileSystem.InMemory.Create(function(e, inMemory) {\n     *     BrowserFS.FileSystem.AsyncMirror({\n     *       sync: inMemory, async: idbfs\n     *     }, function(e, mirrored) {\n     *       BrowserFS.initialize(mirrored);\n     *     });\n     *   });\n     * });\n     * ```\n     */\n    class AsyncMirror extends SynchronousFileSystem {\n        /**\n         * **Deprecated; use AsyncMirror.Create() method instead.**\n         *\n         * Mirrors the synchronous file system into the asynchronous file system.\n         *\n         * **IMPORTANT**: You must call `initialize` on the file system before it can be used.\n         * @param sync The synchronous file system to mirror the asynchronous file system to.\n         * @param async The asynchronous file system to mirror.\n         */\n        constructor(sync, async) {\n            super();\n            /**\n             * Queue of pending asynchronous operations.\n             */\n            this._queue = [];\n            this._queueRunning = false;\n            this._isInitialized = false;\n            this._initializeCallbacks = [];\n            this._sync = sync;\n            this._async = async;\n        }\n        /**\n         * Constructs and initializes an AsyncMirror file system with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                const fs = new AsyncMirror(opts.sync, opts.async);\n                fs._initialize((e) => {\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        cb(null, fs);\n                    }\n                });\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() {\n            return true;\n        }\n        getName() {\n            return AsyncMirror.Name;\n        }\n        _syncSync(fd) {\n            this._sync.writeFileSync(fd.getPath(), fd.getBuffer(), null, FileFlag.getFileFlag('w'), fd.getStats().mode);\n            this.enqueueOp({\n                apiMethod: 'writeFile',\n                arguments: [fd.getPath(), fd.getBuffer(), null, fd.getFlag(), fd.getStats().mode]\n            });\n        }\n        isReadOnly() { return false; }\n        supportsSynch() { return true; }\n        supportsLinks() { return false; }\n        supportsProps() { return this._sync.supportsProps() && this._async.supportsProps(); }\n        renameSync(oldPath, newPath) {\n            this._sync.renameSync(oldPath, newPath);\n            this.enqueueOp({\n                apiMethod: 'rename',\n                arguments: [oldPath, newPath]\n            });\n        }\n        statSync(p, isLstat) {\n            return this._sync.statSync(p, isLstat);\n        }\n        openSync(p, flag, mode) {\n            // Sanity check: Is this open/close permitted?\n            const fd = this._sync.openSync(p, flag, mode);\n            fd.closeSync();\n            return new MirrorFile(this, p, flag, this._sync.statSync(p, false), this._sync.readFileSync(p, null, FileFlag.getFileFlag('r')));\n        }\n        unlinkSync(p) {\n            this._sync.unlinkSync(p);\n            this.enqueueOp({\n                apiMethod: 'unlink',\n                arguments: [p]\n            });\n        }\n        rmdirSync(p) {\n            this._sync.rmdirSync(p);\n            this.enqueueOp({\n                apiMethod: 'rmdir',\n                arguments: [p]\n            });\n        }\n        mkdirSync(p, mode) {\n            this._sync.mkdirSync(p, mode);\n            this.enqueueOp({\n                apiMethod: 'mkdir',\n                arguments: [p, mode]\n            });\n        }\n        readdirSync(p) {\n            return this._sync.readdirSync(p);\n        }\n        existsSync(p) {\n            return this._sync.existsSync(p);\n        }\n        chmodSync(p, isLchmod, mode) {\n            this._sync.chmodSync(p, isLchmod, mode);\n            this.enqueueOp({\n                apiMethod: 'chmod',\n                arguments: [p, isLchmod, mode]\n            });\n        }\n        chownSync(p, isLchown, uid, gid) {\n            this._sync.chownSync(p, isLchown, uid, gid);\n            this.enqueueOp({\n                apiMethod: 'chown',\n                arguments: [p, isLchown, uid, gid]\n            });\n        }\n        utimesSync(p, atime, mtime) {\n            this._sync.utimesSync(p, atime, mtime);\n            this.enqueueOp({\n                apiMethod: 'utimes',\n                arguments: [p, atime, mtime]\n            });\n        }\n        /**\n         * Called once to load up files from async storage into sync storage.\n         */\n        _initialize(userCb) {\n            const callbacks = this._initializeCallbacks;\n            const end = (e) => {\n                this._isInitialized = !e;\n                this._initializeCallbacks = [];\n                callbacks.forEach((cb) => cb(e));\n            };\n            if (!this._isInitialized) {\n                // First call triggers initialization, the rest wait.\n                if (callbacks.push(userCb) === 1) {\n                    const copyDirectory = (p, mode, cb) => {\n                        if (p !== '/') {\n                            this._sync.mkdirSync(p, mode);\n                        }\n                        this._async.readdir(p, (err, files) => {\n                            let i = 0;\n                            // NOTE: This function must not be in a lexically nested statement,\n                            // such as an if or while statement. Safari refuses to run the\n                            // script since it is undefined behavior.\n                            function copyNextFile(err) {\n                                if (err) {\n                                    cb(err);\n                                }\n                                else if (i < files.length) {\n                                    copyItem(path.join(p, files[i]), copyNextFile);\n                                    i++;\n                                }\n                                else {\n                                    cb();\n                                }\n                            }\n                            if (err) {\n                                cb(err);\n                            }\n                            else {\n                                copyNextFile();\n                            }\n                        });\n                    }, copyFile = (p, mode, cb) => {\n                        this._async.readFile(p, null, FileFlag.getFileFlag('r'), (err, data) => {\n                            if (err) {\n                                cb(err);\n                            }\n                            else {\n                                try {\n                                    this._sync.writeFileSync(p, data, null, FileFlag.getFileFlag('w'), mode);\n                                }\n                                catch (e) {\n                                    err = e;\n                                }\n                                finally {\n                                    cb(err);\n                                }\n                            }\n                        });\n                    }, copyItem = (p, cb) => {\n                        this._async.stat(p, false, (err, stats) => {\n                            if (err) {\n                                cb(err);\n                            }\n                            else if (stats.isDirectory()) {\n                                copyDirectory(p, stats.mode, cb);\n                            }\n                            else {\n                                copyFile(p, stats.mode, cb);\n                            }\n                        });\n                    };\n                    copyDirectory('/', 0, end);\n                }\n            }\n            else {\n                userCb();\n            }\n        }\n        enqueueOp(op) {\n            this._queue.push(op);\n            if (!this._queueRunning) {\n                this._queueRunning = true;\n                const doNextOp = (err) => {\n                    if (err) {\n                        throw new Error(`WARNING: File system has desynchronized. Received following error: ${err}\\n$`);\n                    }\n                    if (this._queue.length > 0) {\n                        const op = this._queue.shift(), args = op.arguments;\n                        args.push(doNextOp);\n                        this._async[op.apiMethod].apply(this._async, args);\n                    }\n                    else {\n                        this._queueRunning = false;\n                    }\n                };\n                doNextOp();\n            }\n        }\n    }\n    AsyncMirror.Name = \"AsyncMirror\";\n    AsyncMirror.Options = {\n        sync: {\n            type: \"object\",\n            description: \"The synchronous file system to mirror the asynchronous file system to.\",\n            validator: (v, cb) => {\n                if (v && typeof (v['supportsSynch']) === \"function\" && v.supportsSynch()) {\n                    cb();\n                }\n                else {\n                    cb(new ApiError(ErrorCode.EINVAL, `'sync' option must be a file system that supports synchronous operations`));\n                }\n            }\n        },\n        async: {\n            type: \"object\",\n            description: \"The asynchronous file system to mirror.\"\n        }\n    };\n\n    return AsyncMirror;\n});\ndefine('skylark-browserfs/backend/Dropbox',[\n    '../libs/buffers',\n    '../generic/preload_file',\n    '../core/file_system',\n    '../core/node_fs_stats',\n    '../core/api_error',\n    '../core/util',\n///    'dropbox_bridge',\n    '../generic/setImmediate',\n    '../libs/path'\n], function (buffers,preload_file, file_system, node_fs_stats, api_error, util,  setImmediate, path) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { Stats, FileType } = node_fs_stats;\n    const { ApiError, ErrorCode } = api_error;\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer } =  util;\n///    const { Dropbox } =  dropbox_bridge;\n    const { dirname } =  path;\n\n    const { PreloadFile} = preload_file;\n\n    const {Buffer} = buffers;\n\n\n    /**\n     * Dropbox paths do not begin with a /, they just begin with a folder at the root node.\n     * Here, we strip the `/`.\n     * @param p An absolute path\n     */\n    function FixPath(p) {\n        if (p === '/') {\n            return '';\n        }\n        else {\n            return p;\n        }\n    }\n    /**\n     * HACK: Dropbox errors are FUBAR'd sometimes.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @param e\n     */\n    function ExtractTheFuckingError(e) {\n        const obj = e.error;\n        if (obj['.tag']) {\n            // Everything is OK.\n            return obj;\n        }\n        else if (obj['error']) {\n            // Terrible nested object bug.\n            const obj2 = obj.error;\n            if (obj2['.tag']) {\n                return obj2;\n            }\n            else if (obj2['reason'] && obj2['reason']['.tag']) {\n                return obj2.reason;\n            }\n            else {\n                return obj2;\n            }\n        }\n        else if (typeof (obj) === 'string') {\n            // Might be a fucking JSON object error.\n            try {\n                const obj2 = JSON.parse(obj);\n                if (obj2['error'] && obj2['error']['reason'] && obj2['error']['reason']['.tag']) {\n                    return obj2.error.reason;\n                }\n            }\n            catch (e) {\n                // Nope. Give up.\n            }\n        }\n        return obj;\n    }\n    /**\n     * Returns a user-facing error message given an error.\n     *\n     * HACK: Dropbox error messages sometimes lack a `user_message` field.\n     * Sometimes, they are even strings. Ugh.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/145\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/144\n     * @param err An error.\n     */\n    function GetErrorMessage(err) {\n        if (err['user_message']) {\n            return err.user_message.text;\n        }\n        else if (err['error_summary']) {\n            return err.error_summary;\n        }\n        else if (typeof (err.error) === \"string\") {\n            return err.error;\n        }\n        else if (typeof (err.error) === \"object\") {\n            // DROPBOX BUG: Sometimes, error is a nested error.\n            return GetErrorMessage(err.error);\n        }\n        else {\n            throw new Error(`Dropbox's servers gave us a garbage error message: ${JSON.stringify(err)}`);\n        }\n    }\n    function LookupErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n                return new ApiError(ErrorCode.EBADF, msg, p);\n            case 'not_found':\n                return ApiError.ENOENT(p);\n            case 'not_file':\n                return ApiError.EISDIR(p);\n            case 'not_folder':\n                return ApiError.ENOTDIR(p);\n            case 'restricted_content':\n                return ApiError.EPERM(p);\n            case 'other':\n            default:\n                return new ApiError(ErrorCode.EIO, msg, p);\n        }\n    }\n    function WriteErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n            case 'disallowed_name':\n                return new ApiError(ErrorCode.EBADF, msg, p);\n            case 'conflict':\n            case 'no_write_permission':\n            case 'team_folder':\n                return ApiError.EPERM(p);\n            case 'insufficient_space':\n                return new ApiError(ErrorCode.ENOSPC, msg);\n            case 'other':\n            default:\n                return new ApiError(ErrorCode.EIO, msg, p);\n        }\n    }\n    function FilesDeleteWrapped(client, p, cb) {\n        const arg = {\n            path: FixPath(p)\n        };\n        client.filesDeleteV2(arg)\n            .then(() => {\n            cb();\n        }).catch((e) => {\n            const err = ExtractTheFuckingError(e);\n            switch (err['.tag']) {\n                case 'path_lookup':\n                    cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));\n                    break;\n                case 'path_write':\n                    cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));\n                    break;\n                case 'too_many_write_operations':\n                    setTimeout(() => FilesDeleteWrapped(client, p, cb), 500 + (300 * (Math.random())));\n                    break;\n                case 'other':\n                default:\n                    cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));\n                    break;\n            }\n        });\n    }\n    class DropboxFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        sync(cb) {\n            this._fs._syncFile(this.getPath(), this.getBuffer(), cb);\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n    }\n    /**\n     * A read/write file system backed by Dropbox cloud storage.\n     *\n     * Uses the Dropbox V2 API, and the 2.x JS SDK.\n     */\n    class DropboxFileSystem extends BaseFileSystem {\n        constructor(client) {\n            super();\n            this._client = client;\n        }\n        /**\n         * Creates a new DropboxFileSystem instance with the given options.\n         * Must be given an *authenticated* Dropbox client from 2.x JS SDK.\n         */\n        static Create(opts, cb) {\n            cb(null, new DropboxFileSystem(opts.client));\n        }\n        static isAvailable() {\n            // Checks if the Dropbox library is loaded.\n            return typeof Dropbox !== 'undefined';\n        }\n        getName() {\n            return DropboxFileSystem.Name;\n        }\n        isReadOnly() {\n            return false;\n        }\n        // Dropbox doesn't support symlinks, properties, or synchronous calls\n        // TODO: does it???\n        supportsSymlinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return false;\n        }\n        /**\n         * Deletes *everything* in the file system. Mainly intended for unit testing!\n         * @param mainCb Called when operation completes.\n         */\n        empty(mainCb) {\n            this.readdir('/', (e, paths) => {\n                if (paths) {\n                    const next = (e) => {\n                        if (paths.length === 0) {\n                            mainCb();\n                        }\n                        else {\n                            FilesDeleteWrapped(this._client, paths.shift(), next);\n                        }\n                    };\n                    next();\n                }\n                else {\n                    mainCb(e);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            // Dropbox doesn't let you rename things over existing things, but POSIX does.\n            // So, we need to see if newPath exists...\n            this.stat(newPath, false, (e, stats) => {\n                const rename = () => {\n                    const relocationArg = {\n                        from_path: FixPath(oldPath),\n                        to_path: FixPath(newPath)\n                    };\n                    this._client.filesMoveV2(relocationArg)\n                        .then(() => cb())\n                        .catch(function (e) {\n                        const err = ExtractTheFuckingError(e);\n                        switch (err['.tag']) {\n                            case 'from_lookup':\n                                cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'from_write':\n                                cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'to':\n                                cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));\n                                break;\n                            case 'cant_copy_shared_folder':\n                            case 'cant_nest_shared_folder':\n                                cb(new ApiError(ErrorCode.EPERM, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'cant_move_folder_into_itself':\n                            case 'duplicated_or_nested_paths':\n                                cb(new ApiError(ErrorCode.EBADF, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'too_many_files':\n                                cb(new ApiError(ErrorCode.ENOSPC, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'other':\n                            default:\n                                cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), oldPath));\n                                break;\n                        }\n                    });\n                };\n                if (e) {\n                    // Doesn't exist. Proceed!\n                    rename();\n                }\n                else if (oldPath === newPath) {\n                    // NOP if the path exists. Error if it doesn't exist.\n                    if (e) {\n                        cb(ApiError.ENOENT(newPath));\n                    }\n                    else {\n                        cb();\n                    }\n                }\n                else if (stats && stats.isDirectory()) {\n                    // Exists, is a directory. Cannot rename over an existing directory.\n                    cb(ApiError.EISDIR(newPath));\n                }\n                else {\n                    // Exists, is a file, and differs from oldPath. Delete and rename.\n                    this.unlink(newPath, (e) => {\n                        if (e) {\n                            cb(e);\n                        }\n                        else {\n                            rename();\n                        }\n                    });\n                }\n            });\n        }\n        stat(path, isLstat, cb) {\n            if (path === '/') {\n                // Dropbox doesn't support querying the root directory.\n                setImmediate(function () {\n                    cb(null, new Stats(FileType.DIRECTORY, 4096));\n                });\n                return;\n            }\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesGetMetadata(arg).then((ref) => {\n                switch (ref['.tag']) {\n                    case 'file':\n                        const fileMetadata = ref;\n                        // TODO: Parse time fields.\n                        cb(null, new Stats(FileType.FILE, fileMetadata.size));\n                        break;\n                    case 'folder':\n                        cb(null, new Stats(FileType.DIRECTORY, 4096));\n                        break;\n                    case 'deleted':\n                        cb(ApiError.ENOENT(path));\n                        break;\n                    default:\n                        // Unknown.\n                        break;\n                }\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        cb(LookupErrorToError(err.path, path, GetErrorMessage(e)));\n                        break;\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        openFile(path, flags, cb) {\n            const downloadArg = {\n                path: FixPath(path)\n            };\n            this._client.filesDownload(downloadArg).then((res) => {\n                const b = res.fileBlob;\n                const fr = new FileReader();\n                fr.onload = () => {\n                    const ab = fr.result;\n                    cb(null, new DropboxFile(this, path, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));\n                };\n                fr.readAsArrayBuffer(b);\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const dpError = err;\n                        cb(LookupErrorToError(dpError.path, path, GetErrorMessage(e)));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        createFile(p, flags, mode, cb) {\n            const fileData = Buffer.alloc(0);\n            const blob = new Blob([buffer2ArrayBuffer(fileData)], { type: \"octet/stream\" });\n            const commitInfo = {\n                contents: blob,\n                path: FixPath(p)\n            };\n            this._client.filesUpload(commitInfo).then((metadata) => {\n                cb(null, new DropboxFile(this, p, flags, new Stats(FileType.FILE, 0), fileData));\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        // Retry in (500, 800) ms.\n                        setTimeout(() => this.createFile(p, flags, mode, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n        /**\n         * Delete a file\n         */\n        unlink(path, cb) {\n            // Must be a file. Check first.\n            this.stat(path, false, (e, stat) => {\n                if (stat) {\n                    if (stat.isDirectory()) {\n                        cb(ApiError.EISDIR(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Delete a directory\n         */\n        rmdir(path, cb) {\n            this.readdir(path, (e, paths) => {\n                if (paths) {\n                    if (paths.length > 0) {\n                        cb(ApiError.ENOTEMPTY(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Create a directory\n         */\n        mkdir(p, mode, cb) {\n            // Dropbox's create_folder is recursive. Check if parent exists.\n            const parent = dirname(p);\n            this.stat(parent, false, (e, stats) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (stats && !stats.isDirectory()) {\n                    cb(ApiError.ENOTDIR(parent));\n                }\n                else {\n                    const arg = {\n                        path: FixPath(p)\n                    };\n                    this._client.filesCreateFolderV2(arg).then(() => cb()).catch((e) => {\n                        const err = ExtractTheFuckingError(e);\n                        if (err['.tag'] === \"too_many_write_operations\") {\n                            // Retry in a bit.\n                            setTimeout(() => this.mkdir(p, mode, cb), 500 + (300 * (Math.random())));\n                        }\n                        else {\n                            cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Get the names of the files in a directory\n         */\n        readdir(path, cb) {\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesListFolder(arg).then((res) => {\n                ContinueReadingDir(this._client, path, res, [], cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n        /**\n         * (Internal) Syncs file to Dropbox.\n         */\n        _syncFile(p, d, cb) {\n            const blob = new Blob([buffer2ArrayBuffer(d)], { type: \"octet/stream\" });\n            const arg = {\n                contents: blob,\n                path: FixPath(p),\n                mode: {\n                    '.tag': 'overwrite'\n                }\n            };\n            this._client.filesUpload(arg).then(() => {\n                cb();\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        setTimeout(() => this._syncFile(p, d, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n    }\n    DropboxFileSystem.Name = \"DropboxV2\";\n    DropboxFileSystem.Options = {\n        client: {\n            type: \"object\",\n            description: \"An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK.\"\n        }\n    };\n    function ProcessListFolderError(e, path, cb) {\n        const err = ExtractTheFuckingError(e);\n        switch (err['.tag']) {\n            case 'path':\n                const pathError = err;\n                cb(LookupErrorToError(pathError.path, path, GetErrorMessage(e)));\n                break;\n            case 'other':\n            default:\n                cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));\n                break;\n        }\n    }\n    function ContinueReadingDir(client, path, res, previousEntries, cb) {\n        const newEntries = res.entries.map((e) => e.path_display).filter((p) => !!p);\n        const entries = previousEntries.concat(newEntries);\n        if (!res.has_more) {\n            cb(null, entries);\n        }\n        else {\n            const arg = {\n                cursor: res.cursor\n            };\n            client.filesListFolderContinue(arg).then((res) => {\n                ContinueReadingDir(client, path, res, entries, cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n    }\n\n    DropboxFileSystem.DropboxFile = DropboxFile;\n\n    return  DropboxFileSystem;\n    \n});\ndefine('skylark-browserfs/backend/Emscripten',[\n    '../libs/buffers',\n    '../core/file_system',\n    '../core/node_fs_stats',\n    '../core/file',\n    '../core/util',\n    '../core/api_error'\n], function (buffers,file_system, node_fs_stats, file, util, api_error) {\n    'use strict';\n\n    const { SynchronousFileSystem } = file_system;\n    const { Stats, FileType } = node_fs_stats;\n    const { BaseFile } = file;\n    const { uint8Array2Buffer, buffer2Uint8array } = util;\n    const { ApiError, ErrorCode, ErrorStrings } = api_error;\n    const { Buffer } = buffers;\n\n    /**\n     * @hidden\n     */\n    function convertError(e, path = '') {\n        const errno = e.errno;\n        let parent = e.node;\n        const paths = [];\n        while (parent) {\n            paths.unshift(parent.name);\n            if (parent === parent.parent) {\n                break;\n            }\n            parent = parent.parent;\n        }\n        return new ApiError(errno, ErrorStrings[errno], paths.length > 0 ? '/' + paths.join('/') : path);\n    }\n    class EmscriptenFile extends BaseFile {\n        constructor(_fs, _FS, _path, _stream) {\n            super();\n            this._fs = _fs;\n            this._FS = _FS;\n            this._path = _path;\n            this._stream = _stream;\n        }\n        getPos() {\n            return undefined;\n        }\n        close(cb) {\n            let err = null;\n            try {\n                this.closeSync();\n            }\n            catch (e) {\n                err = e;\n            }\n            finally {\n                cb(err);\n            }\n        }\n        closeSync() {\n            try {\n                this._FS.close(this._stream);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        stat(cb) {\n            try {\n                cb(null, this.statSync());\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        statSync() {\n            try {\n                return this._fs.statSync(this._path, false);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        truncate(len, cb) {\n            let err = null;\n            try {\n                this.truncateSync(len);\n            }\n            catch (e) {\n                err = e;\n            }\n            finally {\n                cb(err);\n            }\n        }\n        truncateSync(len) {\n            try {\n                this._FS.ftruncate(this._stream.fd, len);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        write(buffer, offset, length, position, cb) {\n            try {\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        writeSync(buffer, offset, length, position) {\n            try {\n                const u8 = buffer2Uint8array(buffer);\n                // Emscripten is particular about what position is set to.\n                const emPosition = position === null ? undefined : position;\n                return this._FS.write(this._stream, u8, offset, length, emPosition);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        read(buffer, offset, length, position, cb) {\n            try {\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readSync(buffer, offset, length, position) {\n            try {\n                const u8 = buffer2Uint8array(buffer);\n                // Emscripten is particular about what position is set to.\n                const emPosition = position === null ? undefined : position;\n                return this._FS.read(this._stream, u8, offset, length, emPosition);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        sync(cb) {\n            // NOP.\n            cb();\n        }\n        syncSync() {\n            // NOP.\n        }\n        chown(uid, gid, cb) {\n            let err = null;\n            try {\n                this.chownSync(uid, gid);\n            }\n            catch (e) {\n                err = e;\n            }\n            finally {\n                cb(err);\n            }\n        }\n        chownSync(uid, gid) {\n            try {\n                this._FS.fchown(this._stream.fd, uid, gid);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        chmod(mode, cb) {\n            let err = null;\n            try {\n                this.chmodSync(mode);\n            }\n            catch (e) {\n                err = e;\n            }\n            finally {\n                cb(err);\n            }\n        }\n        chmodSync(mode) {\n            try {\n                this._FS.fchmod(this._stream.fd, mode);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        utimes(atime, mtime, cb) {\n            let err = null;\n            try {\n                this.utimesSync(atime, mtime);\n            }\n            catch (e) {\n                err = e;\n            }\n            finally {\n                cb(err);\n            }\n        }\n        utimesSync(atime, mtime) {\n            this._fs.utimesSync(this._path, atime, mtime);\n        }\n    }\n    /**\n     * Mounts an Emscripten file system into the BrowserFS file system.\n     */\n    class EmscriptenFileSystem extends SynchronousFileSystem {\n        constructor(_FS) {\n            super();\n            this._FS = _FS;\n        }\n        /**\n         * Create an EmscriptenFileSystem instance with the given options.\n         */\n        static Create(opts, cb) {\n            cb(null, new EmscriptenFileSystem(opts.FS));\n        }\n        static isAvailable() { return true; }\n        getName() { return this._FS.DB_NAME(); }\n        isReadOnly() { return false; }\n        supportsLinks() { return true; }\n        supportsProps() { return true; }\n        supportsSynch() { return true; }\n        renameSync(oldPath, newPath) {\n            try {\n                this._FS.rename(oldPath, newPath);\n            }\n            catch (e) {\n                if (e.errno === ErrorCode.ENOENT) {\n                    throw convertError(e, this.existsSync(oldPath) ? newPath : oldPath);\n                }\n                else {\n                    throw convertError(e);\n                }\n            }\n        }\n        statSync(p, isLstat) {\n            try {\n                const stats = isLstat ? this._FS.lstat(p) : this._FS.stat(p);\n                const itemType = this.modeToFileType(stats.mode);\n                return new Stats(itemType, stats.size, stats.mode, stats.atime.getTime(), stats.mtime.getTime(), stats.ctime.getTime());\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        openSync(p, flag, mode) {\n            try {\n                const stream = this._FS.open(p, flag.getFlagString(), mode);\n                if (this._FS.isDir(stream.node.mode)) {\n                    this._FS.close(stream);\n                    throw ApiError.EISDIR(p);\n                }\n                return new EmscriptenFile(this, this._FS, p, stream);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        unlinkSync(p) {\n            try {\n                this._FS.unlink(p);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        rmdirSync(p) {\n            try {\n                this._FS.rmdir(p);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        mkdirSync(p, mode) {\n            try {\n                this._FS.mkdir(p, mode);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        readdirSync(p) {\n            try {\n                // Emscripten returns items for '.' and '..'. Node does not.\n                return this._FS.readdir(p).filter((p) => p !== '.' && p !== '..');\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        truncateSync(p, len) {\n            try {\n                this._FS.truncate(p, len);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        readFileSync(p, encoding, flag) {\n            try {\n                const data = this._FS.readFile(p, { flags: flag.getFlagString() });\n                const buff = uint8Array2Buffer(data);\n                if (encoding) {\n                    return buff.toString(encoding);\n                }\n                else {\n                    return buff;\n                }\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        writeFileSync(p, data, encoding, flag, mode) {\n            try {\n                if (encoding) {\n                    data = Buffer.from(data, encoding);\n                }\n                const u8 = buffer2Uint8array(data);\n                this._FS.writeFile(p, u8, { flags: flag.getFlagString(), encoding: 'binary' });\n                this._FS.chmod(p, mode);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        chmodSync(p, isLchmod, mode) {\n            try {\n                isLchmod ? this._FS.lchmod(p, mode) : this._FS.chmod(p, mode);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        chownSync(p, isLchown, uid, gid) {\n            try {\n                isLchown ? this._FS.lchown(p, uid, gid) : this._FS.chown(p, uid, gid);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        symlinkSync(srcpath, dstpath, type) {\n            try {\n                this._FS.symlink(srcpath, dstpath);\n            }\n            catch (e) {\n                throw convertError(e);\n            }\n        }\n        readlinkSync(p) {\n            try {\n                return this._FS.readlink(p);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        utimesSync(p, atime, mtime) {\n            try {\n                this._FS.utime(p, atime.getTime(), mtime.getTime());\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        modeToFileType(mode) {\n            if (this._FS.isDir(mode)) {\n                return FileType.DIRECTORY;\n            }\n            else if (this._FS.isFile(mode)) {\n                return FileType.FILE;\n            }\n            else if (this._FS.isLink(mode)) {\n                return FileType.SYMLINK;\n            }\n            else {\n                throw ApiError.EPERM(`Invalid mode: ${mode}`);\n            }\n        }\n    }\n    EmscriptenFileSystem.Name = \"EmscriptenFileSystem\";\n    EmscriptenFileSystem.Options = {\n        FS: {\n            type: \"object\",\n            description: \"The Emscripten file system to use (the `FS` variable)\"\n        }\n    };\n\n    EmscriptenFileSystem.EmscriptenFile = EmscriptenFile;\n\n    return EmscriptenFileSystem;\n});\ndefine('skylark-browserfs/backend/FolderAdapter',[\n    '../core/file_system',\n    '../libs/path',\n    '../core/api_error'\n], function (file_system, path, api_error) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError } = api_error;\n\n    /**\n     * The FolderAdapter file system wraps a file system, and scopes all interactions to a subfolder of that file system.\n     *\n     * Example: Given a file system `foo` with folder `bar` and file `bar/baz`...\n     *\n     * ```javascript\n     * BrowserFS.configure({\n     *   fs: \"FolderAdapter\",\n     *   options: {\n     *     folder: \"bar\",\n     *     wrapped: foo\n     *   }\n     * }, function(e) {\n     *   var fs = BrowserFS.BFSRequire('fs');\n     *   fs.readdirSync('/'); // ['baz']\n     * });\n     * ```\n     */\n    class FolderAdapter extends BaseFileSystem {\n        constructor(folder, wrapped) {\n            super();\n            this._folder = folder;\n            this._wrapped = wrapped;\n        }\n        /**\n         * Creates a FolderAdapter instance with the given options.\n         */\n        static Create(opts, cb) {\n            const fa = new FolderAdapter(opts.folder, opts.wrapped);\n            fa._initialize(function (e) {\n                if (e) {\n                    cb(e);\n                }\n                else {\n                    cb(null, fa);\n                }\n            });\n        }\n        static isAvailable() {\n            return true;\n        }\n        getName() { return this._wrapped.getName(); }\n        isReadOnly() { return this._wrapped.isReadOnly(); }\n        supportsProps() { return this._wrapped.supportsProps(); }\n        supportsSynch() { return this._wrapped.supportsSynch(); }\n        supportsLinks() { return false; }\n        /**\n         * Initialize the file system. Ensures that the wrapped file system\n         * has the given folder.\n         */\n        _initialize(cb) {\n            this._wrapped.exists(this._folder, (exists) => {\n                if (exists) {\n                    cb();\n                }\n                else if (this._wrapped.isReadOnly()) {\n                    cb(ApiError.ENOENT(this._folder));\n                }\n                else {\n                    this._wrapped.mkdir(this._folder, 0x1ff, cb);\n                }\n            });\n        }\n    }\n    FolderAdapter.Name = \"FolderAdapter\";\n    FolderAdapter.Options = {\n        folder: {\n            type: \"string\",\n            description: \"The folder to use as the root directory\"\n        },\n        wrapped: {\n            type: \"object\",\n            description: \"The file system to wrap\"\n        }\n    };\n    /**\n     * @hidden\n     */\n    function translateError(folder, e) {\n        if (e !== null && typeof e === 'object') {\n            const err = e;\n            let p = err.path;\n            if (p) {\n                p = '/' + path.relative(folder, p);\n                err.message = err.message.replace(err.path, p);\n                err.path = p;\n            }\n        }\n        return e;\n    }\n    /**\n     * @hidden\n     */\n    function wrapCallback(folder, cb) {\n        if (typeof cb === 'function') {\n            return function (err) {\n                if (arguments.length > 0) {\n                    arguments[0] = translateError(folder, err);\n                }\n                cb.apply(null, arguments);\n            };\n        }\n        else {\n            return cb;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function wrapFunction(name, wrapFirst, wrapSecond) {\n        if (name.slice(name.length - 4) !== 'Sync') {\n            // Async function. Translate error in callback.\n            return function () {\n                if (arguments.length > 0) {\n                    if (wrapFirst) {\n                        arguments[0] = path.join(this._folder, arguments[0]);\n                    }\n                    if (wrapSecond) {\n                        arguments[1] = path.join(this._folder, arguments[1]);\n                    }\n                    arguments[arguments.length - 1] = wrapCallback(this._folder, arguments[arguments.length - 1]);\n                }\n                return this._wrapped[name].apply(this._wrapped, arguments);\n            };\n        }\n        else {\n            // Sync function. Translate error in catch.\n            return function () {\n                try {\n                    if (wrapFirst) {\n                        arguments[0] = path.join(this._folder, arguments[0]);\n                    }\n                    if (wrapSecond) {\n                        arguments[1] = path.join(this._folder, arguments[1]);\n                    }\n                    return this._wrapped[name].apply(this._wrapped, arguments);\n                }\n                catch (e) {\n                    throw translateError(this._folder, e);\n                }\n            };\n        }\n    }\n    // First argument is a path.\n    ['diskSpace', 'stat', 'statSync', 'open', 'openSync', 'unlink', 'unlinkSync',\n        'rmdir', 'rmdirSync', 'mkdir', 'mkdirSync', 'readdir', 'readdirSync', 'exists',\n        'existsSync', 'realpath', 'realpathSync', 'truncate', 'truncateSync', 'readFile',\n        'readFileSync', 'writeFile', 'writeFileSync', 'appendFile', 'appendFileSync',\n        'chmod', 'chmodSync', 'chown', 'chownSync', 'utimes', 'utimesSync', 'readlink',\n        'readlinkSync'].forEach((name) => {\n        FolderAdapter.prototype[name] = wrapFunction(name, true, false);\n    });\n    // First and second arguments are paths.\n    ['rename', 'renameSync', 'link', 'linkSync', 'symlink', 'symlinkSync'].forEach((name) => {\n        FolderAdapter.prototype[name] = wrapFunction(name, true, true);\n    });\n\n    return FolderAdapter;\n});\ndefine('skylark-browserfs/backend/HTML5FS',[\n    \"skylark-langx-async\",\n    '../generic/preload_file',\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/node_fs_stats',\n    '../libs/path',\n    '../core/global',\n    '../core/util'\n], function (async,preload_file, file_system, api_error, file_flag, node_fs_stats, path, global, util) {\n    'use strict';\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode } = api_error;\n    const { ActionType } = file_flag;\n    const { Stats, FileType } = node_fs_stats;\n    const asyncEach = async.each;\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = util;\n\n    const { PreloadFile} = preload_file;\n\n    /**\n     * @hidden\n     */\n    function isDirectoryEntry(entry) {\n        return entry.isDirectory;\n    }\n    /**\n     * @hidden\n     */\n    const _getFS = global.webkitRequestFileSystem || global.requestFileSystem || null;\n    /**\n     * @hidden\n     */\n    function _requestQuota(type, size, success, errorCallback) {\n        // We cast navigator and window to '<any>' because everything here is\n        // nonstandard functionality, despite the fact that Chrome has the only\n        // implementation of the HTML5FS and is likely driving the standardization\n        // process. Thus, these objects defined off of navigator and window are not\n        // present in the DefinitelyTyped TypeScript typings for FileSystem.\n        if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {\n            switch (type) {\n                case global.PERSISTENT:\n                    navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);\n                    break;\n                case global.TEMPORARY:\n                    navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);\n                    break;\n                default:\n                    errorCallback(new TypeError(`Invalid storage type: ${type}`));\n                    break;\n            }\n        }\n        else {\n            global.webkitStorageInfo.requestQuota(type, size, success, errorCallback);\n        }\n    }\n    /**\n     * @hidden\n     */\n    function _toArray(list) {\n        return Array.prototype.slice.call(list || [], 0);\n    }\n    /**\n     * Converts the given DOMError into an appropriate ApiError.\n     * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n     * @hidden\n     */\n    function convertError(err, p, expectedDir) {\n        switch (err.name) {\n            /* The user agent failed to create a file or directory due to the existence of a file or\n                directory with the same path.  */\n            case \"PathExistsError\":\n                return ApiError.EEXIST(p);\n            /* The operation failed because it would cause the application to exceed its storage quota.  */\n            case 'QuotaExceededError':\n                return ApiError.FileError(ErrorCode.ENOSPC, p);\n            /*  A required file or directory could not be found at the time an operation was processed.   */\n            case 'NotFoundError':\n                return ApiError.ENOENT(p);\n            /* This is a security error code to be used in situations not covered by any other error codes.\n                - A required file was unsafe for access within a Web application\n                - Too many calls are being made on filesystem resources */\n            case 'SecurityError':\n                return ApiError.FileError(ErrorCode.EACCES, p);\n            /* The modification requested was illegal. Examples of invalid modifications include moving a\n                directory into its own child, moving a file into its parent directory without changing its name,\n                or copying a directory to a path occupied by a file.  */\n            case 'InvalidModificationError':\n                return ApiError.FileError(ErrorCode.EPERM, p);\n            /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type\n                [e.g. is a DirectoryEntry when the user requested a FileEntry].  */\n            case 'TypeMismatchError':\n                return ApiError.FileError(expectedDir ? ErrorCode.ENOTDIR : ErrorCode.EISDIR, p);\n            /* A path or URL supplied to the API was malformed.  */\n            case \"EncodingError\":\n            /* An operation depended on state cached in an interface object, but that state that has changed\n                since it was read from disk.  */\n            case \"InvalidStateError\":\n            /* The user attempted to write to a file or directory which could not be modified due to the state\n                of the underlying filesystem.  */\n            case \"NoModificationAllowedError\":\n            default:\n                return ApiError.FileError(ErrorCode.EINVAL, p);\n        }\n    }\n    // A note about getFile and getDirectory options:\n    // These methods are called at numerous places in this file, and are passed\n    // some combination of these two options:\n    //   - create: If true, the entry will be created if it doesn't exist.\n    //             If false, an error will be thrown if it doesn't exist.\n    //   - exclusive: If true, only create the entry if it doesn't already exist,\n    //                and throw an error if it does.\n    class HTML5FSFile extends PreloadFile {\n        constructor(fs, entry, path, flag, stat, contents) {\n            super(fs, path, flag, stat, contents);\n            this._entry = entry;\n        }\n        sync(cb) {\n            if (!this.isDirty()) {\n                return cb();\n            }\n            this._entry.createWriter((writer) => {\n                const buffer = this.getBuffer();\n                const blob = new Blob([buffer2ArrayBuffer(buffer)]);\n                const length = blob.size;\n                writer.onwriteend = (err) => {\n                    writer.onwriteend = null;\n                    writer.onerror = null;\n                    writer.truncate(length);\n                    this.resetDirty();\n                    cb();\n                };\n                writer.onerror = (err) => {\n                    cb(convertError(err, this.getPath(), false));\n                };\n                writer.write(blob);\n            });\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n    }\n    /**\n     * A read-write filesystem backed by the HTML5 FileSystem API.\n     *\n     * As the HTML5 FileSystem is only implemented in Blink, this interface is\n     * only available in Chrome.\n     */\n    class HTML5FS extends BaseFileSystem {\n        /**\n         * @param size storage quota to request, in megabytes. Allocated value may be less.\n         * @param type window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\n         */\n        constructor(size = 5, type = global.PERSISTENT) {\n            super();\n            // Convert MB to bytes.\n            this.size = 1024 * 1024 * size;\n            this.type = type;\n        }\n        /**\n         * Creates an HTML5FS instance with the given options.\n         */\n        static Create(opts, cb) {\n            const fs = new HTML5FS(opts.size, opts.type);\n            fs._allocate((e) => e ? cb(e) : cb(null, fs));\n        }\n        static isAvailable() {\n            return !!_getFS;\n        }\n        getName() {\n            return HTML5FS.Name;\n        }\n        isReadOnly() {\n            return false;\n        }\n        supportsSymlinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return false;\n        }\n        /**\n         * Deletes everything in the FS. Used for testing.\n         * Karma clears the storage after you quit it but not between runs of the test\n         * suite, and the tests expect an empty FS every time.\n         */\n        empty(mainCb) {\n            // Get a list of all entries in the root directory to delete them\n            this._readdir('/', (err, entries) => {\n                if (err) {\n                    mainCb(err);\n                }\n                else {\n                    // Called when every entry has been operated on\n                    const finished = (er) => {\n                        if (err) {\n                            mainCb(err);\n                        }\n                        else {\n                            mainCb();\n                        }\n                    };\n                    // Removes files and recursively removes directories\n                    const deleteEntry = (entry, cb) => {\n                        const succ = () => {\n                            cb();\n                        };\n                        const error = (err) => {\n                            cb(convertError(err, entry.fullPath, !entry.isDirectory));\n                        };\n                        if (isDirectoryEntry(entry)) {\n                            entry.removeRecursively(succ, error);\n                        }\n                        else {\n                            entry.remove(succ, error);\n                        }\n                    };\n                    // Loop through the entries and remove them, then call the callback\n                    // when they're all finished.\n                    asyncEach(entries, deleteEntry, finished);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            let semaphore = 2;\n            let successCount = 0;\n            const root = this.fs.root;\n            let currentPath = oldPath;\n            const error = (err) => {\n                if (--semaphore <= 0) {\n                    cb(convertError(err, currentPath, false));\n                }\n            };\n            const success = (file) => {\n                if (++successCount === 2) {\n                    return cb(new ApiError(ErrorCode.EINVAL, \"Something was identified as both a file and a directory. This should never happen.\"));\n                }\n                // SPECIAL CASE: If newPath === oldPath, and the path exists, then\n                // this operation trivially succeeds.\n                if (oldPath === newPath) {\n                    return cb();\n                }\n                // Get the new parent directory.\n                currentPath = path.dirname(newPath);\n                root.getDirectory(currentPath, {}, (parentDir) => {\n                    currentPath = path.basename(newPath);\n                    file.moveTo(parentDir, currentPath, (entry) => { cb(); }, (err) => {\n                        // SPECIAL CASE: If oldPath is a directory, and newPath is a\n                        // file, rename should delete the file and perform the move.\n                        if (file.isDirectory) {\n                            currentPath = newPath;\n                            // Unlink only works on files. Try to delete newPath.\n                            this.unlink(newPath, (e) => {\n                                if (e) {\n                                    // newPath is probably a directory.\n                                    error(err);\n                                }\n                                else {\n                                    // Recur, now that newPath doesn't exist.\n                                    this.rename(oldPath, newPath, cb);\n                                }\n                            });\n                        }\n                        else {\n                            error(err);\n                        }\n                    });\n                }, error);\n            };\n            // We don't know if oldPath is a *file* or a *directory*, and there's no\n            // way to stat items. So launch both requests, see which one succeeds.\n            root.getFile(oldPath, {}, success, error);\n            root.getDirectory(oldPath, {}, success, error);\n        }\n        stat(path, isLstat, cb) {\n            // Throw an error if the entry doesn't exist, because then there's nothing\n            // to stat.\n            const opts = {\n                create: false\n            };\n            // Called when the path has been successfully loaded as a file.\n            const loadAsFile = (entry) => {\n                const fileFromEntry = (file) => {\n                    const stat = new Stats(FileType.FILE, file.size);\n                    cb(null, stat);\n                };\n                entry.file(fileFromEntry, failedToLoad);\n            };\n            // Called when the path has been successfully loaded as a directory.\n            const loadAsDir = (dir) => {\n                // Directory entry size can't be determined from the HTML5 FS API, and is\n                // implementation-dependant anyway, so a dummy value is used.\n                const size = 4096;\n                const stat = new Stats(FileType.DIRECTORY, size);\n                cb(null, stat);\n            };\n            // Called when the path couldn't be opened as a directory or a file.\n            const failedToLoad = (err) => {\n                cb(convertError(err, path, false /* Unknown / irrelevant */));\n            };\n            // Called when the path couldn't be opened as a file, but might still be a\n            // directory.\n            const failedToLoadAsFile = () => {\n                this.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);\n            };\n            // No method currently exists to determine whether a path refers to a\n            // directory or a file, so this implementation tries both and uses the first\n            // one that succeeds.\n            this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);\n        }\n        open(p, flags, mode, cb) {\n            // XXX: err is a DOMError\n            const error = (err) => {\n                if (err.name === 'InvalidModificationError' && flags.isExclusive()) {\n                    cb(ApiError.EEXIST(p));\n                }\n                else {\n                    cb(convertError(err, p, false));\n                }\n            };\n            this.fs.root.getFile(p, {\n                create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,\n                exclusive: flags.isExclusive()\n            }, (entry) => {\n                // Try to fetch corresponding file.\n                entry.file((file) => {\n                    const reader = new FileReader();\n                    reader.onloadend = (event) => {\n                        const bfsFile = this._makeFile(p, entry, flags, file, reader.result);\n                        cb(null, bfsFile);\n                    };\n                    reader.onerror = (ev) => {\n                        error(reader.error);\n                    };\n                    reader.readAsArrayBuffer(file);\n                }, error);\n            }, error);\n        }\n        unlink(path, cb) {\n            this._remove(path, cb, true);\n        }\n        rmdir(path, cb) {\n            // Check if directory is non-empty, first.\n            this.readdir(path, (e, files) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (files.length > 0) {\n                    cb(ApiError.ENOTEMPTY(path));\n                }\n                else {\n                    this._remove(path, cb, false);\n                }\n            });\n        }\n        mkdir(path, mode, cb) {\n            // Create the directory, but throw an error if it already exists, as per\n            // mkdir(1)\n            const opts = {\n                create: true,\n                exclusive: true\n            };\n            const success = (dir) => {\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            this.fs.root.getDirectory(path, opts, success, error);\n        }\n        /**\n         * Map _readdir's list of `FileEntry`s to their names and return that.\n         */\n        readdir(path, cb) {\n            this._readdir(path, (e, entries) => {\n                if (entries) {\n                    const rv = [];\n                    for (const entry of entries) {\n                        rv.push(entry.name);\n                    }\n                    cb(null, rv);\n                }\n                else {\n                    return cb(e);\n                }\n            });\n        }\n        /**\n         * Returns a BrowserFS object representing a File.\n         */\n        _makeFile(path, entry, flag, stat, data = new ArrayBuffer(0)) {\n            const stats = new Stats(FileType.FILE, stat.size);\n            const buffer = arrayBuffer2Buffer(data);\n            return new HTML5FSFile(this, entry, path, flag, stats, buffer);\n        }\n        /**\n         * Returns an array of `FileEntry`s. Used internally by empty and readdir.\n         */\n        _readdir(path, cb) {\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            // Grab the requested directory.\n            this.fs.root.getDirectory(path, { create: false }, (dirEntry) => {\n                const reader = dirEntry.createReader();\n                let entries = [];\n                // Call the reader.readEntries() until no more results are returned.\n                const readEntries = () => {\n                    reader.readEntries(((results) => {\n                        if (results.length) {\n                            entries = entries.concat(_toArray(results));\n                            readEntries();\n                        }\n                        else {\n                            cb(null, entries);\n                        }\n                    }), error);\n                };\n                readEntries();\n            }, error);\n        }\n        /**\n         * Requests a storage quota from the browser to back this FS.\n         */\n        _allocate(cb) {\n            const success = (fs) => {\n                this.fs = fs;\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, \"/\", true));\n            };\n            if (this.type === global.PERSISTENT) {\n                _requestQuota(this.type, this.size, (granted) => {\n                    _getFS(this.type, granted, success, error);\n                }, error);\n            }\n            else {\n                _getFS(this.type, this.size, success, error);\n            }\n        }\n        /**\n         * Delete a file or directory from the file system\n         * isFile should reflect which call was made to remove the it (`unlink` or\n         * `rmdir`). If this doesn't match what's actually at `path`, an error will be\n         * returned\n         */\n        _remove(path, cb, isFile) {\n            const success = (entry) => {\n                const succ = () => {\n                    cb();\n                };\n                const err = (err) => {\n                    cb(convertError(err, path, !isFile));\n                };\n                entry.remove(succ, err);\n            };\n            const error = (err) => {\n                cb(convertError(err, path, !isFile));\n            };\n            // Deleting the entry, so don't create it\n            const opts = {\n                create: false\n            };\n            if (isFile) {\n                this.fs.root.getFile(path, opts, success, error);\n            }\n            else {\n                this.fs.root.getDirectory(path, opts, success, error);\n            }\n        }\n    }\n    HTML5FS.Name = \"HTML5FS\";\n    HTML5FS.Options = {\n        size: {\n            type: \"number\",\n            optional: true,\n            description: \"Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5.\"\n        },\n        type: {\n            type: \"number\",\n            optional: true,\n            description: \"window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\"\n        }\n    };\n\n    HTML5FS.HTML5FSFile = HTML5FSFile;\n\n    return HTML5FS;\n});\ndefine('skylark-browserfs/generic/inode',[\n    '../libs/buffers',\n    '../core/node_fs_stats'\n], function (buffers,node_fs_stats) {\n    'use strict';\n\n    const  { Stats, FileType } = node_fs_stats;\n    const { Buffer } = buffers;\n\n    /**\n     * Generic inode definition that can easily be serialized.\n     */\n    class Inode {\n        constructor(id, size, mode, atime, mtime, ctime) {\n            this.id = id;\n            this.size = size;\n            this.mode = mode;\n            this.atime = atime;\n            this.mtime = mtime;\n            this.ctime = ctime;\n        }\n        /**\n         * Converts the buffer into an Inode.\n         */\n        static fromBuffer(buffer) {\n            if (buffer === undefined) {\n                throw new Error(\"NO\");\n            }\n            return new Inode(buffer.toString('ascii', 30), buffer.readUInt32LE(0), buffer.readUInt16LE(4), buffer.readDoubleLE(6), buffer.readDoubleLE(14), buffer.readDoubleLE(22));\n        }\n        /**\n         * Handy function that converts the Inode to a Node Stats object.\n         */\n        toStats() {\n            return new Stats((this.mode & 0xF000) === FileType.DIRECTORY ? FileType.DIRECTORY : FileType.FILE, this.size, this.mode, this.atime, this.mtime, this.ctime);\n        }\n        /**\n         * Get the size of this Inode, in bytes.\n         */\n        getSize() {\n            // ASSUMPTION: ID is ASCII (1 byte per char).\n            return 30 + this.id.length;\n        }\n        /**\n         * Writes the inode into the start of the buffer.\n         */\n        toBuffer(buff = Buffer.alloc(this.getSize())) {\n            buff.writeUInt32LE(this.size, 0);\n            buff.writeUInt16LE(this.mode, 4);\n            buff.writeDoubleLE(this.atime, 6);\n            buff.writeDoubleLE(this.mtime, 14);\n            buff.writeDoubleLE(this.ctime, 22);\n            buff.write(this.id, 30, this.id.length, 'ascii');\n            return buff;\n        }\n        /**\n         * Updates the Inode using information from the stats object. Used by file\n         * systems at sync time, e.g.:\n         * - Program opens file and gets a File object.\n         * - Program mutates file. File object is responsible for maintaining\n         *   metadata changes locally -- typically in a Stats object.\n         * - Program closes file. File object's metadata changes are synced with the\n         *   file system.\n         * @return True if any changes have occurred.\n         */\n        update(stats) {\n            let hasChanged = false;\n            if (this.size !== stats.size) {\n                this.size = stats.size;\n                hasChanged = true;\n            }\n            if (this.mode !== stats.mode) {\n                this.mode = stats.mode;\n                hasChanged = true;\n            }\n            const atimeMs = stats.atime.getTime();\n            if (this.atime !== atimeMs) {\n                this.atime = atimeMs;\n                hasChanged = true;\n            }\n            const mtimeMs = stats.mtime.getTime();\n            if (this.mtime !== mtimeMs) {\n                this.mtime = mtimeMs;\n                hasChanged = true;\n            }\n            const ctimeMs = stats.ctime.getTime();\n            if (this.ctime !== ctimeMs) {\n                this.ctime = ctimeMs;\n                hasChanged = true;\n            }\n            return hasChanged;\n        }\n        // XXX: Copied from Stats. Should reconcile these two into something more\n        //      compact.\n        /**\n         * @return [Boolean] True if this item is a file.\n         */\n        isFile() {\n            return (this.mode & 0xF000) === FileType.FILE;\n        }\n        /**\n         * @return [Boolean] True if this item is a directory.\n         */\n        isDirectory() {\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\n        }\n    }\n\n\n    return Inode;\n});\ndefine('skylark-browserfs/generic/key_value_filesystem',[\n    '../libs/buffers',\n    '../core/file_system',\n    '../core/api_error',\n    '../core/node_fs_stats',\n    '../libs/path',\n    '../generic/inode',\n    '../generic/preload_file',\n    '../core/util'\n], function (buffers,file_system, api_error, node_fs_stats, path, Inode, preload_file, util) {\n    'use strict';\n\n    const { BaseFileSystem, SynchronousFileSystem } = file_system;\n    const { ApiError, ErrorCode } = api_error;\n    const { FileType } = node_fs_stats;\n    const { emptyBuffer } = util;\n    const { PreloadFile} = preload_file;\n    const { Buffer } = buffers;\n\n\n    /**\n     * @hidden\n     */\n    const ROOT_NODE_ID = \"/\";\n    /**\n     * @hidden\n     */\n    let emptyDirNode = null;\n    /**\n     * Returns an empty directory node.\n     * @hidden\n     */\n    function getEmptyDirNode() {\n        if (emptyDirNode) {\n            return emptyDirNode;\n        }\n        return emptyDirNode = Buffer.from(\"{}\");\n    }\n    /**\n     * Generates a random ID.\n     * @hidden\n     */\n    function GenerateRandomID() {\n        // From http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n    /**\n     * Helper function. Checks if 'e' is defined. If so, it triggers the callback\n     * with 'e' and returns false. Otherwise, returns true.\n     * @hidden\n     */\n    function noError(e, cb) {\n        if (e) {\n            cb(e);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,\n     * triggers the callback with 'e', and returns false. Otherwise, returns true.\n     * @hidden\n     */\n    function noErrorTx(e, tx, cb) {\n        if (e) {\n            tx.abort(() => {\n                cb(e);\n            });\n            return false;\n        }\n        return true;\n    }\n    class LRUNode {\n        constructor(key, value) {\n            this.key = key;\n            this.value = value;\n            this.prev = null;\n            this.next = null;\n        }\n    }\n    // Adapted from https://chrisrng.svbtle.com/lru-cache-in-javascript\n    class LRUCache {\n        constructor(limit) {\n            this.limit = limit;\n            this.size = 0;\n            this.map = {};\n            this.head = null;\n            this.tail = null;\n        }\n        /**\n         * Change or add a new value in the cache\n         * We overwrite the entry if it already exists\n         */\n        set(key, value) {\n            const node = new LRUNode(key, value);\n            if (this.map[key]) {\n                this.map[key].value = node.value;\n                this.remove(node.key);\n            }\n            else {\n                if (this.size >= this.limit) {\n                    delete this.map[this.tail.key];\n                    this.size--;\n                    this.tail = this.tail.prev;\n                    this.tail.next = null;\n                }\n            }\n            this.setHead(node);\n        }\n        /* Retrieve a single entry from the cache */\n        get(key) {\n            if (this.map[key]) {\n                const value = this.map[key].value;\n                const node = new LRUNode(key, value);\n                this.remove(key);\n                this.setHead(node);\n                return value;\n            }\n            else {\n                return null;\n            }\n        }\n        /* Remove a single entry from the cache */\n        remove(key) {\n            const node = this.map[key];\n            if (!node) {\n                return;\n            }\n            if (node.prev !== null) {\n                node.prev.next = node.next;\n            }\n            else {\n                this.head = node.next;\n            }\n            if (node.next !== null) {\n                node.next.prev = node.prev;\n            }\n            else {\n                this.tail = node.prev;\n            }\n            delete this.map[key];\n            this.size--;\n        }\n        /* Resets the entire cache - Argument limit is optional to be reset */\n        removeAll() {\n            this.size = 0;\n            this.map = {};\n            this.head = null;\n            this.tail = null;\n        }\n        setHead(node) {\n            node.next = this.head;\n            node.prev = null;\n            if (this.head !== null) {\n                this.head.prev = node;\n            }\n            this.head = node;\n            if (this.tail === null) {\n                this.tail = node;\n            }\n            this.size++;\n            this.map[node.key] = node;\n        }\n    }\n    /**\n     * A simple RW transaction for simple synchronous key-value stores.\n     */\n    class SimpleSyncRWTransaction {\n        constructor(store) {\n            this.store = store;\n            /**\n             * Stores data in the keys we modify prior to modifying them.\n             * Allows us to roll back commits.\n             */\n            this.originalData = {};\n            /**\n             * List of keys modified in this transaction, if any.\n             */\n            this.modifiedKeys = [];\n        }\n        get(key) {\n            const val = this.store.get(key);\n            this.stashOldValue(key, val);\n            return val;\n        }\n        put(key, data, overwrite) {\n            this.markModified(key);\n            return this.store.put(key, data, overwrite);\n        }\n        del(key) {\n            this.markModified(key);\n            this.store.del(key);\n        }\n        commit() { }\n        abort() {\n            // Rollback old values.\n            for (const key of this.modifiedKeys) {\n                const value = this.originalData[key];\n                if (!value) {\n                    // Key didn't exist.\n                    this.store.del(key);\n                }\n                else {\n                    // Key existed. Store old value.\n                    this.store.put(key, value, true);\n                }\n            }\n        }\n        /**\n         * Stashes given key value pair into `originalData` if it doesn't already\n         * exist. Allows us to stash values the program is requesting anyway to\n         * prevent needless `get` requests if the program modifies the data later\n         * on during the transaction.\n         */\n        stashOldValue(key, value) {\n            // Keep only the earliest value in the transaction.\n            if (!this.originalData.hasOwnProperty(key)) {\n                this.originalData[key] = value;\n            }\n        }\n        /**\n         * Marks the given key as modified, and stashes its value if it has not been\n         * stashed already.\n         */\n        markModified(key) {\n            if (this.modifiedKeys.indexOf(key) === -1) {\n                this.modifiedKeys.push(key);\n                if (!this.originalData.hasOwnProperty(key)) {\n                    this.originalData[key] = this.store.get(key);\n                }\n            }\n        }\n    }\n    class SyncKeyValueFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        syncSync() {\n            if (this.isDirty()) {\n                this._fs._syncSync(this.getPath(), this.getBuffer(), this.getStats());\n                this.resetDirty();\n            }\n        }\n        closeSync() {\n            this.syncSync();\n        }\n    }\n    /**\n     * A \"Synchronous key-value file system\". Stores data to/retrieves data from an\n     * underlying key-value store.\n     *\n     * We use a unique ID for each node in the file system. The root node has a\n     * fixed ID.\n     * @todo Introduce Node ID caching.\n     * @todo Check modes.\n     */\n    class SyncKeyValueFileSystem extends SynchronousFileSystem {\n        static isAvailable() { return true; }\n        constructor(options) {\n            super();\n            this.store = options.store;\n            // INVARIANT: Ensure that the root exists.\n            this.makeRootDirectory();\n        }\n        getName() { return this.store.name(); }\n        isReadOnly() { return false; }\n        supportsSymlinks() { return false; }\n        supportsProps() { return false; }\n        supportsSynch() { return true; }\n        /**\n         * Delete all contents stored in the file system.\n         */\n        empty() {\n            this.store.clear();\n            // INVARIANT: Root always exists.\n            this.makeRootDirectory();\n        }\n        renameSync(oldPath, newPath) {\n            const tx = this.store.beginTransaction('readwrite'), oldParent = path.dirname(oldPath), oldName = path.basename(oldPath), newParent = path.dirname(newPath), newName = path.basename(newPath), \n            // Remove oldPath from parent's directory listing.\n            oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);\n            if (!oldDirList[oldName]) {\n                throw ApiError.ENOENT(oldPath);\n            }\n            const nodeId = oldDirList[oldName];\n            delete oldDirList[oldName];\n            // Invariant: Can't move a folder inside itself.\n            // This funny little hack ensures that the check passes only if oldPath\n            // is a subpath of newParent. We append '/' to avoid matching folders that\n            // are a substring of the bottom-most folder in the path.\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\n                throw new ApiError(ErrorCode.EBUSY, oldParent);\n            }\n            // Add newPath to parent's directory listing.\n            let newDirNode, newDirList;\n            if (newParent === oldParent) {\n                // Prevent us from re-grabbing the same directory listing, which still\n                // contains oldName.\n                newDirNode = oldDirNode;\n                newDirList = oldDirList;\n            }\n            else {\n                newDirNode = this.findINode(tx, newParent);\n                newDirList = this.getDirListing(tx, newParent, newDirNode);\n            }\n            if (newDirList[newName]) {\n                // If it's a file, delete it.\n                const newNameNode = this.getINode(tx, newPath, newDirList[newName]);\n                if (newNameNode.isFile()) {\n                    try {\n                        tx.del(newNameNode.id);\n                        tx.del(newDirList[newName]);\n                    }\n                    catch (e) {\n                        tx.abort();\n                        throw e;\n                    }\n                }\n                else {\n                    // If it's a directory, throw a permissions error.\n                    throw ApiError.EPERM(newPath);\n                }\n            }\n            newDirList[newName] = nodeId;\n            // Commit the two changed directory listings.\n            try {\n                tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);\n                tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n        }\n        statSync(p, isLstat) {\n            // Get the inode to the item, convert it into a Stats object.\n            return this.findINode(this.store.beginTransaction('readonly'), p).toStats();\n        }\n        createFileSync(p, flag, mode) {\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);\n            // Open the file.\n            return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);\n        }\n        openFileSync(p, flag) {\n            const tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);\n            if (data === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return new SyncKeyValueFile(this, p, flag, node.toStats(), data);\n        }\n        unlinkSync(p) {\n            this.removeEntry(p, false);\n        }\n        rmdirSync(p) {\n            // Check first if directory is empty.\n            if (this.readdirSync(p).length > 0) {\n                throw ApiError.ENOTEMPTY(p);\n            }\n            else {\n                this.removeEntry(p, true);\n            }\n        }\n        mkdirSync(p, mode) {\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);\n        }\n        readdirSync(p) {\n            const tx = this.store.beginTransaction('readonly');\n            return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));\n        }\n        _syncSync(p, data, stats) {\n            // @todo Ensure mtime updates properly, and use that to determine if a data\n            //       update is required.\n            const tx = this.store.beginTransaction('readwrite'), \n            // We use the _findInode helper because we actually need the INode id.\n            fileInodeId = this._findINode(tx, path.dirname(p), path.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);\n            try {\n                // Sync data.\n                tx.put(fileInode.id, data, true);\n                // Sync metadata.\n                if (inodeChanged) {\n                    tx.put(fileInodeId, fileInode.toBuffer(), true);\n                }\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n        }\n        /**\n         * Checks if the root directory exists. Creates it if it doesn't.\n         */\n        makeRootDirectory() {\n            const tx = this.store.beginTransaction('readwrite');\n            if (tx.get(ROOT_NODE_ID) === undefined) {\n                // Create new inode.\n                const currTime = (new Date()).getTime(), \n                // Mode 0666\n                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\n                // If the root doesn't exist, the first random ID shouldn't exist,\n                // either.\n                tx.put(dirInode.id, getEmptyDirNode(), false);\n                tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);\n                tx.commit();\n            }\n        }\n        /**\n         * Helper function for findINode.\n         * @param parent The parent directory of the file we are attempting to find.\n         * @param filename The filename of the inode we are attempting to find, minus\n         *   the parent.\n         * @return string The ID of the file's inode in the file system.\n         */\n        _findINode(tx, parent, filename) {\n            const readDirectory = (inode) => {\n                // Get the root's directory listing.\n                const dirList = this.getDirListing(tx, parent, inode);\n                // Get the file's ID.\n                if (dirList[filename]) {\n                    return dirList[filename];\n                }\n                else {\n                    throw ApiError.ENOENT(path.resolve(parent, filename));\n                }\n            };\n            if (parent === '/') {\n                if (filename === '') {\n                    // BASE CASE #1: Return the root's ID.\n                    return ROOT_NODE_ID;\n                }\n                else {\n                    // BASE CASE #2: Find the item in the root ndoe.\n                    return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));\n                }\n            }\n            else {\n                return readDirectory(this.getINode(tx, parent + path.sep + filename, this._findINode(tx, path.dirname(parent), path.basename(parent))));\n            }\n        }\n        /**\n         * Finds the Inode of the given path.\n         * @param p The path to look up.\n         * @return The Inode of the path p.\n         * @todo memoize/cache\n         */\n        findINode(tx, p) {\n            return this.getINode(tx, p, this._findINode(tx, path.dirname(p), path.basename(p)));\n        }\n        /**\n         * Given the ID of a node, retrieves the corresponding Inode.\n         * @param tx The transaction to use.\n         * @param p The corresponding path to the file (used for error messages).\n         * @param id The ID to look up.\n         */\n        getINode(tx, p, id) {\n            const inode = tx.get(id);\n            if (inode === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return Inode.fromBuffer(inode);\n        }\n        /**\n         * Given the Inode of a directory, retrieves the corresponding directory\n         * listing.\n         */\n        getDirListing(tx, p, inode) {\n            if (!inode.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n            const data = tx.get(inode.id);\n            if (data === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return JSON.parse(data.toString());\n        }\n        /**\n         * Creates a new node under a random ID. Retries 5 times before giving up in\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\n         * @return The GUID that the data was stored under.\n         */\n        addNewNode(tx, data) {\n            const retries = 0;\n            let currId;\n            while (retries < 5) {\n                try {\n                    currId = GenerateRandomID();\n                    tx.put(currId, data, false);\n                    return currId;\n                }\n                catch (e) {\n                    // Ignore and reroll.\n                }\n            }\n            throw new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.');\n        }\n        /**\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\n         * the given mode.\n         * Note: This will commit the transaction.\n         * @param p The path to the new file.\n         * @param type The type of the new file.\n         * @param mode The mode to create the new file with.\n         * @param data The data to store at the file's data node.\n         * @return The Inode for the new file.\n         */\n        commitNewFile(tx, p, type, mode, data) {\n            const parentDir = path.dirname(p), fname = path.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();\n            // Invariant: The root always exists.\n            // If we don't check this prior to taking steps below, we will create a\n            // file with name '' in root should p == '/'.\n            if (p === '/') {\n                throw ApiError.EEXIST(p);\n            }\n            // Check if file already exists.\n            if (dirListing[fname]) {\n                throw ApiError.EEXIST(p);\n            }\n            let fileNode;\n            try {\n                // Commit data.\n                const dataId = this.addNewNode(tx, data);\n                fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\n                // Commit file node.\n                const fileNodeId = this.addNewNode(tx, fileNode.toBuffer());\n                // Update and commit parent directory listing.\n                dirListing[fname] = fileNodeId;\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n            return fileNode;\n        }\n        /**\n         * Remove all traces of the given path from the file system.\n         * @param p The path to remove from the file system.\n         * @param isDir Does the path belong to a directory, or a file?\n         * @todo Update mtime.\n         */\n        removeEntry(p, isDir) {\n            const tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = path.basename(p);\n            if (!parentListing[fileName]) {\n                throw ApiError.ENOENT(p);\n            }\n            // Remove from directory listing of parent.\n            const fileNodeId = parentListing[fileName];\n            delete parentListing[fileName];\n            // Get file inode.\n            const fileNode = this.getINode(tx, p, fileNodeId);\n            if (!isDir && fileNode.isDirectory()) {\n                throw ApiError.EISDIR(p);\n            }\n            else if (isDir && !fileNode.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n            try {\n                // Delete data.\n                tx.del(fileNode.id);\n                // Delete node.\n                tx.del(fileNodeId);\n                // Update directory listing.\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            // Success.\n            tx.commit();\n        }\n    }\n    class AsyncKeyValueFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        sync(cb) {\n            if (this.isDirty()) {\n                this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), (e) => {\n                    if (!e) {\n                        this.resetDirty();\n                    }\n                    cb(e);\n                });\n            }\n            else {\n                cb();\n            }\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n    }\n    /**\n     * An \"Asynchronous key-value file system\". Stores data to/retrieves data from\n     * an underlying asynchronous key-value store.\n     */\n    class AsyncKeyValueFileSystem extends BaseFileSystem {\n        constructor(cacheSize) {\n            super();\n            this._cache = null;\n            if (cacheSize > 0) {\n                this._cache = new LRUCache(cacheSize);\n            }\n        }\n        static isAvailable() { return true; }\n        /**\n         * Initializes the file system. Typically called by subclasses' async\n         * constructors.\n         */\n        init(store, cb) {\n            this.store = store;\n            // INVARIANT: Ensure that the root exists.\n            this.makeRootDirectory(cb);\n        }\n        getName() { return this.store.name(); }\n        isReadOnly() { return false; }\n        supportsSymlinks() { return false; }\n        supportsProps() { return false; }\n        supportsSynch() { return false; }\n        /**\n         * Delete all contents stored in the file system.\n         */\n        empty(cb) {\n            if (this._cache) {\n                this._cache.removeAll();\n            }\n            this.store.clear((e) => {\n                if (noError(e, cb)) {\n                    // INVARIANT: Root always exists.\n                    this.makeRootDirectory(cb);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            // TODO: Make rename compatible with the cache.\n            if (this._cache) {\n                // Clear and disable cache during renaming process.\n                const c = this._cache;\n                this._cache = null;\n                c.removeAll();\n                const oldCb = cb;\n                cb = (e) => {\n                    // Restore empty cache.\n                    this._cache = c;\n                    oldCb(e);\n                };\n            }\n            const tx = this.store.beginTransaction('readwrite');\n            const oldParent = path.dirname(oldPath), oldName = path.basename(oldPath);\n            const newParent = path.dirname(newPath), newName = path.basename(newPath);\n            const inodes = {};\n            const lists = {};\n            let errorOccurred = false;\n            // Invariant: Can't move a folder inside itself.\n            // This funny little hack ensures that the check passes only if oldPath\n            // is a subpath of newParent. We append '/' to avoid matching folders that\n            // are a substring of the bottom-most folder in the path.\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\n                return cb(new ApiError(ErrorCode.EBUSY, oldParent));\n            }\n            /**\n             * Responsible for Phase 2 of the rename operation: Modifying and\n             * committing the directory listings. Called once we have successfully\n             * retrieved both the old and new parent's inodes and listings.\n             */\n            const theOleSwitcharoo = () => {\n                // Sanity check: Ensure both paths are present, and no error has occurred.\n                if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {\n                    return;\n                }\n                const oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];\n                // Delete file from old parent.\n                if (!oldParentList[oldName]) {\n                    cb(ApiError.ENOENT(oldPath));\n                }\n                else {\n                    const fileId = oldParentList[oldName];\n                    delete oldParentList[oldName];\n                    // Finishes off the renaming process by adding the file to the new\n                    // parent.\n                    const completeRename = () => {\n                        newParentList[newName] = fileId;\n                        // Commit old parent's list.\n                        tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, (e) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (oldParent === newParent) {\n                                    // DONE!\n                                    tx.commit(cb);\n                                }\n                                else {\n                                    // Commit new parent's list.\n                                    tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, (e) => {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            tx.commit(cb);\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    };\n                    if (newParentList[newName]) {\n                        // 'newPath' already exists. Check if it's a file or a directory, and\n                        // act accordingly.\n                        this.getINode(tx, newPath, newParentList[newName], (e, inode) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (inode.isFile()) {\n                                    // Delete the file and continue.\n                                    tx.del(inode.id, (e) => {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            tx.del(newParentList[newName], (e) => {\n                                                if (noErrorTx(e, tx, cb)) {\n                                                    completeRename();\n                                                }\n                                            });\n                                        }\n                                    });\n                                }\n                                else {\n                                    // Can't overwrite a directory using rename.\n                                    tx.abort((e) => {\n                                        cb(ApiError.EPERM(newPath));\n                                    });\n                                }\n                            }\n                        });\n                    }\n                    else {\n                        completeRename();\n                    }\n                }\n            };\n            /**\n             * Grabs a path's inode and directory listing, and shoves it into the\n             * inodes and lists hashes.\n             */\n            const processInodeAndListings = (p) => {\n                this.findINodeAndDirListing(tx, p, (e, node, dirList) => {\n                    if (e) {\n                        if (!errorOccurred) {\n                            errorOccurred = true;\n                            tx.abort(() => {\n                                cb(e);\n                            });\n                        }\n                        // If error has occurred already, just stop here.\n                    }\n                    else {\n                        inodes[p] = node;\n                        lists[p] = dirList;\n                        theOleSwitcharoo();\n                    }\n                });\n            };\n            processInodeAndListings(oldParent);\n            if (oldParent !== newParent) {\n                processInodeAndListings(newParent);\n            }\n        }\n        stat(p, isLstat, cb) {\n            const tx = this.store.beginTransaction('readonly');\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    cb(null, inode.toStats());\n                }\n            });\n        }\n        createFile(p, flag, mode, cb) {\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();\n            this.commitNewFile(tx, p, FileType.FILE, mode, data, (e, newFile) => {\n                if (noError(e, cb)) {\n                    cb(null, new AsyncKeyValueFile(this, p, flag, newFile.toStats(), data));\n                }\n            });\n        }\n        openFile(p, flag, cb) {\n            const tx = this.store.beginTransaction('readonly');\n            // Step 1: Grab the file's inode.\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    // Step 2: Grab the file's data.\n                    tx.get(inode.id, (e, data) => {\n                        if (noError(e, cb)) {\n                            if (data === undefined) {\n                                cb(ApiError.ENOENT(p));\n                            }\n                            else {\n                                cb(null, new AsyncKeyValueFile(this, p, flag, inode.toStats(), data));\n                            }\n                        }\n                    });\n                }\n            });\n        }\n        unlink(p, cb) {\n            this.removeEntry(p, false, cb);\n        }\n        rmdir(p, cb) {\n            // Check first if directory is empty.\n            this.readdir(p, (err, files) => {\n                if (err) {\n                    cb(err);\n                }\n                else if (files.length > 0) {\n                    cb(ApiError.ENOTEMPTY(p));\n                }\n                else {\n                    this.removeEntry(p, true, cb);\n                }\n            });\n        }\n        mkdir(p, mode, cb) {\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);\n        }\n        readdir(p, cb) {\n            const tx = this.store.beginTransaction('readonly');\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    this.getDirListing(tx, p, inode, (e, dirListing) => {\n                        if (noError(e, cb)) {\n                            cb(null, Object.keys(dirListing));\n                        }\n                    });\n                }\n            });\n        }\n        _sync(p, data, stats, cb) {\n            // @todo Ensure mtime updates properly, and use that to determine if a data\n            //       update is required.\n            const tx = this.store.beginTransaction('readwrite');\n            // Step 1: Get the file node's ID.\n            this._findINode(tx, path.dirname(p), path.basename(p), (e, fileInodeId) => {\n                if (noErrorTx(e, tx, cb)) {\n                    // Step 2: Get the file inode.\n                    this.getINode(tx, p, fileInodeId, (e, fileInode) => {\n                        if (noErrorTx(e, tx, cb)) {\n                            const inodeChanged = fileInode.update(stats);\n                            // Step 3: Sync the data.\n                            tx.put(fileInode.id, data, true, (e) => {\n                                if (noErrorTx(e, tx, cb)) {\n                                    // Step 4: Sync the metadata (if it changed)!\n                                    if (inodeChanged) {\n                                        tx.put(fileInodeId, fileInode.toBuffer(), true, (e) => {\n                                            if (noErrorTx(e, tx, cb)) {\n                                                tx.commit(cb);\n                                            }\n                                        });\n                                    }\n                                    else {\n                                        // No need to sync metadata; return.\n                                        tx.commit(cb);\n                                    }\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Checks if the root directory exists. Creates it if it doesn't.\n         */\n        makeRootDirectory(cb) {\n            const tx = this.store.beginTransaction('readwrite');\n            tx.get(ROOT_NODE_ID, (e, data) => {\n                if (e || data === undefined) {\n                    // Create new inode.\n                    const currTime = (new Date()).getTime(), \n                    // Mode 0666\n                    dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\n                    // If the root doesn't exist, the first random ID shouldn't exist,\n                    // either.\n                    tx.put(dirInode.id, getEmptyDirNode(), false, (e) => {\n                        if (noErrorTx(e, tx, cb)) {\n                            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, (e) => {\n                                if (e) {\n                                    tx.abort(() => { cb(e); });\n                                }\n                                else {\n                                    tx.commit(cb);\n                                }\n                            });\n                        }\n                    });\n                }\n                else {\n                    // We're good.\n                    tx.commit(cb);\n                }\n            });\n        }\n        /**\n         * Helper function for findINode.\n         * @param parent The parent directory of the file we are attempting to find.\n         * @param filename The filename of the inode we are attempting to find, minus\n         *   the parent.\n         * @param cb Passed an error or the ID of the file's inode in the file system.\n         */\n        _findINode(tx, parent, filename, cb) {\n            if (this._cache) {\n                const id = this._cache.get(path.join(parent, filename));\n                if (id) {\n                    return cb(null, id);\n                }\n            }\n            const handleDirectoryListings = (e, inode, dirList) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (dirList[filename]) {\n                    const id = dirList[filename];\n                    if (this._cache) {\n                        this._cache.set(path.join(parent, filename), id);\n                    }\n                    cb(null, id);\n                }\n                else {\n                    cb(ApiError.ENOENT(path.resolve(parent, filename)));\n                }\n            };\n            if (parent === '/') {\n                if (filename === '') {\n                    // BASE CASE #1: Return the root's ID.\n                    if (this._cache) {\n                        this._cache.set(path.join(parent, filename), ROOT_NODE_ID);\n                    }\n                    cb(null, ROOT_NODE_ID);\n                }\n                else {\n                    // BASE CASE #2: Find the item in the root node.\n                    this.getINode(tx, parent, ROOT_NODE_ID, (e, inode) => {\n                        if (noError(e, cb)) {\n                            this.getDirListing(tx, parent, inode, (e, dirList) => {\n                                // handle_directory_listings will handle e for us.\n                                handleDirectoryListings(e, inode, dirList);\n                            });\n                        }\n                    });\n                }\n            }\n            else {\n                // Get the parent directory's INode, and find the file in its directory\n                // listing.\n                this.findINodeAndDirListing(tx, parent, handleDirectoryListings);\n            }\n        }\n        /**\n         * Finds the Inode of the given path.\n         * @param p The path to look up.\n         * @param cb Passed an error or the Inode of the path p.\n         * @todo memoize/cache\n         */\n        findINode(tx, p, cb) {\n            this._findINode(tx, path.dirname(p), path.basename(p), (e, id) => {\n                if (noError(e, cb)) {\n                    this.getINode(tx, p, id, cb);\n                }\n            });\n        }\n        /**\n         * Given the ID of a node, retrieves the corresponding Inode.\n         * @param tx The transaction to use.\n         * @param p The corresponding path to the file (used for error messages).\n         * @param id The ID to look up.\n         * @param cb Passed an error or the inode under the given id.\n         */\n        getINode(tx, p, id, cb) {\n            tx.get(id, (e, data) => {\n                if (noError(e, cb)) {\n                    if (data === undefined) {\n                        cb(ApiError.ENOENT(p));\n                    }\n                    else {\n                        cb(null, Inode.fromBuffer(data));\n                    }\n                }\n            });\n        }\n        /**\n         * Given the Inode of a directory, retrieves the corresponding directory\n         * listing.\n         */\n        getDirListing(tx, p, inode, cb) {\n            if (!inode.isDirectory()) {\n                cb(ApiError.ENOTDIR(p));\n            }\n            else {\n                tx.get(inode.id, (e, data) => {\n                    if (noError(e, cb)) {\n                        try {\n                            cb(null, JSON.parse(data.toString()));\n                        }\n                        catch (e) {\n                            // Occurs when data is undefined, or corresponds to something other\n                            // than a directory listing. The latter should never occur unless\n                            // the file system is corrupted.\n                            cb(ApiError.ENOENT(p));\n                        }\n                    }\n                });\n            }\n        }\n        /**\n         * Given a path to a directory, retrieves the corresponding INode and\n         * directory listing.\n         */\n        findINodeAndDirListing(tx, p, cb) {\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    this.getDirListing(tx, p, inode, (e, listing) => {\n                        if (noError(e, cb)) {\n                            cb(null, inode, listing);\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Adds a new node under a random ID. Retries 5 times before giving up in\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\n         * @param cb Passed an error or the GUID that the data was stored under.\n         */\n        addNewNode(tx, data, cb) {\n            let retries = 0, currId;\n            const reroll = () => {\n                if (++retries === 5) {\n                    // Max retries hit. Return with an error.\n                    cb(new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.'));\n                }\n                else {\n                    // Try again.\n                    currId = GenerateRandomID();\n                    tx.put(currId, data, false, (e, committed) => {\n                        if (e || !committed) {\n                            reroll();\n                        }\n                        else {\n                            // Successfully stored under 'currId'.\n                            cb(null, currId);\n                        }\n                    });\n                }\n            };\n            reroll();\n        }\n        /**\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\n         * the given mode.\n         * Note: This will commit the transaction.\n         * @param p The path to the new file.\n         * @param type The type of the new file.\n         * @param mode The mode to create the new file with.\n         * @param data The data to store at the file's data node.\n         * @param cb Passed an error or the Inode for the new file.\n         */\n        commitNewFile(tx, p, type, mode, data, cb) {\n            const parentDir = path.dirname(p), fname = path.basename(p), currTime = (new Date()).getTime();\n            // Invariant: The root always exists.\n            // If we don't check this prior to taking steps below, we will create a\n            // file with name '' in root should p == '/'.\n            if (p === '/') {\n                return cb(ApiError.EEXIST(p));\n            }\n            // Let's build a pyramid of code!\n            // Step 1: Get the parent directory's inode and directory listing\n            this.findINodeAndDirListing(tx, parentDir, (e, parentNode, dirListing) => {\n                if (noErrorTx(e, tx, cb)) {\n                    if (dirListing[fname]) {\n                        // File already exists.\n                        tx.abort(() => {\n                            cb(ApiError.EEXIST(p));\n                        });\n                    }\n                    else {\n                        // Step 2: Commit data to store.\n                        this.addNewNode(tx, data, (e, dataId) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                // Step 3: Commit the file's inode to the store.\n                                const fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\n                                this.addNewNode(tx, fileInode.toBuffer(), (e, fileInodeId) => {\n                                    if (noErrorTx(e, tx, cb)) {\n                                        // Step 4: Update parent directory's listing.\n                                        dirListing[fname] = fileInodeId;\n                                        tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, (e) => {\n                                            if (noErrorTx(e, tx, cb)) {\n                                                // Step 5: Commit and return the new inode.\n                                                tx.commit((e) => {\n                                                    if (noErrorTx(e, tx, cb)) {\n                                                        cb(null, fileInode);\n                                                    }\n                                                });\n                                            }\n                                        });\n                                    }\n                                });\n                            }\n                        });\n                    }\n                }\n            });\n        }\n        /**\n         * Remove all traces of the given path from the file system.\n         * @param p The path to remove from the file system.\n         * @param isDir Does the path belong to a directory, or a file?\n         * @todo Update mtime.\n         */\n        removeEntry(p, isDir, cb) {\n            // Eagerly delete from cache (harmless even if removal fails)\n            if (this._cache) {\n                this._cache.remove(p);\n            }\n            const tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), fileName = path.basename(p);\n            // Step 1: Get parent directory's node and directory listing.\n            this.findINodeAndDirListing(tx, parent, (e, parentNode, parentListing) => {\n                if (noErrorTx(e, tx, cb)) {\n                    if (!parentListing[fileName]) {\n                        tx.abort(() => {\n                            cb(ApiError.ENOENT(p));\n                        });\n                    }\n                    else {\n                        // Remove from directory listing of parent.\n                        const fileNodeId = parentListing[fileName];\n                        delete parentListing[fileName];\n                        // Step 2: Get file inode.\n                        this.getINode(tx, p, fileNodeId, (e, fileNode) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (!isDir && fileNode.isDirectory()) {\n                                    tx.abort(() => {\n                                        cb(ApiError.EISDIR(p));\n                                    });\n                                }\n                                else if (isDir && !fileNode.isDirectory()) {\n                                    tx.abort(() => {\n                                        cb(ApiError.ENOTDIR(p));\n                                    });\n                                }\n                                else {\n                                    // Step 3: Delete data.\n                                    tx.del(fileNode.id, (e) => {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            // Step 4: Delete node.\n                                            tx.del(fileNodeId, (e) => {\n                                                if (noErrorTx(e, tx, cb)) {\n                                                    // Step 5: Update directory listing.\n                                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, (e) => {\n                                                        if (noErrorTx(e, tx, cb)) {\n                                                            tx.commit(cb);\n                                                        }\n                                                    });\n                                                }\n                                            });\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    }\n\n\n    return {\n        SimpleSyncRWTransaction: SimpleSyncRWTransaction,\n        SyncKeyValueFile: SyncKeyValueFile,\n        SyncKeyValueFileSystem: SyncKeyValueFileSystem,\n        AsyncKeyValueFile: AsyncKeyValueFile,\n        AsyncKeyValueFileSystem: AsyncKeyValueFileSystem\n    };\n});\ndefine('skylark-browserfs/backend/InMemory',['../generic/key_value_filesystem'], function (key_value_filesystem) {\n    'use strict';\n\n    const { SimpleSyncRWTransaction, SyncKeyValueFileSystem } = key_value_filesystem;\n    /**\n     * A simple in-memory key-value store backed by a JavaScript object.\n     */\n    class InMemoryStore {\n        constructor() {\n            this.store = {};\n        }\n        name() { return InMemoryFileSystem.Name; }\n        clear() { this.store = {}; }\n        beginTransaction(type) {\n            return new SimpleSyncRWTransaction(this);\n        }\n        get(key) {\n            return this.store[key];\n        }\n        put(key, data, overwrite) {\n            if (!overwrite && this.store.hasOwnProperty(key)) {\n                return false;\n            }\n            this.store[key] = data;\n            return true;\n        }\n        del(key) {\n            delete this.store[key];\n        }\n    }\n    /**\n     * A simple in-memory file system backed by an InMemoryStore.\n     * Files are not persisted across page loads.\n     */\n    class InMemoryFileSystem extends SyncKeyValueFileSystem {\n        constructor() {\n            super({ store: new InMemoryStore() });\n        }\n        /**\n         * Creates an InMemoryFileSystem instance.\n         */\n        static Create(options, cb) {\n            cb(null, new InMemoryFileSystem());\n        }\n    }\n    InMemoryFileSystem.Name = \"InMemory\";\n    InMemoryFileSystem.Options = {};\n\n    InMemoryFileSystem.InMemoryStore = InMemoryStore;\n\n    return InMemoryFileSystem;\n});\ndefine('skylark-browserfs/backend/IndexedDB',[\n    '../generic/key_value_filesystem',\n    '../core/api_error',\n    '../core/global',\n    '../core/util'\n], function (key_value_filesystem, api_error, global, util) {\n    'use strict';\n    const { AsyncKeyValueFileSystem } =  key_value_filesystem;\n    const { ApiError, ErrorCode }  = api_error;\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = util;\n\n    /**\n     * Get the indexedDB constructor for the current browser.\n     * @hidden\n     */\n    const indexedDB = global.indexedDB ||\n        global.mozIndexedDB ||\n        global.webkitIndexedDB ||\n        global.msIndexedDB;\n    /**\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\n     * standardized BrowserFS API error.\n     * @hidden\n     */\n    function convertError(e, message = e.toString()) {\n        switch (e.name) {\n            case \"NotFoundError\":\n                return new ApiError(ErrorCode.ENOENT, message);\n            case \"QuotaExceededError\":\n                return new ApiError(ErrorCode.ENOSPC, message);\n            default:\n                // The rest do not seem to map cleanly to standard error codes.\n                return new ApiError(ErrorCode.EIO, message);\n        }\n    }\n    /**\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\n     * handle them generically: Call the user-supplied callback with a translated\n     * version of the error, and let the error bubble up.\n     * @hidden\n     */\n    function onErrorHandler(cb, code = ErrorCode.EIO, message = null) {\n        return function (e) {\n            // Prevent the error from canceling the transaction.\n            e.preventDefault();\n            cb(new ApiError(code, message !== null ? message : undefined));\n        };\n    }\n    /**\n     * @hidden\n     */\n    class IndexedDBROTransaction {\n        constructor(tx, store) {\n            this.tx = tx;\n            this.store = store;\n        }\n        get(key, cb) {\n            try {\n                const r = this.store.get(key);\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = (event) => {\n                    // IDB returns the value 'undefined' when you try to get keys that\n                    // don't exist. The caller expects this behavior.\n                    const result = event.target.result;\n                    if (result === undefined) {\n                        cb(null, result);\n                    }\n                    else {\n                        // IDB data is stored as an ArrayBuffer\n                        cb(null, arrayBuffer2Buffer(result));\n                    }\n                };\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    class IndexedDBRWTransaction extends IndexedDBROTransaction {\n        constructor(tx, store) {\n            super(tx, store);\n        }\n        put(key, data, overwrite, cb) {\n            try {\n                const arraybuffer = buffer2ArrayBuffer(data);\n                let r;\n                // Note: 'add' will never overwrite an existing key.\n                r = overwrite ? this.store.put(arraybuffer, key) : this.store.add(arraybuffer, key);\n                // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = (event) => {\n                    cb(null, true);\n                };\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n        del(key, cb) {\n            try {\n                // NOTE: IE8 has a bug with identifiers named 'delete' unless used as a string\n                // like this.\n                // http://stackoverflow.com/a/26479152\n                const r = this.store['delete'](key);\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = (event) => {\n                    cb();\n                };\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n        commit(cb) {\n            // Return to the event loop to commit the transaction.\n            setTimeout(cb, 0);\n        }\n        abort(cb) {\n            let _e = null;\n            try {\n                this.tx.abort();\n            }\n            catch (e) {\n                _e = convertError(e);\n            }\n            finally {\n                cb(_e);\n            }\n        }\n    }\n    class IndexedDBStore {\n        constructor(db, storeName) {\n            this.db = db;\n            this.storeName = storeName;\n        }\n        static Create(storeName, cb) {\n            const openReq = indexedDB.open(storeName, 1);\n            openReq.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                // Huh. This should never happen; we're at version 1. Why does another\n                // database exist?\n                if (db.objectStoreNames.contains(storeName)) {\n                    db.deleteObjectStore(storeName);\n                }\n                db.createObjectStore(storeName);\n            };\n            openReq.onsuccess = (event) => {\n                cb(null, new IndexedDBStore(event.target.result, storeName));\n            };\n            openReq.onerror = onErrorHandler(cb, ErrorCode.EACCES);\n        }\n        name() {\n            return IndexedDBFileSystem.Name + \" - \" + this.storeName;\n        }\n        clear(cb) {\n            try {\n                const tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();\n                r.onsuccess = (event) => {\n                    // Use setTimeout to commit transaction.\n                    setTimeout(cb, 0);\n                };\n                r.onerror = onErrorHandler(cb);\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n        beginTransaction(type = 'readonly') {\n            const tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);\n            if (type === 'readwrite') {\n                return new IndexedDBRWTransaction(tx, objectStore);\n            }\n            else if (type === 'readonly') {\n                return new IndexedDBROTransaction(tx, objectStore);\n            }\n            else {\n                throw new ApiError(ErrorCode.EINVAL, 'Invalid transaction type.');\n            }\n        }\n    }\n    /**\n     * A file system that uses the IndexedDB key value file system.\n     */\n    class IndexedDBFileSystem extends AsyncKeyValueFileSystem {\n        constructor(cacheSize) {\n            super(cacheSize);\n        }\n        /**\n         * Constructs an IndexedDB file system with the given options.\n         */\n        static Create(opts = {}, cb) {\n            IndexedDBStore.Create(opts.storeName ? opts.storeName : 'browserfs', (e, store) => {\n                if (store) {\n                    const idbfs = new IndexedDBFileSystem(typeof (opts.cacheSize) === 'number' ? opts.cacheSize : 100);\n                    idbfs.init(store, (e) => {\n                        if (e) {\n                            cb(e);\n                        }\n                        else {\n                            cb(null, idbfs);\n                        }\n                    });\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        static isAvailable() {\n            // In Safari's private browsing mode, indexedDB.open returns NULL.\n            // In Firefox, it throws an exception.\n            // In Chrome, it \"just works\", and clears the database when you leave the page.\n            // Untested: Opera, IE.\n            try {\n                return typeof indexedDB !== 'undefined' && null !== indexedDB.open(\"__browserfs_test__\");\n            }\n            catch (e) {\n                return false;\n            }\n        }\n    }\n    IndexedDBFileSystem.Name = \"IndexedDB\";\n    IndexedDBFileSystem.Options = {\n        storeName: {\n            type: \"string\",\n            optional: true,\n            description: \"The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name.\"\n        },\n        cacheSize: {\n            type: \"number\",\n            optional: true,\n            description: \"The size of the inode cache. Defaults to 100. A size of 0 or below disables caching.\"\n        }\n    };\n\n\n    IndexedDBFileSystem.IndexedDBROTransaction = IndexedDBROTransaction;\n    IndexedDBFileSystem.IndexedDBRWTransaction = IndexedDBRWTransaction;\n    IndexedDBFileSystem.IndexedDBStore = IndexedDBStore;\n\n    return IndexedDBFileSystem;\n});\ndefine('skylark-browserfs/backend/LocalStorage',[\n    '../libs/buffers',\n    '../generic/key_value_filesystem',\n    '../core/api_error',\n    '../core/global'\n], function (buffers,key_value_filesystem, api_error, global) {\n    'use strict';\n\n    const { SyncKeyValueFileSystem, SimpleSyncRWTransaction } = key_value_filesystem;\n    const { ApiError, ErrorCode } = api_error;\n\n    const { Buffer} = buffers;\n\n    /**\n     * Some versions of FF and all versions of IE do not support the full range of\n     * 16-bit numbers encoded as characters, as they enforce UTF-16 restrictions.\n     * @url http://stackoverflow.com/questions/11170716/are-there-any-characters-that-are-not-allowed-in-localstorage/11173673#11173673\n     * @hidden\n     */\n    let supportsBinaryString = false, binaryEncoding;\n    try {\n        global.localStorage.setItem(\"__test__\", String.fromCharCode(0xD800));\n        supportsBinaryString = global.localStorage.getItem(\"__test__\") === String.fromCharCode(0xD800);\n    }\n    catch (e) {\n        // IE throws an exception.\n        supportsBinaryString = false;\n    }\n    binaryEncoding = supportsBinaryString ? 'binary_string' : 'binary_string_ie';\n    if (!Buffer.isEncoding(binaryEncoding)) {\n        // Fallback for non BrowserFS implementations of buffer that lack a\n        // binary_string format.\n        binaryEncoding = \"base64\";\n    }\n    /**\n     * A synchronous key-value store backed by localStorage.\n     */\n    class LocalStorageStore {\n        name() {\n            return LocalStorageFileSystem.Name;\n        }\n        clear() {\n            global.localStorage.clear();\n        }\n        beginTransaction(type) {\n            // No need to differentiate.\n            return new SimpleSyncRWTransaction(this);\n        }\n        get(key) {\n            try {\n                const data = global.localStorage.getItem(key);\n                if (data !== null) {\n                    return Buffer.from(data, binaryEncoding);\n                }\n            }\n            catch (e) {\n                // Do nothing.\n            }\n            // Key doesn't exist, or a failure occurred.\n            return undefined;\n        }\n        put(key, data, overwrite) {\n            try {\n                if (!overwrite && global.localStorage.getItem(key) !== null) {\n                    // Don't want to overwrite the key!\n                    return false;\n                }\n                global.localStorage.setItem(key, data.toString(binaryEncoding));\n                return true;\n            }\n            catch (e) {\n                throw new ApiError(ErrorCode.ENOSPC, \"LocalStorage is full.\");\n            }\n        }\n        del(key) {\n            try {\n                global.localStorage.removeItem(key);\n            }\n            catch (e) {\n                throw new ApiError(ErrorCode.EIO, \"Unable to delete key \" + key + \": \" + e);\n            }\n        }\n    }\n    /**\n     * A synchronous file system backed by localStorage. Connects our\n     * LocalStorageStore to our SyncKeyValueFileSystem.\n     */\n    class LocalStorageFileSystem extends SyncKeyValueFileSystem {\n        /**\n         * Creates a new LocalStorage file system using the contents of `localStorage`.\n         */\n        constructor() { super({ store: new LocalStorageStore() }); }\n        /**\n         * Creates a LocalStorageFileSystem instance.\n         */\n        static Create(options, cb) {\n            cb(null, new LocalStorageFileSystem());\n        }\n        static isAvailable() {\n            return typeof global.localStorage !== 'undefined';\n        }\n    }\n    LocalStorageFileSystem.Name = \"LocalStorage\";\n    LocalStorageFileSystem.Options = {};\n    \n    LocalStorageFileSystem.LocalStorageStore = LocalStorageStore;\n\n    return LocalStorageFileSystem;\n});\ndefine('skylark-browserfs/backend/MountableFileSystem',[\n    '../core/file_system',\n    './InMemory',\n    '../core/api_error',\n    '../core/node_fs',\n    '../libs/path',\n    '../core/util'\n], function (file_system, InMemory, api_error, fs, path, util) {\n    'use strict';\n    const { BaseFileSystem } = file_system;\n    const {InMemoryFileSystem}  = InMemory;\n    const { ApiError, ErrorCode }  = api_error;\n    const { mkdirpSync }  = util;\n\n    /**\n     * The MountableFileSystem allows you to mount multiple backend types or\n     * multiple instantiations of the same backend into a single file system tree.\n     * The file systems do not need to know about each other; all interactions are\n     * automatically facilitated through this interface.\n     *\n     * For example, if a file system is mounted at /mnt/blah, and a request came in\n     * for /mnt/blah/foo.txt, the file system would see a request for /foo.txt.\n     *\n     * You can mount file systems when you configure the file system:\n     * ```javascript\n     * BrowserFS.configure({\n     *   fs: \"MountableFileSystem\",\n     *   options: {\n     *     '/data': { fs: 'HTTPRequest', options: { index: \"http://mysite.com/files/index.json\" } },\n     *     '/home': { fs: 'LocalStorage' }\n     *   }\n     * }, function(e) {\n     *\n     * });\n     * ```\n     *\n     * For advanced users, you can also mount file systems *after* MFS is constructed:\n     * ```javascript\n     * BrowserFS.FileSystem.HTTPRequest.Create({\n     *   index: \"http://mysite.com/files/index.json\"\n     * }, function(e, xhrfs) {\n     *   BrowserFS.FileSystem.MountableFileSystem.Create({\n     *     '/data': xhrfs\n     *   }, function(e, mfs) {\n     *     BrowserFS.initialize(mfs);\n     *\n     *     // Added after-the-fact...\n     *     BrowserFS.FileSystem.LocalStorage.Create(function(e, lsfs) {\n     *       mfs.mount('/home', lsfs);\n     *     });\n     *   });\n     * });\n     * ```\n     *\n     * Since MountableFileSystem simply proxies requests to mounted file systems, it supports all of the operations that the mounted file systems support.\n     *\n     * With no mounted file systems, `MountableFileSystem` acts as a simple `InMemory` filesystem.\n     */\n    class MountableFileSystem extends BaseFileSystem {\n        /**\n         * Creates a new, empty MountableFileSystem.\n         */\n        constructor(rootFs) {\n            super();\n            // Contains the list of mount points in mntMap, sorted by string length in decreasing order.\n            // Ensures that we scan the most specific mount points for a match first, which lets us\n            // nest mount points.\n            this.mountList = [];\n            this.mntMap = {};\n            this.rootFs = rootFs;\n        }\n        /**\n         * Creates a MountableFileSystem instance with the given options.\n         */\n        static Create(opts, cb) {\n            InMemoryFileSystem.Create({}, (e, imfs) => {\n                if (imfs) {\n                    const fs = new MountableFileSystem(imfs);\n                    try {\n                        Object.keys(opts).forEach((mountPoint) => {\n                            fs.mount(mountPoint, opts[mountPoint]);\n                        });\n                    }\n                    catch (e) {\n                        return cb(e);\n                    }\n                    cb(null, fs);\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        static isAvailable() {\n            return true;\n        }\n        /**\n         * Mounts the file system at the given mount point.\n         */\n        mount(mountPoint, fs) {\n            if (mountPoint[0] !== '/') {\n                mountPoint = `/${mountPoint}`;\n            }\n            mountPoint = path.resolve(mountPoint);\n            if (this.mntMap[mountPoint]) {\n                throw new ApiError(ErrorCode.EINVAL, \"Mount point \" + mountPoint + \" is already taken.\");\n            }\n            mkdirpSync(mountPoint, 0x1ff, this.rootFs);\n            this.mntMap[mountPoint] = fs;\n            this.mountList.push(mountPoint);\n            this.mountList = this.mountList.sort((a, b) => b.length - a.length);\n        }\n        umount(mountPoint) {\n            if (mountPoint[0] !== '/') {\n                mountPoint = `/${mountPoint}`;\n            }\n            mountPoint = path.resolve(mountPoint);\n            if (!this.mntMap[mountPoint]) {\n                throw new ApiError(ErrorCode.EINVAL, \"Mount point \" + mountPoint + \" is already unmounted.\");\n            }\n            delete this.mntMap[mountPoint];\n            this.mountList.splice(this.mountList.indexOf(mountPoint), 1);\n            while (mountPoint !== '/') {\n                if (this.rootFs.readdirSync(mountPoint).length === 0) {\n                    this.rootFs.rmdirSync(mountPoint);\n                    mountPoint = path.dirname(mountPoint);\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        /**\n         * Returns the file system that the path points to.\n         */\n        _getFs(path) {\n            const mountList = this.mountList, len = mountList.length;\n            for (let i = 0; i < len; i++) {\n                const mountPoint = mountList[i];\n                // We know path is normalized, so it is a substring of the mount point.\n                if (mountPoint.length <= path.length && path.indexOf(mountPoint) === 0) {\n                    path = path.substr(mountPoint.length > 1 ? mountPoint.length : 0);\n                    if (path === '') {\n                        path = '/';\n                    }\n                    return { fs: this.mntMap[mountPoint], path: path, mountPoint: mountPoint };\n                }\n            }\n            // Query our root file system.\n            return { fs: this.rootFs, path: path, mountPoint: '/' };\n        }\n        // Global information methods\n        getName() {\n            return MountableFileSystem.Name;\n        }\n        diskSpace(path, cb) {\n            cb(0, 0);\n        }\n        isReadOnly() {\n            return false;\n        }\n        supportsLinks() {\n            // I'm not ready for cross-FS links yet.\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return true;\n        }\n        /**\n         * Fixes up error messages so they mention the mounted file location relative\n         * to the MFS root, not to the particular FS's root.\n         * Mutates the input error, and returns it.\n         */\n        standardizeError(err, path, realPath) {\n            const index = err.message.indexOf(path);\n            if (index !== -1) {\n                err.message = err.message.substr(0, index) + realPath + err.message.substr(index + path.length);\n                err.path = realPath;\n            }\n            return err;\n        }\n        // The following methods involve multiple file systems, and thus have custom\n        // logic.\n        // Note that we go through the Node API to use its robust default argument\n        // processing.\n        rename(oldPath, newPath, cb) {\n            // Scenario 1: old and new are on same FS.\n            const fs1rv = this._getFs(oldPath);\n            const fs2rv = this._getFs(newPath);\n            if (fs1rv.fs === fs2rv.fs) {\n                return fs1rv.fs.rename(fs1rv.path, fs2rv.path, (e) => {\n                    if (e) {\n                        this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);\n                    }\n                    cb(e);\n                });\n            }\n            // Scenario 2: Different file systems.\n            // Read old file, write new file, delete old file.\n            return fs.readFile(oldPath, function (err, data) {\n                if (err) {\n                    return cb(err);\n                }\n                fs.writeFile(newPath, data, function (err) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    fs.unlink(oldPath, cb);\n                });\n            });\n        }\n        renameSync(oldPath, newPath) {\n            // Scenario 1: old and new are on same FS.\n            const fs1rv = this._getFs(oldPath);\n            const fs2rv = this._getFs(newPath);\n            if (fs1rv.fs === fs2rv.fs) {\n                try {\n                    return fs1rv.fs.renameSync(fs1rv.path, fs2rv.path);\n                }\n                catch (e) {\n                    this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);\n                    throw e;\n                }\n            }\n            // Scenario 2: Different file systems.\n            const data = fs.readFileSync(oldPath);\n            fs.writeFileSync(newPath, data);\n            return fs.unlinkSync(oldPath);\n        }\n        readdirSync(p) {\n            const fsInfo = this._getFs(p);\n            // If null, rootfs did not have the directory\n            // (or the target FS is the root fs).\n            let rv = null;\n            // Mount points are all defined in the root FS.\n            // Ensure that we list those, too.\n            if (fsInfo.fs !== this.rootFs) {\n                try {\n                    rv = this.rootFs.readdirSync(p);\n                }\n                catch (e) {\n                    // Ignore.\n                }\n            }\n            try {\n                const rv2 = fsInfo.fs.readdirSync(fsInfo.path);\n                if (rv === null) {\n                    return rv2;\n                }\n                else {\n                    // Filter out duplicates.\n                    return rv2.concat(rv.filter((val) => rv2.indexOf(val) === -1));\n                }\n            }\n            catch (e) {\n                if (rv === null) {\n                    throw this.standardizeError(e, fsInfo.path, p);\n                }\n                else {\n                    // The root FS had something.\n                    return rv;\n                }\n            }\n        }\n        readdir(p, cb) {\n            const fsInfo = this._getFs(p);\n            fsInfo.fs.readdir(fsInfo.path, (err, files) => {\n                if (fsInfo.fs !== this.rootFs) {\n                    try {\n                        const rv = this.rootFs.readdirSync(p);\n                        if (files) {\n                            // Filter out duplicates.\n                            files = files.concat(rv.filter((val) => files.indexOf(val) === -1));\n                        }\n                        else {\n                            files = rv;\n                        }\n                    }\n                    catch (e) {\n                        // Root FS and target FS did not have directory.\n                        if (err) {\n                            return cb(this.standardizeError(err, fsInfo.path, p));\n                        }\n                    }\n                }\n                else if (err) {\n                    // Root FS and target FS are the same, and did not have directory.\n                    return cb(this.standardizeError(err, fsInfo.path, p));\n                }\n                cb(null, files);\n            });\n        }\n        realpathSync(p, cache) {\n            const fsInfo = this._getFs(p);\n            try {\n                const mountedPath = fsInfo.fs.realpathSync(fsInfo.path, {});\n                // resolve is there to remove any trailing slash that may be present\n                return path.resolve(path.join(fsInfo.mountPoint, mountedPath));\n            }\n            catch (e) {\n                throw this.standardizeError(e, fsInfo.path, p);\n            }\n        }\n        realpath(p, cache, cb) {\n            const fsInfo = this._getFs(p);\n            fsInfo.fs.realpath(fsInfo.path, {}, (err, rv) => {\n                if (err) {\n                    cb(this.standardizeError(err, fsInfo.path, p));\n                }\n                else {\n                    // resolve is there to remove any trailing slash that may be present\n                    cb(null, path.resolve(path.join(fsInfo.mountPoint, rv)));\n                }\n            });\n        }\n        rmdirSync(p) {\n            const fsInfo = this._getFs(p);\n            if (this._containsMountPt(p)) {\n                throw ApiError.ENOTEMPTY(p);\n            }\n            else {\n                try {\n                    fsInfo.fs.rmdirSync(fsInfo.path);\n                }\n                catch (e) {\n                    throw this.standardizeError(e, fsInfo.path, p);\n                }\n            }\n        }\n        rmdir(p, cb) {\n            const fsInfo = this._getFs(p);\n            if (this._containsMountPt(p)) {\n                cb(ApiError.ENOTEMPTY(p));\n            }\n            else {\n                fsInfo.fs.rmdir(fsInfo.path, (err) => {\n                    cb(err ? this.standardizeError(err, fsInfo.path, p) : null);\n                });\n            }\n        }\n        /**\n         * Returns true if the given path contains a mount point.\n         */\n        _containsMountPt(p) {\n            const mountPoints = this.mountList, len = mountPoints.length;\n            for (let i = 0; i < len; i++) {\n                const pt = mountPoints[i];\n                if (pt.length >= p.length && pt.slice(0, p.length) === p) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    MountableFileSystem.Name = \"MountableFileSystem\";\n    MountableFileSystem.Options = {};\n    /**\n     * Tricky: Define all of the functions that merely forward arguments to the\n     * relevant file system, or return/throw an error.\n     * Take advantage of the fact that the *first* argument is always the path, and\n     * the *last* is the callback function (if async).\n     * @todo Can use numArgs to make proxying more efficient.\n     * @hidden\n     */\n    function defineFcn(name, isSync, numArgs) {\n        if (isSync) {\n            return function (...args) {\n                const path = args[0];\n                const rv = this._getFs(path);\n                args[0] = rv.path;\n                try {\n                    return rv.fs[name].apply(rv.fs, args);\n                }\n                catch (e) {\n                    this.standardizeError(e, rv.path, path);\n                    throw e;\n                }\n            };\n        }\n        else {\n            return function (...args) {\n                const path = args[0];\n                const rv = this._getFs(path);\n                args[0] = rv.path;\n                if (typeof args[args.length - 1] === 'function') {\n                    const cb = args[args.length - 1];\n                    args[args.length - 1] = (...args) => {\n                        if (args.length > 0 && args[0] instanceof ApiError) {\n                            this.standardizeError(args[0], rv.path, path);\n                        }\n                        cb.apply(null, args);\n                    };\n                }\n                return rv.fs[name].apply(rv.fs, args);\n            };\n        }\n    }\n    /**\n     * @hidden\n     */\n    const fsCmdMap = [\n        // 1 arg functions\n        ['exists', 'unlink', 'readlink'],\n        // 2 arg functions\n        ['stat', 'mkdir', 'truncate'],\n        // 3 arg functions\n        ['open', 'readFile', 'chmod', 'utimes'],\n        // 4 arg functions\n        ['chown'],\n        // 5 arg functions\n        ['writeFile', 'appendFile']\n    ];\n    for (let i = 0; i < fsCmdMap.length; i++) {\n        const cmds = fsCmdMap[i];\n        for (const fnName of cmds) {\n            MountableFileSystem.prototype[fnName] = defineFcn(fnName, false, i + 1);\n            MountableFileSystem.prototype[fnName + 'Sync'] = defineFcn(fnName + 'Sync', true, i + 1);\n        }\n    }\n\n\n    return MountableFileSystem;\n});\ndefine('skylark-browserfs/generic/mutex',['../generic/setImmediate'], function (setImmediate) {\n    'use strict';\n    /**\n     * Non-recursive mutex\n     * @hidden\n     */\n    class Mutex {\n        constructor() {\n            this._locked = false;\n            this._waiters = [];\n        }\n        lock(cb) {\n            if (this._locked) {\n                this._waiters.push(cb);\n                return;\n            }\n            this._locked = true;\n            cb();\n        }\n        unlock() {\n            if (!this._locked) {\n                throw new Error('unlock of a non-locked mutex');\n            }\n            const next = this._waiters.shift();\n            // don't unlock - we want to queue up next for the\n            // _end_ of the current task execution, but we don't\n            // want it to be called inline with whatever the\n            // current stack is.  This way we still get the nice\n            // behavior that an unlock immediately followed by a\n            // lock won't cause starvation.\n            if (next) {\n                setImmediate(next);\n                return;\n            }\n            this._locked = false;\n        }\n        tryLock() {\n            if (this._locked) {\n                return false;\n            }\n            this._locked = true;\n            return true;\n        }\n        isLocked() {\n            return this._locked;\n        }\n    }\n\n    return Mutex;\n});\ndefine('skylark-browserfs/generic/locked_fs',['./mutex'], function (Mutex) {\n    'use strict';\n    /**\n     * This class serializes access to an underlying async filesystem.\n     * For example, on an OverlayFS instance with an async lower\n     * directory operations like rename and rmdir may involve multiple\n     * requests involving both the upper and lower filesystems -- they\n     * are not executed in a single atomic step.  OverlayFS uses this\n     * LockedFS to avoid having to reason about the correctness of\n     * multiple requests interleaving.\n     */\n    class LockedFS {\n        constructor(fs) {\n            this._fs = fs;\n            this._mu = new Mutex();\n        }\n        getName() {\n            return 'LockedFS<' + this._fs.getName() + '>';\n        }\n        getFSUnlocked() {\n            return this._fs;\n        }\n        diskSpace(p, cb) {\n            // FIXME: should this lock?\n            this._fs.diskSpace(p, cb);\n        }\n        isReadOnly() {\n            return this._fs.isReadOnly();\n        }\n        supportsLinks() {\n            return this._fs.supportsLinks();\n        }\n        supportsProps() {\n            return this._fs.supportsProps();\n        }\n        supportsSynch() {\n            return this._fs.supportsSynch();\n        }\n        rename(oldPath, newPath, cb) {\n            this._mu.lock(() => {\n                this._fs.rename(oldPath, newPath, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        renameSync(oldPath, newPath) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.renameSync(oldPath, newPath);\n        }\n        stat(p, isLstat, cb) {\n            this._mu.lock(() => {\n                this._fs.stat(p, isLstat, (err, stat) => {\n                    this._mu.unlock();\n                    cb(err, stat);\n                });\n            });\n        }\n        statSync(p, isLstat) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.statSync(p, isLstat);\n        }\n        open(p, flag, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.open(p, flag, mode, (err, fd) => {\n                    this._mu.unlock();\n                    cb(err, fd);\n                });\n            });\n        }\n        openSync(p, flag, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.openSync(p, flag, mode);\n        }\n        unlink(p, cb) {\n            this._mu.lock(() => {\n                this._fs.unlink(p, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        unlinkSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.unlinkSync(p);\n        }\n        rmdir(p, cb) {\n            this._mu.lock(() => {\n                this._fs.rmdir(p, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        rmdirSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.rmdirSync(p);\n        }\n        mkdir(p, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.mkdir(p, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        mkdirSync(p, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.mkdirSync(p, mode);\n        }\n        readdir(p, cb) {\n            this._mu.lock(() => {\n                this._fs.readdir(p, (err, files) => {\n                    this._mu.unlock();\n                    cb(err, files);\n                });\n            });\n        }\n        readdirSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.readdirSync(p);\n        }\n        exists(p, cb) {\n            this._mu.lock(() => {\n                this._fs.exists(p, (exists) => {\n                    this._mu.unlock();\n                    cb(exists);\n                });\n            });\n        }\n        existsSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.existsSync(p);\n        }\n        realpath(p, cache, cb) {\n            this._mu.lock(() => {\n                this._fs.realpath(p, cache, (err, resolvedPath) => {\n                    this._mu.unlock();\n                    cb(err, resolvedPath);\n                });\n            });\n        }\n        realpathSync(p, cache) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.realpathSync(p, cache);\n        }\n        truncate(p, len, cb) {\n            this._mu.lock(() => {\n                this._fs.truncate(p, len, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        truncateSync(p, len) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.truncateSync(p, len);\n        }\n        readFile(fname, encoding, flag, cb) {\n            this._mu.lock(() => {\n                this._fs.readFile(fname, encoding, flag, (err, data) => {\n                    this._mu.unlock();\n                    cb(err, data);\n                });\n            });\n        }\n        readFileSync(fname, encoding, flag) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.readFileSync(fname, encoding, flag);\n        }\n        writeFile(fname, data, encoding, flag, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.writeFile(fname, data, encoding, flag, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        writeFileSync(fname, data, encoding, flag, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.writeFileSync(fname, data, encoding, flag, mode);\n        }\n        appendFile(fname, data, encoding, flag, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.appendFile(fname, data, encoding, flag, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        appendFileSync(fname, data, encoding, flag, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.appendFileSync(fname, data, encoding, flag, mode);\n        }\n        chmod(p, isLchmod, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.chmod(p, isLchmod, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        chmodSync(p, isLchmod, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.chmodSync(p, isLchmod, mode);\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            this._mu.lock(() => {\n                this._fs.chown(p, isLchown, uid, gid, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        chownSync(p, isLchown, uid, gid) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.chownSync(p, isLchown, uid, gid);\n        }\n        utimes(p, atime, mtime, cb) {\n            this._mu.lock(() => {\n                this._fs.utimes(p, atime, mtime, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        utimesSync(p, atime, mtime) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.utimesSync(p, atime, mtime);\n        }\n        link(srcpath, dstpath, cb) {\n            this._mu.lock(() => {\n                this._fs.link(srcpath, dstpath, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        linkSync(srcpath, dstpath) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.linkSync(srcpath, dstpath);\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            this._mu.lock(() => {\n                this._fs.symlink(srcpath, dstpath, type, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        symlinkSync(srcpath, dstpath, type) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.symlinkSync(srcpath, dstpath, type);\n        }\n        readlink(p, cb) {\n            this._mu.lock(() => {\n                this._fs.readlink(p, (err, linkString) => {\n                    this._mu.unlock();\n                    cb(err, linkString);\n                });\n            });\n        }\n        readlinkSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.readlinkSync(p);\n        }\n    }\n\n    return LockedFS;\n});\ndefine('skylark-browserfs/backend/OverlayFS',[\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/node_fs_stats',\n    '../generic/preload_file',\n    '../generic/locked_fs',\n    '../libs/path'\n], function (file_system, api_error, file_flag, node_fs_stats, preload_file, LockedFS, path) {\n\n    'use strict';\n\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode }  = api_error;\n    const { FileFlag, ActionType }  = file_flag;\n    const { Stats }  = node_fs_stats;\n    const {PreloadFile}  = preload_file;\n\n    /**\n     * @hidden\n     */\n    const deletionLogPath = '/.deletedFiles.log';\n    /**\n     * Given a read-only mode, makes it writable.\n     * @hidden\n     */\n    function makeModeWritable(mode) {\n        return 0o222 | mode;\n    }\n    /**\n     * @hidden\n     */\n    function getFlag(f) {\n        return FileFlag.getFileFlag(f);\n    }\n    /**\n     * Overlays a RO file to make it writable.\n     */\n    class OverlayFile extends PreloadFile {\n        constructor(fs, path, flag, stats, data) {\n            super(fs, path, flag, stats, data);\n        }\n        sync(cb) {\n            if (!this.isDirty()) {\n                cb(null);\n                return;\n            }\n            this._fs._syncAsync(this, (err) => {\n                this.resetDirty();\n                cb(err);\n            });\n        }\n        syncSync() {\n            if (this.isDirty()) {\n                this._fs._syncSync(this);\n                this.resetDirty();\n            }\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n        closeSync() {\n            this.syncSync();\n        }\n    }\n    /**\n     * *INTERNAL, DO NOT USE DIRECTLY!*\n     *\n     * Core OverlayFS class that contains no locking whatsoever. We wrap these objects\n     * in a LockedFS to prevent races.\n     */\n    class UnlockedOverlayFS extends BaseFileSystem {\n        constructor(writable, readable) {\n            super();\n            this._isInitialized = false;\n            this._initializeCallbacks = [];\n            this._deletedFiles = {};\n            this._deleteLog = '';\n            // If 'true', we have scheduled a delete log update.\n            this._deleteLogUpdatePending = false;\n            // If 'true', a delete log update is needed after the scheduled delete log\n            // update finishes.\n            this._deleteLogUpdateNeeded = false;\n            // If there was an error updating the delete log...\n            this._deleteLogError = null;\n            this._writable = writable;\n            this._readable = readable;\n            if (this._writable.isReadOnly()) {\n                throw new ApiError(ErrorCode.EINVAL, \"Writable file system must be writable.\");\n            }\n        }\n        static isAvailable() {\n            return true;\n        }\n        getOverlayedFileSystems() {\n            return {\n                readable: this._readable,\n                writable: this._writable\n            };\n        }\n        _syncAsync(file, cb) {\n            this.createParentDirectoriesAsync(file.getPath(), (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                this._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);\n            });\n        }\n        _syncSync(file) {\n            this.createParentDirectories(file.getPath());\n            this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);\n        }\n        getName() {\n            return OverlayFS.Name;\n        }\n        /**\n         * **INTERNAL METHOD**\n         *\n         * Called once to load up metadata stored on the writable file system.\n         */\n        _initialize(cb) {\n            const callbackArray = this._initializeCallbacks;\n            const end = (e) => {\n                this._isInitialized = !e;\n                this._initializeCallbacks = [];\n                callbackArray.forEach(((cb) => cb(e)));\n            };\n            // if we're already initialized, immediately invoke the callback\n            if (this._isInitialized) {\n                return cb();\n            }\n            callbackArray.push(cb);\n            // The first call to initialize initializes, the rest wait for it to complete.\n            if (callbackArray.length !== 1) {\n                return;\n            }\n            // Read deletion log, process into metadata.\n            this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), (err, data) => {\n                if (err) {\n                    // ENOENT === Newly-instantiated file system, and thus empty log.\n                    if (err.errno !== ErrorCode.ENOENT) {\n                        return end(err);\n                    }\n                }\n                else {\n                    this._deleteLog = data;\n                }\n                this._reparseDeletionLog();\n                end();\n            });\n        }\n        isReadOnly() { return false; }\n        supportsSynch() { return this._readable.supportsSynch() && this._writable.supportsSynch(); }\n        supportsLinks() { return false; }\n        supportsProps() { return this._readable.supportsProps() && this._writable.supportsProps(); }\n        getDeletionLog() {\n            return this._deleteLog;\n        }\n        restoreDeletionLog(log) {\n            this._deleteLog = log;\n            this._reparseDeletionLog();\n            this.updateLog('');\n        }\n        rename(oldPath, newPath, cb) {\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {\n                return;\n            }\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\n                return cb(ApiError.EPERM('Cannot rename deletion log.'));\n            }\n            // nothing to do if paths match\n            if (oldPath === newPath) {\n                return cb();\n            }\n            this.stat(oldPath, false, (oldErr, oldStats) => {\n                if (oldErr) {\n                    return cb(oldErr);\n                }\n                return this.stat(newPath, false, (newErr, newStats) => {\n                    const self = this;\n                    // precondition: both oldPath and newPath exist and are dirs.\n                    // decreases: |files|\n                    // Need to move *every file/folder* currently stored on\n                    // readable to its new location on writable.\n                    function copyDirContents(files) {\n                        const file = files.shift();\n                        if (!file) {\n                            return cb();\n                        }\n                        const oldFile = path.resolve(oldPath, file);\n                        const newFile = path.resolve(newPath, file);\n                        // Recursion! Should work for any nested files / folders.\n                        self.rename(oldFile, newFile, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            copyDirContents(files);\n                        });\n                    }\n                    let mode = 0o777;\n                    // from linux's rename(2) manpage: oldpath can specify a\n                    // directory.  In this case, newpath must either not exist, or\n                    // it must specify an empty directory.\n                    if (oldStats.isDirectory()) {\n                        if (newErr) {\n                            if (newErr.errno !== ErrorCode.ENOENT) {\n                                return cb(newErr);\n                            }\n                            return this._writable.exists(oldPath, (exists) => {\n                                // simple case - both old and new are on the writable layer\n                                if (exists) {\n                                    return this._writable.rename(oldPath, newPath, cb);\n                                }\n                                this._writable.mkdir(newPath, mode, (mkdirErr) => {\n                                    if (mkdirErr) {\n                                        return cb(mkdirErr);\n                                    }\n                                    this._readable.readdir(oldPath, (err, files) => {\n                                        if (err) {\n                                            return cb();\n                                        }\n                                        copyDirContents(files);\n                                    });\n                                });\n                            });\n                        }\n                        mode = newStats.mode;\n                        if (!newStats.isDirectory()) {\n                            return cb(ApiError.ENOTDIR(newPath));\n                        }\n                        this.readdir(newPath, (readdirErr, files) => {\n                            if (files && files.length) {\n                                return cb(ApiError.ENOTEMPTY(newPath));\n                            }\n                            this._readable.readdir(oldPath, (err, files) => {\n                                if (err) {\n                                    return cb();\n                                }\n                                copyDirContents(files);\n                            });\n                        });\n                    }\n                    if (newStats && newStats.isDirectory()) {\n                        return cb(ApiError.EISDIR(newPath));\n                    }\n                    this.readFile(oldPath, null, getFlag('r'), (err, data) => {\n                        if (err) {\n                            return cb(err);\n                        }\n                        return this.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            return this.unlink(oldPath, cb);\n                        });\n                    });\n                });\n            });\n        }\n        renameSync(oldPath, newPath) {\n            this.checkInitialized();\n            this.checkPath(oldPath);\n            this.checkPath(newPath);\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\n                throw ApiError.EPERM('Cannot rename deletion log.');\n            }\n            // Write newPath using oldPath's contents, delete oldPath.\n            const oldStats = this.statSync(oldPath, false);\n            if (oldStats.isDirectory()) {\n                // Optimization: Don't bother moving if old === new.\n                if (oldPath === newPath) {\n                    return;\n                }\n                let mode = 0o777;\n                if (this.existsSync(newPath)) {\n                    const stats = this.statSync(newPath, false);\n                    mode = stats.mode;\n                    if (stats.isDirectory()) {\n                        if (this.readdirSync(newPath).length > 0) {\n                            throw ApiError.ENOTEMPTY(newPath);\n                        }\n                    }\n                    else {\n                        throw ApiError.ENOTDIR(newPath);\n                    }\n                }\n                // Take care of writable first. Move any files there, or create an empty directory\n                // if it doesn't exist.\n                if (this._writable.existsSync(oldPath)) {\n                    this._writable.renameSync(oldPath, newPath);\n                }\n                else if (!this._writable.existsSync(newPath)) {\n                    this._writable.mkdirSync(newPath, mode);\n                }\n                // Need to move *every file/folder* currently stored on readable to its new location\n                // on writable.\n                if (this._readable.existsSync(oldPath)) {\n                    this._readable.readdirSync(oldPath).forEach((name) => {\n                        // Recursion! Should work for any nested files / folders.\n                        this.renameSync(path.resolve(oldPath, name), path.resolve(newPath, name));\n                    });\n                }\n            }\n            else {\n                if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {\n                    throw ApiError.EISDIR(newPath);\n                }\n                this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);\n            }\n            if (oldPath !== newPath && this.existsSync(oldPath)) {\n                this.unlinkSync(oldPath);\n            }\n        }\n        stat(p, isLstat, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this._writable.stat(p, isLstat, (err, stat) => {\n                if (err && err.errno === ErrorCode.ENOENT) {\n                    if (this._deletedFiles[p]) {\n                        cb(ApiError.ENOENT(p));\n                    }\n                    this._readable.stat(p, isLstat, (err, stat) => {\n                        if (stat) {\n                            // Make the oldStat's mode writable. Preserve the topmost\n                            // part of the mode, which specifies if it is a file or a\n                            // directory.\n                            stat = Stats.clone(stat);\n                            stat.mode = makeModeWritable(stat.mode);\n                        }\n                        cb(err, stat);\n                    });\n                }\n                else {\n                    cb(err, stat);\n                }\n            });\n        }\n        statSync(p, isLstat) {\n            this.checkInitialized();\n            try {\n                return this._writable.statSync(p, isLstat);\n            }\n            catch (e) {\n                if (this._deletedFiles[p]) {\n                    throw ApiError.ENOENT(p);\n                }\n                const oldStat = Stats.clone(this._readable.statSync(p, isLstat));\n                // Make the oldStat's mode writable. Preserve the topmost part of the\n                // mode, which specifies if it is a file or a directory.\n                oldStat.mode = makeModeWritable(oldStat.mode);\n                return oldStat;\n            }\n        }\n        open(p, flag, mode, cb) {\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\n                return;\n            }\n            this.stat(p, false, (err, stats) => {\n                if (stats) {\n                    switch (flag.pathExistsAction()) {\n                        case ActionType.TRUNCATE_FILE:\n                            return this.createParentDirectoriesAsync(p, (err) => {\n                                if (err) {\n                                    return cb(err);\n                                }\n                                this._writable.open(p, flag, mode, cb);\n                            });\n                        case ActionType.NOP:\n                            return this._writable.exists(p, (exists) => {\n                                if (exists) {\n                                    this._writable.open(p, flag, mode, cb);\n                                }\n                                else {\n                                    // at this point we know the stats object we got is from\n                                    // the readable FS.\n                                    stats = Stats.clone(stats);\n                                    stats.mode = mode;\n                                    this._readable.readFile(p, null, getFlag('r'), (readFileErr, data) => {\n                                        if (readFileErr) {\n                                            return cb(readFileErr);\n                                        }\n                                        if (stats.size === -1) {\n                                            stats.size = data.length;\n                                        }\n                                        const f = new OverlayFile(this, p, flag, stats, data);\n                                        cb(null, f);\n                                    });\n                                }\n                            });\n                        default:\n                            return cb(ApiError.EEXIST(p));\n                    }\n                }\n                else {\n                    switch (flag.pathNotExistsAction()) {\n                        case ActionType.CREATE_FILE:\n                            return this.createParentDirectoriesAsync(p, (err) => {\n                                if (err) {\n                                    return cb(err);\n                                }\n                                return this._writable.open(p, flag, mode, cb);\n                            });\n                        default:\n                            return cb(ApiError.ENOENT(p));\n                    }\n                }\n            });\n        }\n        openSync(p, flag, mode) {\n            this.checkInitialized();\n            this.checkPath(p);\n            if (p === deletionLogPath) {\n                throw ApiError.EPERM('Cannot open deletion log.');\n            }\n            if (this.existsSync(p)) {\n                switch (flag.pathExistsAction()) {\n                    case ActionType.TRUNCATE_FILE:\n                        this.createParentDirectories(p);\n                        return this._writable.openSync(p, flag, mode);\n                    case ActionType.NOP:\n                        if (this._writable.existsSync(p)) {\n                            return this._writable.openSync(p, flag, mode);\n                        }\n                        else {\n                            // Create an OverlayFile.\n                            const buf = this._readable.readFileSync(p, null, getFlag('r'));\n                            const stats = Stats.clone(this._readable.statSync(p, false));\n                            stats.mode = mode;\n                            return new OverlayFile(this, p, flag, stats, buf);\n                        }\n                    default:\n                        throw ApiError.EEXIST(p);\n                }\n            }\n            else {\n                switch (flag.pathNotExistsAction()) {\n                    case ActionType.CREATE_FILE:\n                        this.createParentDirectories(p);\n                        return this._writable.openSync(p, flag, mode);\n                    default:\n                        throw ApiError.ENOENT(p);\n                }\n            }\n        }\n        unlink(p, cb) {\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\n                return;\n            }\n            this.exists(p, (exists) => {\n                if (!exists) {\n                    return cb(ApiError.ENOENT(p));\n                }\n                this._writable.exists(p, (writableExists) => {\n                    if (writableExists) {\n                        return this._writable.unlink(p, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            this.exists(p, (readableExists) => {\n                                if (readableExists) {\n                                    this.deletePath(p);\n                                }\n                                cb(null);\n                            });\n                        });\n                    }\n                    else {\n                        // if this only exists on the readable FS, add it to the\n                        // delete map.\n                        this.deletePath(p);\n                        cb(null);\n                    }\n                });\n            });\n        }\n        unlinkSync(p) {\n            this.checkInitialized();\n            this.checkPath(p);\n            if (this.existsSync(p)) {\n                if (this._writable.existsSync(p)) {\n                    this._writable.unlinkSync(p);\n                }\n                // if it still exists add to the delete log\n                if (this.existsSync(p)) {\n                    this.deletePath(p);\n                }\n            }\n            else {\n                throw ApiError.ENOENT(p);\n            }\n        }\n        rmdir(p, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            const rmdirLower = () => {\n                this.readdir(p, (err, files) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    if (files.length) {\n                        return cb(ApiError.ENOTEMPTY(p));\n                    }\n                    this.deletePath(p);\n                    cb(null);\n                });\n            };\n            this.exists(p, (exists) => {\n                if (!exists) {\n                    return cb(ApiError.ENOENT(p));\n                }\n                this._writable.exists(p, (writableExists) => {\n                    if (writableExists) {\n                        this._writable.rmdir(p, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            this._readable.exists(p, (readableExists) => {\n                                if (readableExists) {\n                                    rmdirLower();\n                                }\n                                else {\n                                    cb();\n                                }\n                            });\n                        });\n                    }\n                    else {\n                        rmdirLower();\n                    }\n                });\n            });\n        }\n        rmdirSync(p) {\n            this.checkInitialized();\n            if (this.existsSync(p)) {\n                if (this._writable.existsSync(p)) {\n                    this._writable.rmdirSync(p);\n                }\n                if (this.existsSync(p)) {\n                    // Check if directory is empty.\n                    if (this.readdirSync(p).length > 0) {\n                        throw ApiError.ENOTEMPTY(p);\n                    }\n                    else {\n                        this.deletePath(p);\n                    }\n                }\n            }\n            else {\n                throw ApiError.ENOENT(p);\n            }\n        }\n        mkdir(p, mode, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.exists(p, (exists) => {\n                if (exists) {\n                    return cb(ApiError.EEXIST(p));\n                }\n                // The below will throw should any of the parent directories\n                // fail to exist on _writable.\n                this.createParentDirectoriesAsync(p, (err) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    this._writable.mkdir(p, mode, cb);\n                });\n            });\n        }\n        mkdirSync(p, mode) {\n            this.checkInitialized();\n            if (this.existsSync(p)) {\n                throw ApiError.EEXIST(p);\n            }\n            else {\n                // The below will throw should any of the parent directories fail to exist\n                // on _writable.\n                this.createParentDirectories(p);\n                this._writable.mkdirSync(p, mode);\n            }\n        }\n        readdir(p, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.stat(p, false, (err, dirStats) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (!dirStats.isDirectory()) {\n                    return cb(ApiError.ENOTDIR(p));\n                }\n                this._writable.readdir(p, (err, wFiles) => {\n                    if (err && err.code !== 'ENOENT') {\n                        return cb(err);\n                    }\n                    else if (err || !wFiles) {\n                        wFiles = [];\n                    }\n                    this._readable.readdir(p, (err, rFiles) => {\n                        // if the directory doesn't exist on the lower FS set rFiles\n                        // here to simplify the following code.\n                        if (err || !rFiles) {\n                            rFiles = [];\n                        }\n                        // Readdir in both, check delete log on read-only file system's files, merge, return.\n                        const seenMap = {};\n                        const filtered = wFiles.concat(rFiles.filter((fPath) => !this._deletedFiles[`${p}/${fPath}`])).filter((fPath) => {\n                            // Remove duplicates.\n                            const result = !seenMap[fPath];\n                            seenMap[fPath] = true;\n                            return result;\n                        });\n                        cb(null, filtered);\n                    });\n                });\n            });\n        }\n        readdirSync(p) {\n            this.checkInitialized();\n            const dirStats = this.statSync(p, false);\n            if (!dirStats.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n            // Readdir in both, check delete log on RO file system's listing, merge, return.\n            let contents = [];\n            try {\n                contents = contents.concat(this._writable.readdirSync(p));\n            }\n            catch (e) {\n                // NOP.\n            }\n            try {\n                contents = contents.concat(this._readable.readdirSync(p).filter((fPath) => !this._deletedFiles[`${p}/${fPath}`]));\n            }\n            catch (e) {\n                // NOP.\n            }\n            const seenMap = {};\n            return contents.filter((fileP) => {\n                const result = !seenMap[fileP];\n                seenMap[fileP] = true;\n                return result;\n            });\n        }\n        exists(p, cb) {\n            // Cannot pass an error back to callback, so throw an exception instead\n            // if not initialized.\n            this.checkInitialized();\n            this._writable.exists(p, (existsWritable) => {\n                if (existsWritable) {\n                    return cb(true);\n                }\n                this._readable.exists(p, (existsReadable) => {\n                    cb(existsReadable && this._deletedFiles[p] !== true);\n                });\n            });\n        }\n        existsSync(p) {\n            this.checkInitialized();\n            return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);\n        }\n        chmod(p, isLchmod, mode, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.operateOnWritableAsync(p, (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                else {\n                    this._writable.chmod(p, isLchmod, mode, cb);\n                }\n            });\n        }\n        chmodSync(p, isLchmod, mode) {\n            this.checkInitialized();\n            this.operateOnWritable(p, () => {\n                this._writable.chmodSync(p, isLchmod, mode);\n            });\n        }\n        chown(p, isLchmod, uid, gid, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.operateOnWritableAsync(p, (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                else {\n                    this._writable.chown(p, isLchmod, uid, gid, cb);\n                }\n            });\n        }\n        chownSync(p, isLchown, uid, gid) {\n            this.checkInitialized();\n            this.operateOnWritable(p, () => {\n                this._writable.chownSync(p, isLchown, uid, gid);\n            });\n        }\n        utimes(p, atime, mtime, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.operateOnWritableAsync(p, (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                else {\n                    this._writable.utimes(p, atime, mtime, cb);\n                }\n            });\n        }\n        utimesSync(p, atime, mtime) {\n            this.checkInitialized();\n            this.operateOnWritable(p, () => {\n                this._writable.utimesSync(p, atime, mtime);\n            });\n        }\n        deletePath(p) {\n            this._deletedFiles[p] = true;\n            this.updateLog(`d${p}\\n`);\n        }\n        updateLog(addition) {\n            this._deleteLog += addition;\n            if (this._deleteLogUpdatePending) {\n                this._deleteLogUpdateNeeded = true;\n            }\n            else {\n                this._deleteLogUpdatePending = true;\n                this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 0o644, (e) => {\n                    this._deleteLogUpdatePending = false;\n                    if (e) {\n                        this._deleteLogError = e;\n                    }\n                    else if (this._deleteLogUpdateNeeded) {\n                        this._deleteLogUpdateNeeded = false;\n                        this.updateLog('');\n                    }\n                });\n            }\n        }\n        _reparseDeletionLog() {\n            this._deletedFiles = {};\n            this._deleteLog.split('\\n').forEach((path) => {\n                // If the log entry begins w/ 'd', it's a deletion.\n                this._deletedFiles[path.slice(1)] = path.slice(0, 1) === 'd';\n            });\n        }\n        checkInitialized() {\n            if (!this._isInitialized) {\n                throw new ApiError(ErrorCode.EPERM, \"OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.\");\n            }\n            else if (this._deleteLogError !== null) {\n                const e = this._deleteLogError;\n                this._deleteLogError = null;\n                throw e;\n            }\n        }\n        checkInitAsync(cb) {\n            if (!this._isInitialized) {\n                cb(new ApiError(ErrorCode.EPERM, \"OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.\"));\n                return false;\n            }\n            else if (this._deleteLogError !== null) {\n                const e = this._deleteLogError;\n                this._deleteLogError = null;\n                cb(e);\n                return false;\n            }\n            return true;\n        }\n        checkPath(p) {\n            if (p === deletionLogPath) {\n                throw ApiError.EPERM(p);\n            }\n        }\n        checkPathAsync(p, cb) {\n            if (p === deletionLogPath) {\n                cb(ApiError.EPERM(p));\n                return true;\n            }\n            return false;\n        }\n        createParentDirectoriesAsync(p, cb) {\n            let parent = path.dirname(p);\n            const toCreate = [];\n            const self = this;\n            this._writable.stat(parent, false, statDone);\n            function statDone(err, stat) {\n                if (err) {\n                    if (parent === \"/\") {\n                        cb(new ApiError(ErrorCode.EBUSY, \"Invariant failed: root does not exist!\"));\n                    }\n                    else {\n                        toCreate.push(parent);\n                        parent = path.dirname(parent);\n                        self._writable.stat(parent, false, statDone);\n                    }\n                }\n                else {\n                    createParents();\n                }\n            }\n            function createParents() {\n                if (!toCreate.length) {\n                    return cb();\n                }\n                const dir = toCreate.pop();\n                self._readable.stat(dir, false, (err, stats) => {\n                    // stop if we couldn't read the dir\n                    if (!stats) {\n                        return cb();\n                    }\n                    self._writable.mkdir(dir, stats.mode, (err) => {\n                        if (err) {\n                            return cb(err);\n                        }\n                        createParents();\n                    });\n                });\n            }\n        }\n        /**\n         * With the given path, create the needed parent directories on the writable storage\n         * should they not exist. Use modes from the read-only storage.\n         */\n        createParentDirectories(p) {\n            let parent = path.dirname(p), toCreate = [];\n            while (!this._writable.existsSync(parent)) {\n                toCreate.push(parent);\n                parent = path.dirname(parent);\n            }\n            toCreate = toCreate.reverse();\n            toCreate.forEach((p) => {\n                this._writable.mkdirSync(p, this.statSync(p, false).mode);\n            });\n        }\n        /**\n         * Helper function:\n         * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.\n         * - Calls f to perform operation on writable.\n         */\n        operateOnWritable(p, f) {\n            if (this.existsSync(p)) {\n                if (!this._writable.existsSync(p)) {\n                    // File is on readable storage. Copy to writable storage before\n                    // changing its mode.\n                    this.copyToWritable(p);\n                }\n                f();\n            }\n            else {\n                throw ApiError.ENOENT(p);\n            }\n        }\n        operateOnWritableAsync(p, cb) {\n            this.exists(p, (exists) => {\n                if (!exists) {\n                    return cb(ApiError.ENOENT(p));\n                }\n                this._writable.exists(p, (existsWritable) => {\n                    if (existsWritable) {\n                        cb();\n                    }\n                    else {\n                        return this.copyToWritableAsync(p, cb);\n                    }\n                });\n            });\n        }\n        /**\n         * Copy from readable to writable storage.\n         * PRECONDITION: File does not exist on writable storage.\n         */\n        copyToWritable(p) {\n            const pStats = this.statSync(p, false);\n            if (pStats.isDirectory()) {\n                this._writable.mkdirSync(p, pStats.mode);\n            }\n            else {\n                this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);\n            }\n        }\n        copyToWritableAsync(p, cb) {\n            this.stat(p, false, (err, pStats) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (pStats.isDirectory()) {\n                    return this._writable.mkdir(p, pStats.mode, cb);\n                }\n                // need to copy file.\n                this._readable.readFile(p, null, getFlag('r'), (err, data) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    this.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);\n                });\n            });\n        }\n    }\n    /**\n     * OverlayFS makes a read-only filesystem writable by storing writes on a second,\n     * writable file system. Deletes are persisted via metadata stored on the writable\n     * file system.\n     */\n    class OverlayFS extends LockedFS {\n        /**\n         * @param writable The file system to write modified files to.\n         * @param readable The file system that initially populates this file system.\n         */\n        constructor(writable, readable) {\n            super(new UnlockedOverlayFS(writable, readable));\n        }\n        /**\n         * Constructs and initializes an OverlayFS instance with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                const fs = new OverlayFS(opts.writable, opts.readable);\n                fs._initialize((e) => {\n                    cb(e, fs);\n                });\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() {\n            return UnlockedOverlayFS.isAvailable();\n        }\n        getOverlayedFileSystems() {\n            return super.getFSUnlocked().getOverlayedFileSystems();\n        }\n        unwrap() {\n            return super.getFSUnlocked();\n        }\n        _initialize(cb) {\n            super.getFSUnlocked()._initialize(cb);\n        }\n    }\n    OverlayFS.Name = \"OverlayFS\";\n    OverlayFS.Options = {\n        writable: {\n            type: \"object\",\n            description: \"The file system to write modified files to.\"\n        },\n        readable: {\n            type: \"object\",\n            description: \"The file system that initially populates this file system.\"\n        }\n    };\n\n    return OverlayFS;\n});\ndefine('skylark-browserfs/backend/WorkerFS',[\n    '../libs/buffers',\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/util',\n    '../core/file',\n    '../core/node_fs_stats',\n    '../generic/preload_file',\n    '../core/global',\n    '../core/node_fs'\n], function (buffers,file_system, api_error, file_flag, util, file, node_fs_stats, preload_file, global, fs) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode }  = api_error;\n    const { FileFlag }  = file_flag;\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer, emptyBuffer }  = util;\n    const { BaseFile }  = file;\n    const { Stats }  = node_fs_stats;\n    const {PreloadFile}  = preload_file;\n    const { Buffer } = buffers;\n\n    /**\n     * @hidden\n     */\n    var SpecialArgType;\n    (function (SpecialArgType) {\n        // Callback\n        SpecialArgType[SpecialArgType[\"CB\"] = 0] = \"CB\";\n        // File descriptor\n        SpecialArgType[SpecialArgType[\"FD\"] = 1] = \"FD\";\n        // API error\n        SpecialArgType[SpecialArgType[\"API_ERROR\"] = 2] = \"API_ERROR\";\n        // Stats object\n        SpecialArgType[SpecialArgType[\"STATS\"] = 3] = \"STATS\";\n        // Initial probe for file system information.\n        SpecialArgType[SpecialArgType[\"PROBE\"] = 4] = \"PROBE\";\n        // FileFlag object.\n        SpecialArgType[SpecialArgType[\"FILEFLAG\"] = 5] = \"FILEFLAG\";\n        // Buffer object.\n        SpecialArgType[SpecialArgType[\"BUFFER\"] = 6] = \"BUFFER\";\n        // Generic Error object.\n        SpecialArgType[SpecialArgType[\"ERROR\"] = 7] = \"ERROR\";\n    })(SpecialArgType || (SpecialArgType = {}));\n    /**\n     * Converts callback arguments into ICallbackArgument objects, and back\n     * again.\n     * @hidden\n     */\n    class CallbackArgumentConverter {\n        constructor() {\n            this._callbacks = {};\n            this._nextId = 0;\n        }\n        toRemoteArg(cb) {\n            const id = this._nextId++;\n            this._callbacks[id] = cb;\n            return {\n                type: SpecialArgType.CB,\n                id: id\n            };\n        }\n        toLocalArg(id) {\n            const cb = this._callbacks[id];\n            delete this._callbacks[id];\n            return cb;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class FileDescriptorArgumentConverter {\n        constructor() {\n            this._fileDescriptors = {};\n            this._nextId = 0;\n        }\n        toRemoteArg(fd, p, flag, cb) {\n            const id = this._nextId++;\n            let data;\n            let stat;\n            this._fileDescriptors[id] = fd;\n            // Extract needed information asynchronously.\n            fd.stat((err, stats) => {\n                if (err) {\n                    cb(err);\n                }\n                else {\n                    stat = bufferToTransferrableObject(stats.toBuffer());\n                    // If it's a readable flag, we need to grab contents.\n                    if (flag.isReadable()) {\n                        fd.read(Buffer.alloc(stats.size), 0, stats.size, 0, (err, bytesRead, buff) => {\n                            if (err) {\n                                cb(err);\n                            }\n                            else {\n                                data = bufferToTransferrableObject(buff);\n                                cb(null, {\n                                    type: SpecialArgType.FD,\n                                    id: id,\n                                    data: data,\n                                    stat: stat,\n                                    path: p,\n                                    flag: flag.getFlagString()\n                                });\n                            }\n                        });\n                    }\n                    else {\n                        // File is not readable, which means writing to it will append or\n                        // truncate/replace existing contents. Return an empty arraybuffer.\n                        cb(null, {\n                            type: SpecialArgType.FD,\n                            id: id,\n                            data: new ArrayBuffer(0),\n                            stat: stat,\n                            path: p,\n                            flag: flag.getFlagString()\n                        });\n                    }\n                }\n            });\n        }\n        applyFdAPIRequest(request, cb) {\n            const fdArg = request.args[0];\n            this._applyFdChanges(fdArg, (err, fd) => {\n                if (err) {\n                    cb(err);\n                }\n                else {\n                    // Apply method on now-changed file descriptor.\n                    fd[request.method]((e) => {\n                        if (request.method === 'close') {\n                            delete this._fileDescriptors[fdArg.id];\n                        }\n                        cb(e);\n                    });\n                }\n            });\n        }\n        _applyFdChanges(remoteFd, cb) {\n            const fd = this._fileDescriptors[remoteFd.id], data = transferrableObjectToBuffer(remoteFd.data), remoteStats = Stats.fromBuffer(transferrableObjectToBuffer(remoteFd.stat));\n            // Write data if the file is writable.\n            const flag = FileFlag.getFileFlag(remoteFd.flag);\n            if (flag.isWriteable()) {\n                // Appendable: Write to end of file.\n                // Writeable: Replace entire contents of file.\n                fd.write(data, 0, data.length, flag.isAppendable() ? fd.getPos() : 0, (e) => {\n                    function applyStatChanges() {\n                        // Check if mode changed.\n                        fd.stat((e, stats) => {\n                            if (e) {\n                                cb(e);\n                            }\n                            else {\n                                if (stats.mode !== remoteStats.mode) {\n                                    fd.chmod(remoteStats.mode, (e) => {\n                                        cb(e, fd);\n                                    });\n                                }\n                                else {\n                                    cb(e, fd);\n                                }\n                            }\n                        });\n                    }\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        // If writeable & not appendable, we need to ensure file contents are\n                        // identical to those from the remote FD. Thus, we truncate to the\n                        // length of the remote file.\n                        if (!flag.isAppendable()) {\n                            fd.truncate(data.length, () => {\n                                applyStatChanges();\n                            });\n                        }\n                        else {\n                            applyStatChanges();\n                        }\n                    }\n                });\n            }\n            else {\n                cb(null, fd);\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    function apiErrorLocal2Remote(e) {\n        return {\n            type: SpecialArgType.API_ERROR,\n            errorData: bufferToTransferrableObject(e.writeToBuffer())\n        };\n    }\n    /**\n     * @hidden\n     */\n    function apiErrorRemote2Local(e) {\n        return ApiError.fromBuffer(transferrableObjectToBuffer(e.errorData));\n    }\n    /**\n     * @hidden\n     */\n    function errorLocal2Remote(e) {\n        return {\n            type: SpecialArgType.ERROR,\n            name: e.name,\n            message: e.message,\n            stack: e.stack\n        };\n    }\n    /**\n     * @hidden\n     */\n    function errorRemote2Local(e) {\n        let cnstr = global[e.name];\n        if (typeof (cnstr) !== 'function') {\n            cnstr = Error;\n        }\n        const err = new cnstr(e.message);\n        err.stack = e.stack;\n        return err;\n    }\n    /**\n     * @hidden\n     */\n    function statsLocal2Remote(stats) {\n        return {\n            type: SpecialArgType.STATS,\n            statsData: bufferToTransferrableObject(stats.toBuffer())\n        };\n    }\n    /**\n     * @hidden\n     */\n    function statsRemote2Local(stats) {\n        return Stats.fromBuffer(transferrableObjectToBuffer(stats.statsData));\n    }\n    /**\n     * @hidden\n     */\n    function fileFlagLocal2Remote(flag) {\n        return {\n            type: SpecialArgType.FILEFLAG,\n            flagStr: flag.getFlagString()\n        };\n    }\n    /**\n     * @hidden\n     */\n    function fileFlagRemote2Local(remoteFlag) {\n        return FileFlag.getFileFlag(remoteFlag.flagStr);\n    }\n    /**\n     * @hidden\n     */\n    function bufferToTransferrableObject(buff) {\n        return buffer2ArrayBuffer(buff);\n    }\n    /**\n     * @hidden\n     */\n    function transferrableObjectToBuffer(buff) {\n        return arrayBuffer2Buffer(buff);\n    }\n    /**\n     * @hidden\n     */\n    function bufferLocal2Remote(buff) {\n        return {\n            type: SpecialArgType.BUFFER,\n            data: bufferToTransferrableObject(buff)\n        };\n    }\n    /**\n     * @hidden\n     */\n    function bufferRemote2Local(buffArg) {\n        return transferrableObjectToBuffer(buffArg.data);\n    }\n    /**\n     * @hidden\n     */\n    function isAPIRequest(data) {\n        return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];\n    }\n    /**\n     * @hidden\n     */\n    function isAPIResponse(data) {\n        return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];\n    }\n    /**\n     * Represents a remote file in a different worker/thread.\n     */\n    class WorkerFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, remoteFdId, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n            this._remoteFdId = remoteFdId;\n        }\n        getRemoteFdId() {\n            return this._remoteFdId;\n        }\n        /**\n         * @hidden\n         */\n        toRemoteArg() {\n            return {\n                type: SpecialArgType.FD,\n                id: this._remoteFdId,\n                data: bufferToTransferrableObject(this.getBuffer()),\n                stat: bufferToTransferrableObject(this.getStats().toBuffer()),\n                path: this.getPath(),\n                flag: this.getFlag().getFlagString()\n            };\n        }\n        sync(cb) {\n            this._syncClose('sync', cb);\n        }\n        close(cb) {\n            this._syncClose('close', cb);\n        }\n        _syncClose(type, cb) {\n            if (this.isDirty()) {\n                this._fs.syncClose(type, this, (e) => {\n                    if (!e) {\n                        this.resetDirty();\n                    }\n                    cb(e);\n                });\n            }\n            else {\n                cb();\n            }\n        }\n    }\n    /**\n     * WorkerFS lets you access a BrowserFS instance that is running in a different\n     * JavaScript context (e.g. access BrowserFS in one of your WebWorkers, or\n     * access BrowserFS running on the main page from a WebWorker).\n     *\n     * For example, to have a WebWorker access files in the main browser thread,\n     * do the following:\n     *\n     * MAIN BROWSER THREAD:\n     *\n     * ```javascript\n     *   // Listen for remote file system requests.\n     *   BrowserFS.FileSystem.WorkerFS.attachRemoteListener(webWorkerObject);\n     * ```\n     *\n     * WEBWORKER THREAD:\n     *\n     * ```javascript\n     *   // Set the remote file system as the root file system.\n     *   BrowserFS.configure({ fs: \"WorkerFS\", options: { worker: self }}, function(e) {\n     *     // Ready!\n     *   });\n     * ```\n     *\n     * Note that synchronous operations are not permitted on the WorkerFS, regardless\n     * of the configuration option of the remote FS.\n     */\n    class WorkerFS extends BaseFileSystem {\n        /**\n         * Constructs a new WorkerFS instance that connects with BrowserFS running on\n         * the specified worker.\n         */\n        constructor(worker) {\n            super();\n            this._callbackConverter = new CallbackArgumentConverter();\n            this._isInitialized = false;\n            this._isReadOnly = false;\n            this._supportLinks = false;\n            this._supportProps = false;\n            this._worker = worker;\n            this._worker.addEventListener('message', (e) => {\n                const resp = e.data;\n                if (isAPIResponse(resp)) {\n                    let i;\n                    const args = resp.args;\n                    const fixedArgs = new Array(args.length);\n                    // Dispatch event to correct id.\n                    for (i = 0; i < fixedArgs.length; i++) {\n                        fixedArgs[i] = this._argRemote2Local(args[i]);\n                    }\n                    this._callbackConverter.toLocalArg(resp.cbId).apply(null, fixedArgs);\n                }\n            });\n        }\n        static Create(opts, cb) {\n            const fs = new WorkerFS(opts.worker);\n            fs._initialize(() => {\n                cb(null, fs);\n            });\n        }\n        static isAvailable() {\n            return typeof (importScripts) !== 'undefined' || typeof (Worker) !== 'undefined';\n        }\n        /**\n         * Attaches a listener to the remote worker for file system requests.\n         */\n        static attachRemoteListener(worker) {\n            const fdConverter = new FileDescriptorArgumentConverter();\n            function argLocal2Remote(arg, requestArgs, cb) {\n                switch (typeof arg) {\n                    case 'object':\n                        if (arg instanceof Stats) {\n                            cb(null, statsLocal2Remote(arg));\n                        }\n                        else if (arg instanceof ApiError) {\n                            cb(null, apiErrorLocal2Remote(arg));\n                        }\n                        else if (arg instanceof BaseFile) {\n                            // Pass in p and flags from original request.\n                            cb(null, fdConverter.toRemoteArg(arg, requestArgs[0], requestArgs[1], cb));\n                        }\n                        else if (arg instanceof FileFlag) {\n                            cb(null, fileFlagLocal2Remote(arg));\n                        }\n                        else if (arg instanceof Buffer) {\n                            cb(null, bufferLocal2Remote(arg));\n                        }\n                        else if (arg instanceof Error) {\n                            cb(null, errorLocal2Remote(arg));\n                        }\n                        else {\n                            cb(null, arg);\n                        }\n                        break;\n                    default:\n                        cb(null, arg);\n                        break;\n                }\n            }\n            function argRemote2Local(arg, fixedRequestArgs) {\n                if (!arg) {\n                    return arg;\n                }\n                switch (typeof arg) {\n                    case 'object':\n                        if (typeof arg['type'] === 'number') {\n                            const specialArg = arg;\n                            switch (specialArg.type) {\n                                case SpecialArgType.CB:\n                                    const cbId = arg.id;\n                                    return function () {\n                                        let i;\n                                        const fixedArgs = new Array(arguments.length);\n                                        let message, countdown = arguments.length;\n                                        function abortAndSendError(err) {\n                                            if (countdown > 0) {\n                                                countdown = -1;\n                                                message = {\n                                                    browserfsMessage: true,\n                                                    cbId: cbId,\n                                                    args: [apiErrorLocal2Remote(err)]\n                                                };\n                                                worker.postMessage(message);\n                                            }\n                                        }\n                                        for (i = 0; i < arguments.length; i++) {\n                                            // Capture i and argument.\n                                            ((i, arg) => {\n                                                argLocal2Remote(arg, fixedRequestArgs, (err, fixedArg) => {\n                                                    fixedArgs[i] = fixedArg;\n                                                    if (err) {\n                                                        abortAndSendError(err);\n                                                    }\n                                                    else if (--countdown === 0) {\n                                                        message = {\n                                                            browserfsMessage: true,\n                                                            cbId: cbId,\n                                                            args: fixedArgs\n                                                        };\n                                                        worker.postMessage(message);\n                                                    }\n                                                });\n                                            })(i, arguments[i]);\n                                        }\n                                        if (arguments.length === 0) {\n                                            message = {\n                                                browserfsMessage: true,\n                                                cbId: cbId,\n                                                args: fixedArgs\n                                            };\n                                            worker.postMessage(message);\n                                        }\n                                    };\n                                case SpecialArgType.API_ERROR:\n                                    return apiErrorRemote2Local(specialArg);\n                                case SpecialArgType.STATS:\n                                    return statsRemote2Local(specialArg);\n                                case SpecialArgType.FILEFLAG:\n                                    return fileFlagRemote2Local(specialArg);\n                                case SpecialArgType.BUFFER:\n                                    return bufferRemote2Local(specialArg);\n                                case SpecialArgType.ERROR:\n                                    return errorRemote2Local(specialArg);\n                                default:\n                                    // No idea what this is.\n                                    return arg;\n                            }\n                        }\n                        else {\n                            return arg;\n                        }\n                    default:\n                        return arg;\n                }\n            }\n            worker.addEventListener('message', (e) => {\n                const request = e.data;\n                if (isAPIRequest(request)) {\n                    const args = request.args, fixedArgs = new Array(args.length);\n                    switch (request.method) {\n                        case 'close':\n                        case 'sync':\n                            (() => {\n                                // File descriptor-relative methods.\n                                const remoteCb = args[1];\n                                fdConverter.applyFdAPIRequest(request, (err) => {\n                                    // Send response.\n                                    const response = {\n                                        browserfsMessage: true,\n                                        cbId: remoteCb.id,\n                                        args: err ? [apiErrorLocal2Remote(err)] : []\n                                    };\n                                    worker.postMessage(response);\n                                });\n                            })();\n                            break;\n                        case 'probe':\n                            (() => {\n                                const rootFs = fs.getRootFS(), remoteCb = args[1], probeResponse = {\n                                    type: SpecialArgType.PROBE,\n                                    isReadOnly: rootFs.isReadOnly(),\n                                    supportsLinks: rootFs.supportsLinks(),\n                                    supportsProps: rootFs.supportsProps()\n                                }, response = {\n                                    browserfsMessage: true,\n                                    cbId: remoteCb.id,\n                                    args: [probeResponse]\n                                };\n                                worker.postMessage(response);\n                            })();\n                            break;\n                        default:\n                            // File system methods.\n                            for (let i = 0; i < args.length; i++) {\n                                fixedArgs[i] = argRemote2Local(args[i], fixedArgs);\n                            }\n                            const rootFS = fs.getRootFS();\n                            rootFS[request.method].apply(rootFS, fixedArgs);\n                            break;\n                    }\n                }\n            });\n        }\n        getName() {\n            return WorkerFS.Name;\n        }\n        isReadOnly() { return this._isReadOnly; }\n        supportsSynch() { return false; }\n        supportsLinks() { return this._supportLinks; }\n        supportsProps() { return this._supportProps; }\n        rename(oldPath, newPath, cb) {\n            this._rpc('rename', arguments);\n        }\n        stat(p, isLstat, cb) {\n            this._rpc('stat', arguments);\n        }\n        open(p, flag, mode, cb) {\n            this._rpc('open', arguments);\n        }\n        unlink(p, cb) {\n            this._rpc('unlink', arguments);\n        }\n        rmdir(p, cb) {\n            this._rpc('rmdir', arguments);\n        }\n        mkdir(p, mode, cb) {\n            this._rpc('mkdir', arguments);\n        }\n        readdir(p, cb) {\n            this._rpc('readdir', arguments);\n        }\n        exists(p, cb) {\n            this._rpc('exists', arguments);\n        }\n        realpath(p, cache, cb) {\n            this._rpc('realpath', arguments);\n        }\n        truncate(p, len, cb) {\n            this._rpc('truncate', arguments);\n        }\n        readFile(fname, encoding, flag, cb) {\n            this._rpc('readFile', arguments);\n        }\n        writeFile(fname, data, encoding, flag, mode, cb) {\n            this._rpc('writeFile', arguments);\n        }\n        appendFile(fname, data, encoding, flag, mode, cb) {\n            this._rpc('appendFile', arguments);\n        }\n        chmod(p, isLchmod, mode, cb) {\n            this._rpc('chmod', arguments);\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            this._rpc('chown', arguments);\n        }\n        utimes(p, atime, mtime, cb) {\n            this._rpc('utimes', arguments);\n        }\n        link(srcpath, dstpath, cb) {\n            this._rpc('link', arguments);\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            this._rpc('symlink', arguments);\n        }\n        readlink(p, cb) {\n            this._rpc('readlink', arguments);\n        }\n        syncClose(method, fd, cb) {\n            this._worker.postMessage({\n                browserfsMessage: true,\n                method: method,\n                args: [fd.toRemoteArg(), this._callbackConverter.toRemoteArg(cb)]\n            });\n        }\n        /**\n         * Called once both local and remote sides are set up.\n         */\n        _initialize(cb) {\n            if (!this._isInitialized) {\n                const message = {\n                    browserfsMessage: true,\n                    method: 'probe',\n                    args: [this._argLocal2Remote(emptyBuffer()), this._callbackConverter.toRemoteArg((probeResponse) => {\n                            this._isInitialized = true;\n                            this._isReadOnly = probeResponse.isReadOnly;\n                            this._supportLinks = probeResponse.supportsLinks;\n                            this._supportProps = probeResponse.supportsProps;\n                            cb();\n                        })]\n                };\n                this._worker.postMessage(message);\n            }\n            else {\n                cb();\n            }\n        }\n        _argRemote2Local(arg) {\n            if (!arg) {\n                return arg;\n            }\n            switch (typeof arg) {\n                case 'object':\n                    if (typeof arg['type'] === 'number') {\n                        const specialArg = arg;\n                        switch (specialArg.type) {\n                            case SpecialArgType.API_ERROR:\n                                return apiErrorRemote2Local(specialArg);\n                            case SpecialArgType.FD:\n                                const fdArg = specialArg;\n                                return new WorkerFile(this, fdArg.path, FileFlag.getFileFlag(fdArg.flag), Stats.fromBuffer(transferrableObjectToBuffer(fdArg.stat)), fdArg.id, transferrableObjectToBuffer(fdArg.data));\n                            case SpecialArgType.STATS:\n                                return statsRemote2Local(specialArg);\n                            case SpecialArgType.FILEFLAG:\n                                return fileFlagRemote2Local(specialArg);\n                            case SpecialArgType.BUFFER:\n                                return bufferRemote2Local(specialArg);\n                            case SpecialArgType.ERROR:\n                                return errorRemote2Local(specialArg);\n                            default:\n                                return arg;\n                        }\n                    }\n                    else {\n                        return arg;\n                    }\n                default:\n                    return arg;\n            }\n        }\n        _rpc(methodName, args) {\n            const fixedArgs = new Array(args.length);\n            for (let i = 0; i < args.length; i++) {\n                fixedArgs[i] = this._argLocal2Remote(args[i]);\n            }\n            const message = {\n                browserfsMessage: true,\n                method: methodName,\n                args: fixedArgs\n            };\n            this._worker.postMessage(message);\n        }\n        /**\n         * Converts a local argument into a remote argument. Public so WorkerFile objects can call it.\n         */\n        _argLocal2Remote(arg) {\n            if (!arg) {\n                return arg;\n            }\n            switch (typeof arg) {\n                case \"object\":\n                    if (arg instanceof Stats) {\n                        return statsLocal2Remote(arg);\n                    }\n                    else if (arg instanceof ApiError) {\n                        return apiErrorLocal2Remote(arg);\n                    }\n                    else if (arg instanceof WorkerFile) {\n                        return arg.toRemoteArg();\n                    }\n                    else if (arg instanceof FileFlag) {\n                        return fileFlagLocal2Remote(arg);\n                    }\n                    else if (arg instanceof Buffer) {\n                        return bufferLocal2Remote(arg);\n                    }\n                    else if (arg instanceof Error) {\n                        return errorLocal2Remote(arg);\n                    }\n                    else {\n                        return \"Unknown argument\";\n                    }\n                case \"function\":\n                    return this._callbackConverter.toRemoteArg(arg);\n                default:\n                    return arg;\n            }\n        }\n    }\n    WorkerFS.Name = \"WorkerFS\";\n    WorkerFS.Options = {\n        worker: {\n            type: \"object\",\n            description: \"The target worker that you want to connect to, or the current worker if in a worker context.\",\n            validator: function (v, cb) {\n                // Check for a `postMessage` function.\n                if (v['postMessage']) {\n                    cb();\n                }\n                else {\n                    cb(new ApiError(ErrorCode.EINVAL, `option must be a Web Worker instance.`));\n                }\n            }\n        }\n    };\n\n    return WorkerFS;\n});\ndefine('skylark-browserfs/generic/xhr',[\n    '../libs/buffers',\n    '../core/util',\n    '../core/api_error'\n], function (buffers,util, api_error) {\n    'use strict';\n    /**\n     * Contains utility methods for performing a variety of tasks with\n     * XmlHttpRequest across browsers.\n     */\n    const { isIE, emptyBuffer } = util;\n    const { ApiError, ErrorCode } = api_error;\n    const { Buffer } = buffers;\n\n    const xhrIsAvailable = (typeof (XMLHttpRequest) !== \"undefined\" && XMLHttpRequest !== null);\n    function asyncDownloadFileModern(p, type, cb) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, true);\n        let jsonSupported = true;\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // Some browsers don't support the JSON response type.\n                // They either reset responseType, or throw an exception.\n                // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js\n                try {\n                    req.responseType = 'json';\n                    jsonSupported = req.responseType === 'json';\n                }\n                catch (e) {\n                    jsonSupported = false;\n                }\n                break;\n            default:\n                return cb(new ApiError(ErrorCode.EINVAL, \"Invalid download type: \" + type));\n        }\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // XXX: WebKit-based browsers return *null* when XHRing an empty file.\n                            return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());\n                        case 'json':\n                            if (jsonSupported) {\n                                return cb(null, req.response);\n                            }\n                            else {\n                                return cb(null, JSON.parse(req.responseText));\n                            }\n                    }\n                }\n                else {\n                    return cb(new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    function syncDownloadFileModern(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        // On most platforms, we cannot set the responseType of synchronous downloads.\n        // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.\n        let data = null;\n        let err = null;\n        // Classic hack to download binary data as a string.\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // Convert the text into a buffer.\n                            const text = req.responseText;\n                            data = Buffer.alloc(text.length);\n                            // Throw away the upper bits of each character.\n                            for (let i = 0; i < text.length; i++) {\n                                // This will automatically throw away the upper bit of each\n                                // character for us.\n                                data[i] = text.charCodeAt(i);\n                            }\n                            return;\n                        case 'json':\n                            data = JSON.parse(req.responseText);\n                            return;\n                    }\n                }\n                else {\n                    err = new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`);\n                    return;\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    function syncDownloadFileIE10(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // IE10 does not support the JSON type.\n                break;\n            default:\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid download type: \" + type);\n        }\n        let data;\n        let err;\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            data = Buffer.from(req.response);\n                            break;\n                        case 'json':\n                            data = JSON.parse(req.response);\n                            break;\n                    }\n                }\n                else {\n                    err = new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`);\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    /**\n     * @hidden\n     */\n    function getFileSize(async, p, cb) {\n        const req = new XMLHttpRequest();\n        req.open('HEAD', p, async);\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    try {\n                        return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));\n                    }\n                    catch (e) {\n                        // In the event that the header isn't present or there is an error...\n                        return cb(new ApiError(ErrorCode.EIO, \"XHR HEAD error: Could not read content-length.\"));\n                    }\n                }\n                else {\n                    return cb(new ApiError(ErrorCode.EIO, `XHR HEAD error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    /**\n     * Asynchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let asyncDownloadFile = asyncDownloadFileModern;\n    /**\n     * Synchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;\n    /**\n     * Synchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeSync(p) {\n        let rv = -1;\n        getFileSize(false, p, function (err, size) {\n            if (err) {\n                throw err;\n            }\n            rv = size;\n        });\n        return rv;\n    }\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeAsync(p, cb) {\n        getFileSize(true, p, cb);\n    }\n\n\n\n    return {\n        xhrIsAvailable: xhrIsAvailable,\n        asyncDownloadFile: asyncDownloadFile,\n        syncDownloadFile: syncDownloadFile,\n        getFileSizeSync: getFileSizeSync,\n        getFileSizeAsync: getFileSizeAsync\n    };\n});\ndefine('skylark-browserfs/generic/fetch',[\n    '../libs/buffers',\n    '../core/api_error'\n], function (buffers,api_error) {\n    'use strict';\n\n    /**\n     * Contains utility methods using 'fetch'.\n     */\n    const { ApiError, ErrorCode }= api_error;\n\n    const fetchIsAvailable = (typeof (fetch) !== \"undefined\" && fetch !== null);\n    const { Buffer } = buffers;\n\n    function fetchFileAsync(p, type, cb) {\n        let request;\n        try {\n            request = fetch(p);\n        }\n        catch (e) {\n            // XXX: fetch will throw a TypeError if the URL has credentials in it\n            return cb(new ApiError(ErrorCode.EINVAL, e.message));\n        }\n        request\n            .then((res) => {\n            if (!res.ok) {\n                return cb(new ApiError(ErrorCode.EIO, `fetch error: response returned code ${res.status}`));\n            }\n            else {\n                switch (type) {\n                    case 'buffer':\n                        res.arrayBuffer()\n                            .then((buf) => cb(null, Buffer.from(buf)))\n                            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));\n                        break;\n                    case 'json':\n                        res.json()\n                            .then((json) => cb(null, json))\n                            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));\n                        break;\n                    default:\n                        cb(new ApiError(ErrorCode.EINVAL, \"Invalid download type: \" + type));\n                }\n            }\n        })\n            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));\n    }\n\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n\n    function fetchFileSizeAsync(p, cb) {\n        fetch(p, { method: 'HEAD' })\n            .then((res) => {\n            if (!res.ok) {\n                return cb(new ApiError(ErrorCode.EIO, `fetch HEAD error: response returned code ${res.status}`));\n            }\n            else {\n                return cb(null, parseInt(res.headers.get('Content-Length') || '-1', 10));\n            }\n        })\n            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));\n    }\n\n    return {\n        fetchIsAvailable: fetchIsAvailable,\n        fetchFileAsync: fetchFileAsync,\n        fetchFileSizeAsync: fetchFileSizeAsync\n    };\n});\ndefine('skylark-browserfs/generic/file_index',[\n    '../core/node_fs_stats',\n    '../libs/path'\n], function (node_fs_stats, path) {\n    'use strict';\n\n    const {Stats, FileType }  = node_fs_stats;\n\n    /**\n     * A simple class for storing a filesystem index. Assumes that all paths passed\n     * to it are *absolute* paths.\n     *\n     * Can be used as a partial or a full index, although care must be taken if used\n     * for the former purpose, especially when directories are concerned.\n     */\n    class FileIndex {\n        /**\n         * Constructs a new FileIndex.\n         */\n        constructor() {\n            // _index is a single-level key,value store that maps *directory* paths to\n            // DirInodes. File information is only contained in DirInodes themselves.\n            this._index = {};\n            // Create the root directory.\n            this.addPath('/', new DirInode());\n        }\n        /**\n         * Static method for constructing indices from a JSON listing.\n         * @param listing Directory listing generated by tools/XHRIndexer.coffee\n         * @return A new FileIndex object.\n         */\n        static fromListing(listing) {\n            const idx = new FileIndex();\n            // Add a root DirNode.\n            const rootInode = new DirInode();\n            idx._index['/'] = rootInode;\n            const queue = [['', listing, rootInode]];\n            while (queue.length > 0) {\n                let inode;\n                const next = queue.pop();\n                const pwd = next[0];\n                const tree = next[1];\n                const parent = next[2];\n                for (const node in tree) {\n                    if (tree.hasOwnProperty(node)) {\n                        const children = tree[node];\n                        const name = `${pwd}/${node}`;\n                        if (children) {\n                            idx._index[name] = inode = new DirInode();\n                            queue.push([name, children, inode]);\n                        }\n                        else {\n                            // This inode doesn't have correct size information, noted with -1.\n                            inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));\n                        }\n                        if (parent) {\n                            parent._ls[node] = inode;\n                        }\n                    }\n                }\n            }\n            return idx;\n        }\n        /**\n         * Runs the given function over all files in the index.\n         */\n        fileIterator(cb) {\n            for (const path in this._index) {\n                if (this._index.hasOwnProperty(path)) {\n                    const dir = this._index[path];\n                    const files = dir.getListing();\n                    for (const file of files) {\n                        const item = dir.getItem(file);\n                        if (isFileInode(item)) {\n                            cb(item.getData());\n                        }\n                    }\n                }\n            }\n        }\n        /**\n         * Adds the given absolute path to the index if it is not already in the index.\n         * Creates any needed parent directories.\n         * @param path The path to add to the index.\n         * @param inode The inode for the\n         *   path to add.\n         * @return 'True' if it was added or already exists, 'false' if there\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\n         *   different).\n         * @todo If adding fails and implicitly creates directories, we do not clean up\n         *   the new empty directories.\n         */\n        addPath(path, inode) {\n            if (!inode) {\n                throw new Error('Inode must be specified');\n            }\n            if (path[0] !== '/') {\n                throw new Error('Path must be absolute, got: ' + path);\n            }\n            // Check if it already exists.\n            if (this._index.hasOwnProperty(path)) {\n                return this._index[path] === inode;\n            }\n            const splitPath = this._split_path(path);\n            const dirpath = splitPath[0];\n            const itemname = splitPath[1];\n            // Try to add to its parent directory first.\n            let parent = this._index[dirpath];\n            if (parent === undefined && path !== '/') {\n                // Create parent.\n                parent = new DirInode();\n                if (!this.addPath(dirpath, parent)) {\n                    return false;\n                }\n            }\n            // Add myself to my parent.\n            if (path !== '/') {\n                if (!parent.addItem(itemname, inode)) {\n                    return false;\n                }\n            }\n            // If I'm a directory, add myself to the index.\n            if (isDirInode(inode)) {\n                this._index[path] = inode;\n            }\n            return true;\n        }\n        /**\n         * Adds the given absolute path to the index if it is not already in the index.\n         * The path is added without special treatment (no joining of adjacent separators, etc).\n         * Creates any needed parent directories.\n         * @param path The path to add to the index.\n         * @param inode The inode for the\n         *   path to add.\n         * @return 'True' if it was added or already exists, 'false' if there\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\n         *   different).\n         * @todo If adding fails and implicitly creates directories, we do not clean up\n         *   the new empty directories.\n         */\n        addPathFast(path, inode) {\n            const itemNameMark = path.lastIndexOf('/');\n            const parentPath = itemNameMark === 0 ? \"/\" : path.substring(0, itemNameMark);\n            const itemName = path.substring(itemNameMark + 1);\n            // Try to add to its parent directory first.\n            let parent = this._index[parentPath];\n            if (parent === undefined) {\n                // Create parent.\n                parent = new DirInode();\n                this.addPathFast(parentPath, parent);\n            }\n            if (!parent.addItem(itemName, inode)) {\n                return false;\n            }\n            // If adding a directory, add to the index as well.\n            if (inode.isDir()) {\n                this._index[path] = inode;\n            }\n            return true;\n        }\n        /**\n         * Removes the given path. Can be a file or a directory.\n         * @return The removed item,\n         *   or null if it did not exist.\n         */\n        removePath(path) {\n            const splitPath = this._split_path(path);\n            const dirpath = splitPath[0];\n            const itemname = splitPath[1];\n            // Try to remove it from its parent directory first.\n            const parent = this._index[dirpath];\n            if (parent === undefined) {\n                return null;\n            }\n            // Remove myself from my parent.\n            const inode = parent.remItem(itemname);\n            if (inode === null) {\n                return null;\n            }\n            // If I'm a directory, remove myself from the index, and remove my children.\n            if (isDirInode(inode)) {\n                const children = inode.getListing();\n                for (const child of children) {\n                    this.removePath(path + '/' + child);\n                }\n                // Remove the directory from the index, unless it's the root.\n                if (path !== '/') {\n                    delete this._index[path];\n                }\n            }\n            return inode;\n        }\n        /**\n         * Retrieves the directory listing of the given path.\n         * @return An array of files in the given path, or 'null' if it does not exist.\n         */\n        ls(path) {\n            const item = this._index[path];\n            if (item === undefined) {\n                return null;\n            }\n            return item.getListing();\n        }\n        /**\n         * Returns the inode of the given item.\n         * @return Returns null if the item does not exist.\n         */\n        getInode(path) {\n            const splitPath = this._split_path(path);\n            const dirpath = splitPath[0];\n            const itemname = splitPath[1];\n            // Retrieve from its parent directory.\n            const parent = this._index[dirpath];\n            if (parent === undefined) {\n                return null;\n            }\n            // Root case\n            if (dirpath === path) {\n                return parent;\n            }\n            return parent.getItem(itemname);\n        }\n        /**\n         * Split into a (directory path, item name) pair\n         */\n        _split_path(p) {\n            const dirpath = path.dirname(p);\n            const itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\n            return [dirpath, itemname];\n        }\n    }\n    \n    /**\n     * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.\n     */\n    class FileInode {\n        constructor(data) {\n            this.data = data;\n        }\n        isFile() { return true; }\n        isDir() { return false; }\n        getData() { return this.data; }\n        setData(data) { this.data = data; }\n    }\n    /**\n     * Inode for a directory. Currently only contains the directory listing.\n     */\n    class DirInode {\n        /**\n         * Constructs an inode for a directory.\n         */\n        constructor(data = null) {\n            this.data = data;\n            this._ls = {};\n        }\n        isFile() {\n            return false;\n        }\n        isDir() {\n            return true;\n        }\n        getData() { return this.data; }\n        /**\n         * Return a Stats object for this inode.\n         * @todo Should probably remove this at some point. This isn't the\n         *       responsibility of the FileIndex.\n         */\n        getStats() {\n            return new Stats(FileType.DIRECTORY, 4096, 0x16D);\n        }\n        /**\n         * Returns the directory listing for this directory. Paths in the directory are\n         * relative to the directory's path.\n         * @return The directory listing for this directory.\n         */\n        getListing() {\n            return Object.keys(this._ls);\n        }\n        /**\n         * Returns the inode for the indicated item, or null if it does not exist.\n         * @param p Name of item in this directory.\n         */\n        getItem(p) {\n            const item = this._ls[p];\n            return item ? item : null;\n        }\n        /**\n         * Add the given item to the directory listing. Note that the given inode is\n         * not copied, and will be mutated by the DirInode if it is a DirInode.\n         * @param p Item name to add to the directory listing.\n         * @param inode The inode for the\n         *   item to add to the directory inode.\n         * @return True if it was added, false if it already existed.\n         */\n        addItem(p, inode) {\n            if (p in this._ls) {\n                return false;\n            }\n            this._ls[p] = inode;\n            return true;\n        }\n        /**\n         * Removes the given item from the directory listing.\n         * @param p Name of item to remove from the directory listing.\n         * @return Returns the item\n         *   removed, or null if the item did not exist.\n         */\n        remItem(p) {\n            const item = this._ls[p];\n            if (item === undefined) {\n                return null;\n            }\n            delete this._ls[p];\n            return item;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function isFileInode(inode) {\n        return !!inode && inode.isFile();\n    }\n    /**\n     * @hidden\n     */\n    function isDirInode(inode) {\n        return !!inode && inode.isDir();\n    }\n\n\n    return {\n        FileIndex: FileIndex,\n        FileInode: FileInode,\n        DirInode: DirInode,\n        isFileInode: isFileInode,\n        isDirInode: isDirInode\n    };\n});\ndefine('skylark-browserfs/backend/HTTPRequest',[\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/util',\n    '../core/node_fs_stats',\n    '../generic/preload_file',\n    '../generic/xhr',\n    '../generic/fetch',\n    '../generic/file_index'\n], function (file_system, api_error, file_flag, util, node_fs_stats, preload_file, xhr, fetch, file_index) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode }  = api_error;\n    const { ActionType }  = file_flag;\n    const { copyingSlice }  = util;\n    const  {Stats} = node_fs_stats;\n    const { NoSyncFile }  = preload_file;\n    const { xhrIsAvailable, asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync }  = xhr;\n    const { fetchIsAvailable, fetchFileAsync, fetchFileSizeAsync }  = fetch;\n    const { FileIndex, isFileInode, isDirInode }  = file_index;\n    /**\n     * Try to convert the given buffer into a string, and pass it to the callback.\n     * Optimization that removes the needed try/catch into a helper function, as\n     * this is an uncommon case.\n     * @hidden\n     */\n    function tryToString(buff, encoding, cb) {\n        try {\n            cb(null, buff.toString(encoding));\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    function syncNotAvailableError() {\n        throw new ApiError(ErrorCode.ENOTSUP, `Synchronous HTTP download methods are not available in this environment.`);\n    }\n    /**\n     * A simple filesystem backed by HTTP downloads. You must create a directory listing using the\n     * `make_http_index` tool provided by BrowserFS.\n     *\n     * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by\n     * running `make_http_index` in your terminal in the directory you would like to index:\n     *\n     * ```\n     * make_http_index > index.json\n     * ```\n     *\n     * Listings objects look like the following:\n     *\n     * ```json\n     * {\n     *   \"home\": {\n     *     \"jvilk\": {\n     *       \"someFile.txt\": null,\n     *       \"someDir\": {\n     *         // Empty directory\n     *       }\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*\n     */\n    class HTTPRequest extends BaseFileSystem {\n        constructor(index, prefixUrl = '', preferXHR = false) {\n            super();\n            // prefix_url must end in a directory separator.\n            if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {\n                prefixUrl = prefixUrl + '/';\n            }\n            this.prefixUrl = prefixUrl;\n            this._index = FileIndex.fromListing(index);\n            if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {\n                this._requestFileAsyncInternal = fetchFileAsync;\n                this._requestFileSizeAsyncInternal = fetchFileSizeAsync;\n            }\n            else {\n                this._requestFileAsyncInternal = asyncDownloadFile;\n                this._requestFileSizeAsyncInternal = getFileSizeAsync;\n            }\n            if (xhrIsAvailable) {\n                this._requestFileSyncInternal = syncDownloadFile;\n                this._requestFileSizeSyncInternal = getFileSizeSync;\n            }\n            else {\n                this._requestFileSyncInternal = syncNotAvailableError;\n                this._requestFileSizeSyncInternal = syncNotAvailableError;\n            }\n        }\n        /**\n         * Construct an HTTPRequest file system backend with the given options.\n         */\n        static Create(opts, cb) {\n            if (opts.index === undefined) {\n                opts.index = `index.json`;\n            }\n            if (typeof (opts.index) === \"string\") {\n                asyncDownloadFile(opts.index, \"json\", (e, data) => {\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        cb(null, new HTTPRequest(data, opts.baseUrl));\n                    }\n                });\n            }\n            else {\n                cb(null, new HTTPRequest(opts.index, opts.baseUrl));\n            }\n        }\n        static isAvailable() {\n            return xhrIsAvailable || fetchIsAvailable;\n        }\n        empty() {\n            this._index.fileIterator(function (file) {\n                file.fileData = null;\n            });\n        }\n        getName() {\n            return HTTPRequest.Name;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system. We could calculate the total space, but that's not\n            // important right now.\n            cb(0, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            // Synchronous operations are only available via the XHR interface for now.\n            return xhrIsAvailable;\n        }\n        /**\n         * Special HTTPFS function: Preload the given file into the index.\n         * @param [String] path\n         * @param [BrowserFS.Buffer] buffer\n         */\n        preloadFile(path, buffer) {\n            const inode = this._index.getInode(path);\n            if (isFileInode(inode)) {\n                if (inode === null) {\n                    throw ApiError.ENOENT(path);\n                }\n                const stats = inode.getData();\n                stats.size = buffer.length;\n                stats.fileData = buffer;\n            }\n            else {\n                throw ApiError.EISDIR(path);\n            }\n        }\n        stat(path, isLstat, cb) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(ApiError.ENOENT(path));\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    this._requestFileSizeAsync(path, function (e, size) {\n                        if (e) {\n                            return cb(e);\n                        }\n                        stats.size = size;\n                        cb(null, Stats.clone(stats));\n                    });\n                }\n                else {\n                    cb(null, Stats.clone(stats));\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n                cb(null, stats);\n            }\n            else {\n                cb(ApiError.FileError(ErrorCode.EINVAL, path));\n            }\n        }\n        statSync(path, isLstat) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    stats.size = this._requestFileSizeSync(path);\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n            }\n            else {\n                throw ApiError.FileError(ErrorCode.EINVAL, path);\n            }\n            return stats;\n        }\n        open(path, flags, mode, cb) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                return cb(new ApiError(ErrorCode.EPERM, path));\n            }\n            const self = this;\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(ApiError.ENOENT(path));\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        return cb(ApiError.EEXIST(path));\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), stats.fileData));\n                        }\n                        // @todo be lazier about actually requesting the file\n                        this._requestFileAsync(path, 'buffer', function (err, buffer) {\n                            if (err) {\n                                return cb(err);\n                            }\n                            // we don't initially have file sizes\n                            stats.size = buffer.length;\n                            stats.fileData = buffer;\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), buffer));\n                        });\n                        break;\n                    default:\n                        return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.'));\n                }\n            }\n            else {\n                return cb(ApiError.EISDIR(path));\n            }\n        }\n        openSync(path, flags, mode) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, path);\n            }\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw ApiError.EEXIST(path);\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return new NoSyncFile(this, path, flags, Stats.clone(stats), stats.fileData);\n                        }\n                        // @todo be lazier about actually requesting the file\n                        const buffer = this._requestFileSync(path, 'buffer');\n                        // we don't initially have file sizes\n                        stats.size = buffer.length;\n                        stats.fileData = buffer;\n                        return new NoSyncFile(this, path, flags, Stats.clone(stats), buffer);\n                    default:\n                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw ApiError.EISDIR(path);\n            }\n        }\n        readdir(path, cb) {\n            try {\n                cb(null, this.readdirSync(path));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            else if (isDirInode(inode)) {\n                return inode.getListing();\n            }\n            else {\n                throw ApiError.ENOTDIR(path);\n            }\n        }\n        /**\n         * We have the entire file as a buffer; optimize readFile.\n         */\n        readFile(fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (!err) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    cb(err, copyingSlice(fdBuff));\n                }\n                else {\n                    tryToString(fdBuff, encoding, cb);\n                }\n            });\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        _getHTTPPath(filePath) {\n            if (filePath.charAt(0) === '/') {\n                filePath = filePath.slice(1);\n            }\n            return this.prefixUrl + filePath;\n        }\n        _requestFileAsync(p, type, cb) {\n            this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);\n        }\n        _requestFileSync(p, type) {\n            return this._requestFileSyncInternal(this._getHTTPPath(p), type);\n        }\n        /**\n         * Only requests the HEAD content, for the file size.\n         */\n        _requestFileSizeAsync(path, cb) {\n            this._requestFileSizeAsyncInternal(this._getHTTPPath(path), cb);\n        }\n        _requestFileSizeSync(path) {\n            return this._requestFileSizeSyncInternal(this._getHTTPPath(path));\n        }\n    }\n    HTTPRequest.Name = \"HTTPRequest\";\n    HTTPRequest.Options = {\n        index: {\n            type: [\"string\", \"object\"],\n            optional: true,\n            description: \"URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`.\"\n        },\n        baseUrl: {\n            type: \"string\",\n            optional: true,\n            description: \"Used as the URL prefix for fetched files. Default: Fetch files relative to the index.\"\n        },\n        preferXHR: {\n            type: \"boolean\",\n            optional: true,\n            description: \"Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false\"\n        }\n    };\n\n    return HTTPRequest;\n});\ndefine('skylark-browserfs/generic/extended_ascii',[],function () {\n    'use strict';\n    /**\n     * (Nonstandard) String utility function for 8-bit ASCII with the extended\n     * character set. Unlike the ASCII above, we do not mask the high bits.\n     *\n     * Placed into a separate file so it can be used with other Buffer implementations.\n     * @see http://en.wikipedia.org/wiki/Extended_ASCII\n     */\n    class ExtendedASCII {\n        static str2byte(str, buf) {\n            const length = str.length > buf.length ? buf.length : str.length;\n            for (let i = 0; i < length; i++) {\n                let charCode = str.charCodeAt(i);\n                if (charCode > 0x7F) {\n                    // Check if extended ASCII.\n                    const charIdx = ExtendedASCII.extendedChars.indexOf(str.charAt(i));\n                    if (charIdx > -1) {\n                        charCode = charIdx + 0x80;\n                    }\n                    // Otherwise, keep it as-is.\n                }\n                buf[charCode] = i;\n            }\n            return length;\n        }\n        static byte2str(buff) {\n            const chars = new Array(buff.length);\n            for (let i = 0; i < buff.length; i++) {\n                const charCode = buff[i];\n                if (charCode > 0x7F) {\n                    chars[i] = ExtendedASCII.extendedChars[charCode - 128];\n                }\n                else {\n                    chars[i] = String.fromCharCode(charCode);\n                }\n            }\n            return chars.join('');\n        }\n        static byteLength(str) { return str.length; }\n    }\n    \n    ExtendedASCII.extendedChars = ['\\u00C7', '\\u00FC', '\\u00E9', '\\u00E2', '\\u00E4',\n        '\\u00E0', '\\u00E5', '\\u00E7', '\\u00EA', '\\u00EB', '\\u00E8', '\\u00EF',\n        '\\u00EE', '\\u00EC', '\\u00C4', '\\u00C5', '\\u00C9', '\\u00E6', '\\u00C6',\n        '\\u00F4', '\\u00F6', '\\u00F2', '\\u00FB', '\\u00F9', '\\u00FF', '\\u00D6',\n        '\\u00DC', '\\u00F8', '\\u00A3', '\\u00D8', '\\u00D7', '\\u0192', '\\u00E1',\n        '\\u00ED', '\\u00F3', '\\u00FA', '\\u00F1', '\\u00D1', '\\u00AA', '\\u00BA',\n        '\\u00BF', '\\u00AE', '\\u00AC', '\\u00BD', '\\u00BC', '\\u00A1', '\\u00AB',\n        '\\u00BB', '_', '_', '_', '\\u00A6', '\\u00A6', '\\u00C1', '\\u00C2', '\\u00C0',\n        '\\u00A9', '\\u00A6', '\\u00A6', '+', '+', '\\u00A2', '\\u00A5', '+', '+', '-',\n        '-', '+', '-', '+', '\\u00E3', '\\u00C3', '+', '+', '-', '-', '\\u00A6', '-',\n        '+', '\\u00A4', '\\u00F0', '\\u00D0', '\\u00CA', '\\u00CB', '\\u00C8', 'i',\n        '\\u00CD', '\\u00CE', '\\u00CF', '+', '+', '_', '_', '\\u00A6', '\\u00CC', '_',\n        '\\u00D3', '\\u00DF', '\\u00D4', '\\u00D2', '\\u00F5', '\\u00D5', '\\u00B5',\n        '\\u00FE', '\\u00DE', '\\u00DA', '\\u00DB', '\\u00D9', '\\u00FD', '\\u00DD',\n        '\\u00AF', '\\u00B4', '\\u00AD', '\\u00B1', '_', '\\u00BE', '\\u00B6', '\\u00A7',\n        '\\u00F7', '\\u00B8', '\\u00B0', '\\u00A8', '\\u00B7', '\\u00B9', '\\u00B3',\n        '\\u00B2', '_', ' '];\n\n    return ExtendedASCII;\n});\ndefine('skylark-browserfs/backend/ZipFS',[\n    '../core/api_error',\n    '../core/node_fs_stats',\n    '../core/file_system',\n    '../core/file_flag',\n    '../generic/preload_file',\n    '../core/util',\n    '../generic/extended_ascii',\n    '../generic/setImmediate',\n    '../generic/file_index'\n], function (api_error,  node_fs_stats, file_system, file_flag, preload_file, util, ExtendedASCII, setImmediate, file_index) {\n    'use strict';\n\n    const { ApiError, ErrorCode }  = api_error;\n    const { Stats, FileType }  = node_fs_stats;\n    const { SynchronousFileSystem }  = file_system;\n    const { ActionType }  = file_flag;\n    const { NoSyncFile }  = preload_file;\n    const { arrayish2Buffer, copyingSlice, bufferValidator }  = util;\n    /**\n     * @hidden\n     */\n    let inflateRaw;\n    try {\n        inflateRaw = require('pako/lib/inflate').inflateRaw;\n    } catch (e) {\n        console.warn(e);\n    }\n    const { FileIndex, DirInode, FileInode, isDirInode, isFileInode } = '../generic/file_index';\n    /**\n     * Maps CompressionMethod => function that decompresses.\n     * @hidden\n     */\n    const decompressionMethods = {};\n    /**\n     * 4.4.2.2: Indicates the compatibiltiy of a file's external attributes.\n     */\n    var ExternalFileAttributeType;\n    (function (ExternalFileAttributeType) {\n        ExternalFileAttributeType[ExternalFileAttributeType[\"MSDOS\"] = 0] = \"MSDOS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"AMIGA\"] = 1] = \"AMIGA\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"OPENVMS\"] = 2] = \"OPENVMS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"UNIX\"] = 3] = \"UNIX\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"VM_CMS\"] = 4] = \"VM_CMS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"ATARI_ST\"] = 5] = \"ATARI_ST\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"OS2_HPFS\"] = 6] = \"OS2_HPFS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"MAC\"] = 7] = \"MAC\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"Z_SYSTEM\"] = 8] = \"Z_SYSTEM\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"CP_M\"] = 9] = \"CP_M\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"NTFS\"] = 10] = \"NTFS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"MVS\"] = 11] = \"MVS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"VSE\"] = 12] = \"VSE\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"ACORN_RISC\"] = 13] = \"ACORN_RISC\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"VFAT\"] = 14] = \"VFAT\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"ALT_MVS\"] = 15] = \"ALT_MVS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"BEOS\"] = 16] = \"BEOS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"TANDEM\"] = 17] = \"TANDEM\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"OS_400\"] = 18] = \"OS_400\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"OSX\"] = 19] = \"OSX\";\n    })(ExternalFileAttributeType || (ExternalFileAttributeType = {}));\n    /**\n     * 4.4.5\n     */\n    var CompressionMethod;\n    (function (CompressionMethod) {\n        CompressionMethod[CompressionMethod[\"STORED\"] = 0] = \"STORED\";\n        CompressionMethod[CompressionMethod[\"SHRUNK\"] = 1] = \"SHRUNK\";\n        CompressionMethod[CompressionMethod[\"REDUCED_1\"] = 2] = \"REDUCED_1\";\n        CompressionMethod[CompressionMethod[\"REDUCED_2\"] = 3] = \"REDUCED_2\";\n        CompressionMethod[CompressionMethod[\"REDUCED_3\"] = 4] = \"REDUCED_3\";\n        CompressionMethod[CompressionMethod[\"REDUCED_4\"] = 5] = \"REDUCED_4\";\n        CompressionMethod[CompressionMethod[\"IMPLODE\"] = 6] = \"IMPLODE\";\n        CompressionMethod[CompressionMethod[\"DEFLATE\"] = 8] = \"DEFLATE\";\n        CompressionMethod[CompressionMethod[\"DEFLATE64\"] = 9] = \"DEFLATE64\";\n        CompressionMethod[CompressionMethod[\"TERSE_OLD\"] = 10] = \"TERSE_OLD\";\n        CompressionMethod[CompressionMethod[\"BZIP2\"] = 12] = \"BZIP2\";\n        CompressionMethod[CompressionMethod[\"LZMA\"] = 14] = \"LZMA\";\n        CompressionMethod[CompressionMethod[\"TERSE_NEW\"] = 18] = \"TERSE_NEW\";\n        CompressionMethod[CompressionMethod[\"LZ77\"] = 19] = \"LZ77\";\n        CompressionMethod[CompressionMethod[\"WAVPACK\"] = 97] = \"WAVPACK\";\n        CompressionMethod[CompressionMethod[\"PPMD\"] = 98] = \"PPMD\"; // PPMd version I, Rev 1\n    })(CompressionMethod || (CompressionMethod = {}));\n    /**\n     * Converts the input time and date in MS-DOS format into a JavaScript Date\n     * object.\n     * @hidden\n     */\n    function msdos2date(time, date) {\n        // MS-DOS Date\n        // |0 0 0 0  0|0 0 0  0|0 0 0  0 0 0 0\n        //   D (1-31)  M (1-23)  Y (from 1980)\n        const day = date & 0x1F;\n        // JS date is 0-indexed, DOS is 1-indexed.\n        const month = ((date >> 5) & 0xF) - 1;\n        const year = (date >> 9) + 1980;\n        // MS DOS Time\n        // |0 0 0 0  0|0 0 0  0 0 0|0  0 0 0 0\n        //    Second      Minute       Hour\n        const second = time & 0x1F;\n        const minute = (time >> 5) & 0x3F;\n        const hour = time >> 11;\n        return new Date(year, month, day, hour, minute, second);\n    }\n    /**\n     * Safely returns the string from the buffer, even if it is 0 bytes long.\n     * (Normally, calling toString() on a buffer with start === end causes an\n     * exception).\n     * @hidden\n     */\n    function safeToString(buff, useUTF8, start, length) {\n        if (length === 0) {\n            return \"\";\n        }\n        else if (useUTF8) {\n            return buff.toString('utf8', start, start + length);\n        }\n        else {\n            return ExtendedASCII.byte2str(buff.slice(start, start + length));\n        }\n    }\n    /*\n       4.3.6 Overall .ZIP file format:\n\n          [local file header 1]\n          [encryption header 1]\n          [file data 1]\n          [data descriptor 1]\n          .\n          .\n          .\n          [local file header n]\n          [encryption header n]\n          [file data n]\n          [data descriptor n]\n          [archive decryption header]\n          [archive extra data record]\n          [central directory header 1]\n          .\n          .\n          .\n          [central directory header n]\n          [zip64 end of central directory record]\n          [zip64 end of central directory locator]\n          [end of central directory record]\n    */\n    /**\n     * 4.3.7  Local file header:\n     *\n     *     local file header signature     4 bytes  (0x04034b50)\n     *     version needed to extract       2 bytes\n     *     general purpose bit flag        2 bytes\n     *     compression method              2 bytes\n     *    last mod file time              2 bytes\n     *    last mod file date              2 bytes\n     *    crc-32                          4 bytes\n     *    compressed size                 4 bytes\n     *    uncompressed size               4 bytes\n     *    file name length                2 bytes\n     *    extra field length              2 bytes\n     *\n     *    file name (variable size)\n     *    extra field (variable size)\n     */\n    class FileHeader {\n        constructor(data) {\n            this.data = data;\n            if (data.readUInt32LE(0) !== 0x04034b50) {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid Zip file: Local file header has invalid signature: \" + this.data.readUInt32LE(0));\n            }\n        }\n        versionNeeded() { return this.data.readUInt16LE(4); }\n        flags() { return this.data.readUInt16LE(6); }\n        compressionMethod() { return this.data.readUInt16LE(8); }\n        lastModFileTime() {\n            // Time and date is in MS-DOS format.\n            return msdos2date(this.data.readUInt16LE(10), this.data.readUInt16LE(12));\n        }\n        rawLastModFileTime() {\n            return this.data.readUInt32LE(10);\n        }\n        crc32() { return this.data.readUInt32LE(14); }\n        /**\n         * These two values are COMPLETELY USELESS.\n         *\n         * Section 4.4.9:\n         *   If bit 3 of the general purpose bit flag is set,\n         *   these fields are set to zero in the local header and the\n         *   correct values are put in the data descriptor and\n         *   in the central directory.\n         *\n         * So we'll just use the central directory's values.\n         */\n        // public compressedSize(): number { return this.data.readUInt32LE(18); }\n        // public uncompressedSize(): number { return this.data.readUInt32LE(22); }\n        fileNameLength() { return this.data.readUInt16LE(26); }\n        extraFieldLength() { return this.data.readUInt16LE(28); }\n        fileName() {\n            return safeToString(this.data, this.useUTF8(), 30, this.fileNameLength());\n        }\n        extraField() {\n            const start = 30 + this.fileNameLength();\n            return this.data.slice(start, start + this.extraFieldLength());\n        }\n        totalSize() { return 30 + this.fileNameLength() + this.extraFieldLength(); }\n        useUTF8() { return (this.flags() & 0x800) === 0x800; }\n    }\n    /**\n     * 4.3.8  File data\n     *\n     *   Immediately following the local header for a file\n     *   SHOULD be placed the compressed or stored data for the file.\n     *   If the file is encrypted, the encryption header for the file\n     *   SHOULD be placed after the local header and before the file\n     *   data. The series of [local file header][encryption header]\n     *   [file data][data descriptor] repeats for each file in the\n     *   .ZIP archive.\n     *\n     *   Zero-byte files, directories, and other file types that\n     *   contain no content MUST not include file data.\n     */\n    class FileData {\n        constructor(header, record, data) {\n            this.header = header;\n            this.record = record;\n            this.data = data;\n        }\n        decompress() {\n            // Check the compression\n            const compressionMethod = this.header.compressionMethod();\n            const fcn = decompressionMethods[compressionMethod];\n            if (fcn) {\n                return fcn(this.data, this.record.compressedSize(), this.record.uncompressedSize(), this.record.flag());\n            }\n            else {\n                let name = CompressionMethod[compressionMethod];\n                if (!name) {\n                    name = `Unknown: ${compressionMethod}`;\n                }\n                throw new ApiError(ErrorCode.EINVAL, `Invalid compression method on file '${this.header.fileName()}': ${name}`);\n            }\n        }\n        getHeader() {\n            return this.header;\n        }\n        getRecord() {\n            return this.record;\n        }\n        getRawData() {\n            return this.data;\n        }\n    }\n    /**\n     * 4.3.9  Data descriptor:\n     *\n     *    crc-32                          4 bytes\n     *    compressed size                 4 bytes\n     *    uncompressed size               4 bytes\n     */\n    class DataDescriptor {\n        constructor(data) {\n            this.data = data;\n        }\n        crc32() { return this.data.readUInt32LE(0); }\n        compressedSize() { return this.data.readUInt32LE(4); }\n        uncompressedSize() { return this.data.readUInt32LE(8); }\n    }\n    /*\n    ` 4.3.10  Archive decryption header:\n\n          4.3.10.1 The Archive Decryption Header is introduced in version 6.2\n          of the ZIP format specification.  This record exists in support\n          of the Central Directory Encryption Feature implemented as part of\n          the Strong Encryption Specification as described in this document.\n          When the Central Directory Structure is encrypted, this decryption\n          header MUST precede the encrypted data segment.\n     */\n    /**\n     * 4.3.11  Archive extra data record:\n     *\n     *      archive extra data signature    4 bytes  (0x08064b50)\n     *      extra field length              4 bytes\n     *      extra field data                (variable size)\n     *\n     *    4.3.11.1 The Archive Extra Data Record is introduced in version 6.2\n     *    of the ZIP format specification.  This record MAY be used in support\n     *    of the Central Directory Encryption Feature implemented as part of\n     *    the Strong Encryption Specification as described in this document.\n     *    When present, this record MUST immediately precede the central\n     *    directory data structure.\n     */\n    class ArchiveExtraDataRecord {\n        constructor(data) {\n            this.data = data;\n            if (this.data.readUInt32LE(0) !== 0x08064b50) {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid archive extra data record signature: \" + this.data.readUInt32LE(0));\n            }\n        }\n        length() { return this.data.readUInt32LE(4); }\n        extraFieldData() { return this.data.slice(8, 8 + this.length()); }\n    }\n    /**\n     * 4.3.13 Digital signature:\n     *\n     *      header signature                4 bytes  (0x05054b50)\n     *      size of data                    2 bytes\n     *      signature data (variable size)\n     *\n     *    With the introduction of the Central Directory Encryption\n     *    feature in version 6.2 of this specification, the Central\n     *    Directory Structure MAY be stored both compressed and encrypted.\n     *    Although not required, it is assumed when encrypting the\n     *    Central Directory Structure, that it will be compressed\n     *    for greater storage efficiency.  Information on the\n     *    Central Directory Encryption feature can be found in the section\n     *    describing the Strong Encryption Specification. The Digital\n     *    Signature record will be neither compressed nor encrypted.\n     */\n    class DigitalSignature {\n        constructor(data) {\n            this.data = data;\n            if (this.data.readUInt32LE(0) !== 0x05054b50) {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid digital signature signature: \" + this.data.readUInt32LE(0));\n            }\n        }\n        size() { return this.data.readUInt16LE(4); }\n        signatureData() { return this.data.slice(6, 6 + this.size()); }\n    }\n    /**\n     * 4.3.12  Central directory structure:\n     *\n     *  central file header signature   4 bytes  (0x02014b50)\n     *  version made by                 2 bytes\n     *  version needed to extract       2 bytes\n     *  general purpose bit flag        2 bytes\n     *  compression method              2 bytes\n     *  last mod file time              2 bytes\n     *  last mod file date              2 bytes\n     *  crc-32                          4 bytes\n     *  compressed size                 4 bytes\n     *  uncompressed size               4 bytes\n     *  file name length                2 bytes\n     *  extra field length              2 bytes\n     *  file comment length             2 bytes\n     *  disk number start               2 bytes\n     *  internal file attributes        2 bytes\n     *  external file attributes        4 bytes\n     *  relative offset of local header 4 bytes\n     *\n     *  file name (variable size)\n     *  extra field (variable size)\n     *  file comment (variable size)\n     */\n    class CentralDirectory {\n        constructor(zipData, data) {\n            this.zipData = zipData;\n            this.data = data;\n            // Sanity check.\n            if (this.data.readUInt32LE(0) !== 0x02014b50) {\n                throw new ApiError(ErrorCode.EINVAL, `Invalid Zip file: Central directory record has invalid signature: ${this.data.readUInt32LE(0)}`);\n            }\n            this._filename = this.produceFilename();\n        }\n        versionMadeBy() { return this.data.readUInt16LE(4); }\n        versionNeeded() { return this.data.readUInt16LE(6); }\n        flag() { return this.data.readUInt16LE(8); }\n        compressionMethod() { return this.data.readUInt16LE(10); }\n        lastModFileTime() {\n            // Time and date is in MS-DOS format.\n            return msdos2date(this.data.readUInt16LE(12), this.data.readUInt16LE(14));\n        }\n        rawLastModFileTime() {\n            return this.data.readUInt32LE(12);\n        }\n        crc32() { return this.data.readUInt32LE(16); }\n        compressedSize() { return this.data.readUInt32LE(20); }\n        uncompressedSize() { return this.data.readUInt32LE(24); }\n        fileNameLength() { return this.data.readUInt16LE(28); }\n        extraFieldLength() { return this.data.readUInt16LE(30); }\n        fileCommentLength() { return this.data.readUInt16LE(32); }\n        diskNumberStart() { return this.data.readUInt16LE(34); }\n        internalAttributes() { return this.data.readUInt16LE(36); }\n        externalAttributes() { return this.data.readUInt32LE(38); }\n        headerRelativeOffset() { return this.data.readUInt32LE(42); }\n        produceFilename() {\n            /*\n              4.4.17.1 claims:\n              * All slashes are forward ('/') slashes.\n              * Filename doesn't begin with a slash.\n              * No drive letters or any nonsense like that.\n              * If filename is missing, the input came from standard input.\n        \n              Unfortunately, this isn't true in practice. Some Windows zip utilities use\n              a backslash here, but the correct Unix-style path in file headers.\n        \n              To avoid seeking all over the file to recover the known-good filenames\n              from file headers, we simply convert '/' to '\\' here.\n            */\n            const fileName = safeToString(this.data, this.useUTF8(), 46, this.fileNameLength());\n            return fileName.replace(/\\\\/g, \"/\");\n        }\n        fileName() {\n            return this._filename;\n        }\n        rawFileName() {\n            return this.data.slice(46, 46 + this.fileNameLength());\n        }\n        extraField() {\n            const start = 44 + this.fileNameLength();\n            return this.data.slice(start, start + this.extraFieldLength());\n        }\n        fileComment() {\n            const start = 46 + this.fileNameLength() + this.extraFieldLength();\n            return safeToString(this.data, this.useUTF8(), start, this.fileCommentLength());\n        }\n        rawFileComment() {\n            const start = 46 + this.fileNameLength() + this.extraFieldLength();\n            return this.data.slice(start, start + this.fileCommentLength());\n        }\n        totalSize() {\n            return 46 + this.fileNameLength() + this.extraFieldLength() + this.fileCommentLength();\n        }\n        isDirectory() {\n            // NOTE: This assumes that the zip file implementation uses the lower byte\n            //       of external attributes for DOS attributes for\n            //       backwards-compatibility. This is not mandated, but appears to be\n            //       commonplace.\n            //       According to the spec, the layout of external attributes is\n            //       platform-dependent.\n            //       If that fails, we also check if the name of the file ends in '/',\n            //       which is what Java's ZipFile implementation does.\n            const fileName = this.fileName();\n            return (this.externalAttributes() & 0x10 ? true : false) || (fileName.charAt(fileName.length - 1) === '/');\n        }\n        isFile() { return !this.isDirectory(); }\n        useUTF8() { return (this.flag() & 0x800) === 0x800; }\n        isEncrypted() { return (this.flag() & 0x1) === 0x1; }\n        getFileData() {\n            // Need to grab the header before we can figure out where the actual\n            // compressed data starts.\n            const start = this.headerRelativeOffset();\n            const header = new FileHeader(this.zipData.slice(start));\n            return new FileData(header, this, this.zipData.slice(start + header.totalSize()));\n        }\n        getData() {\n            return this.getFileData().decompress();\n        }\n        getRawData() {\n            return this.getFileData().getRawData();\n        }\n        getStats() {\n            return new Stats(FileType.FILE, this.uncompressedSize(), 0x16D, Date.now(), this.lastModFileTime().getTime());\n        }\n    }\n    /**\n     * 4.3.16: end of central directory record\n     *  end of central dir signature    4 bytes  (0x06054b50)\n     *  number of this disk             2 bytes\n     *  number of the disk with the\n     *  start of the central directory  2 bytes\n     *  total number of entries in the\n     *  central directory on this disk  2 bytes\n     *  total number of entries in\n     *  the central directory           2 bytes\n     *  size of the central directory   4 bytes\n     *  offset of start of central\n     *  directory with respect to\n     *  the starting disk number        4 bytes\n     *  .ZIP file comment length        2 bytes\n     *  .ZIP file comment       (variable size)\n     */\n    class EndOfCentralDirectory {\n        constructor(data) {\n            this.data = data;\n            if (this.data.readUInt32LE(0) !== 0x06054b50) {\n                throw new ApiError(ErrorCode.EINVAL, `Invalid Zip file: End of central directory record has invalid signature: ${this.data.readUInt32LE(0)}`);\n            }\n        }\n        diskNumber() { return this.data.readUInt16LE(4); }\n        cdDiskNumber() { return this.data.readUInt16LE(6); }\n        cdDiskEntryCount() { return this.data.readUInt16LE(8); }\n        cdTotalEntryCount() { return this.data.readUInt16LE(10); }\n        cdSize() { return this.data.readUInt32LE(12); }\n        cdOffset() { return this.data.readUInt32LE(16); }\n        cdZipCommentLength() { return this.data.readUInt16LE(20); }\n        cdZipComment() {\n            // Assuming UTF-8. The specification doesn't specify.\n            return safeToString(this.data, true, 22, this.cdZipCommentLength());\n        }\n        rawCdZipComment() {\n            return this.data.slice(22, 22 + this.cdZipCommentLength());\n        }\n    }\n    /**\n     * Contains the table of contents of a Zip file.\n     */\n    class ZipTOC {\n        constructor(index, directoryEntries, eocd, data) {\n            this.index = index;\n            this.directoryEntries = directoryEntries;\n            this.eocd = eocd;\n            this.data = data;\n        }\n    }\n    /**\n     * Zip file-backed filesystem\n     * Implemented according to the standard:\n     * http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n     *\n     * While there are a few zip libraries for JavaScript (e.g. JSZip and zip.js),\n     * they are not a good match for BrowserFS. In particular, these libraries\n     * perform a lot of unneeded data copying, and eagerly decompress every file\n     * in the zip file upon loading to check the CRC32. They also eagerly decode\n     * strings. Furthermore, these libraries duplicate functionality already present\n     * in BrowserFS (e.g. UTF-8 decoding and binary data manipulation).\n     *\n     * This filesystem takes advantage of BrowserFS's Buffer implementation, which\n     * efficiently represents the zip file in memory (in both ArrayBuffer-enabled\n     * browsers *and* non-ArrayBuffer browsers), and which can neatly be 'sliced'\n     * without copying data. Each struct defined in the standard is represented with\n     * a buffer slice pointing to an offset in the zip file, and has getters for\n     * each field. As we anticipate that this data will not be read often, we choose\n     * not to store each struct field in the JavaScript object; instead, to reduce\n     * memory consumption, we retrieve it directly from the binary data each time it\n     * is requested.\n     *\n     * When the filesystem is instantiated, we determine the directory structure\n     * of the zip file as quickly as possible. We lazily decompress and check the\n     * CRC32 of files. We do not cache decompressed files; if this is a desired\n     * feature, it is best implemented as a generic file system wrapper that can\n     * cache data from arbitrary file systems.\n     *\n     * For inflation, we use `pako`'s implementation:\n     * https://github.com/nodeca/pako\n     *\n     * Current limitations:\n     * * No encryption.\n     * * No ZIP64 support.\n     * * Read-only.\n     *   Write support would require that we:\n     *   - Keep track of changed/new files.\n     *   - Compress changed files, and generate appropriate metadata for each.\n     *   - Update file offsets for other files in the zip file.\n     *   - Stream it out to a location.\n     *   This isn't that bad, so we might do this at a later date.\n     */\n    class ZipFS extends SynchronousFileSystem {\n        constructor(input, name = '') {\n            super();\n            this.name = name;\n            this._index = new FileIndex();\n            this._directoryEntries = [];\n            this._eocd = null;\n            this._index = input.index;\n            this._directoryEntries = input.directoryEntries;\n            this._eocd = input.eocd;\n            this.data = input.data;\n        }\n        /**\n         * Constructs a ZipFS instance with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                ZipFS._computeIndex(opts.zipData, (e, zipTOC) => {\n                    if (zipTOC) {\n                        const fs = new ZipFS(zipTOC, opts.name);\n                        cb(null, fs);\n                    }\n                    else {\n                        cb(e);\n                    }\n                });\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() { return true; }\n        static RegisterDecompressionMethod(m, fcn) {\n            decompressionMethods[m] = fcn;\n        }\n        /**\n         * Locates the end of central directory record at the end of the file.\n         * Throws an exception if it cannot be found.\n         */\n        static _getEOCD(data) {\n            // Unfortunately, the comment is variable size and up to 64K in size.\n            // We assume that the magic signature does not appear in the comment, and\n            // in the bytes between the comment and the signature. Other ZIP\n            // implementations make this same assumption, since the alternative is to\n            // read thread every entry in the file to get to it. :(\n            // These are *negative* offsets from the end of the file.\n            const startOffset = 22;\n            const endOffset = Math.min(startOffset + 0xFFFF, data.length - 1);\n            // There's not even a byte alignment guarantee on the comment so we need to\n            // search byte by byte. *grumble grumble*\n            for (let i = startOffset; i < endOffset; i++) {\n                // Magic number: EOCD Signature\n                if (data.readUInt32LE(data.length - i) === 0x06054b50) {\n                    return new EndOfCentralDirectory(data.slice(data.length - i));\n                }\n            }\n            throw new ApiError(ErrorCode.EINVAL, \"Invalid ZIP file: Could not locate End of Central Directory signature.\");\n        }\n        static _addToIndex(cd, index) {\n            // Paths must be absolute, yet zip file paths are always relative to the\n            // zip root. So we append '/' and call it a day.\n            let filename = cd.fileName();\n            if (filename.charAt(0) === '/') {\n                throw new ApiError(ErrorCode.EPERM, `Unexpectedly encountered an absolute path in a zip file. Please file a bug.`);\n            }\n            // XXX: For the file index, strip the trailing '/'.\n            if (filename.charAt(filename.length - 1) === '/') {\n                filename = filename.substr(0, filename.length - 1);\n            }\n            if (cd.isDirectory()) {\n                index.addPathFast('/' + filename, new DirInode(cd));\n            }\n            else {\n                index.addPathFast('/' + filename, new FileInode(cd));\n            }\n        }\n        static _computeIndex(data, cb) {\n            try {\n                const index = new FileIndex();\n                const eocd = ZipFS._getEOCD(data);\n                if (eocd.diskNumber() !== eocd.cdDiskNumber()) {\n                    return cb(new ApiError(ErrorCode.EINVAL, \"ZipFS does not support spanned zip files.\"));\n                }\n                const cdPtr = eocd.cdOffset();\n                if (cdPtr === 0xFFFFFFFF) {\n                    return cb(new ApiError(ErrorCode.EINVAL, \"ZipFS does not support Zip64.\"));\n                }\n                const cdEnd = cdPtr + eocd.cdSize();\n                ZipFS._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, [], eocd);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static _computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {\n            try {\n                ZipFS._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static _computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {\n            if (cdPtr < cdEnd) {\n                let count = 0;\n                while (count++ < 200 && cdPtr < cdEnd) {\n                    const cd = new CentralDirectory(data, data.slice(cdPtr));\n                    ZipFS._addToIndex(cd, index);\n                    cdPtr += cd.totalSize();\n                    cdEntries.push(cd);\n                }\n                setImmediate(() => {\n                    ZipFS._computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);\n                });\n            }\n            else {\n                cb(null, new ZipTOC(index, cdEntries, eocd, data));\n            }\n        }\n        getName() {\n            return ZipFS.Name + (this.name !== '' ? ` ${this.name}` : '');\n        }\n        /**\n         * Get the CentralDirectory object for the given path.\n         */\n        getCentralDirectoryEntry(path) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            if (isFileInode(inode)) {\n                return inode.getData();\n            }\n            else if (isDirInode(inode)) {\n                return inode.getData();\n            }\n            else {\n                // Should never occur.\n                throw ApiError.EPERM(`Invalid inode: ${inode}`);\n            }\n        }\n        getCentralDirectoryEntryAt(index) {\n            const dirEntry = this._directoryEntries[index];\n            if (!dirEntry) {\n                throw new RangeError(`Invalid directory index: ${index}.`);\n            }\n            return dirEntry;\n        }\n        getNumberOfCentralDirectoryEntries() {\n            return this._directoryEntries.length;\n        }\n        getEndOfCentralDirectory() {\n            return this._eocd;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system.\n            cb(this.data.length, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return true;\n        }\n        statSync(path, isLstat) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData().getStats();\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n            }\n            else {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid inode.\");\n            }\n            return stats;\n        }\n        openSync(path, flags, mode) {\n            // INVARIANT: Cannot write to RO file systems.\n            if (flags.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, path);\n            }\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (!inode) {\n                throw ApiError.ENOENT(path);\n            }\n            else if (isFileInode(inode)) {\n                const cdRecord = inode.getData();\n                const stats = cdRecord.getStats();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw ApiError.EEXIST(path);\n                    case ActionType.NOP:\n                        return new NoSyncFile(this, path, flags, stats, cdRecord.getData());\n                    default:\n                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw ApiError.EISDIR(path);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const inode = this._index.getInode(path);\n            if (!inode) {\n                throw ApiError.ENOENT(path);\n            }\n            else if (isDirInode(inode)) {\n                return inode.getListing();\n            }\n            else {\n                throw ApiError.ENOTDIR(path);\n            }\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n    }\n    ZipFS.Name = \"ZipFS\";\n    ZipFS.Options = {\n        zipData: {\n            type: \"object\",\n            description: \"The zip file as a Buffer object.\",\n            validator: bufferValidator\n        },\n        name: {\n            type: \"string\",\n            optional: true,\n            description: \"The name of the zip file (optional).\"\n        }\n    };\n    ZipFS.CompressionMethod = CompressionMethod;\n    ZipFS.RegisterDecompressionMethod(CompressionMethod.DEFLATE, (data, compressedSize, uncompressedSize) => {\n        return arrayish2Buffer(inflateRaw(data.slice(0, compressedSize), { chunkSize: uncompressedSize }));\n    });\n    ZipFS.RegisterDecompressionMethod(CompressionMethod.STORED, (data, compressedSize, uncompressedSize) => {\n        return copyingSlice(data, 0, uncompressedSize);\n    });\n\n    return ZipFS;\n\n});\ndefine('skylark-browserfs/backend/IsoFS',[\n    '../core/api_error',\n    '../core/node_fs_stats',\n    '../core/file_system',\n    '../core/file_flag',\n    '../generic/preload_file',\n    '../core/util',\n    '../libs/path'\n], function (api_error,  node_fs_stats,file_system, file_flag, preload_file, util, path) {\n    'use strict';\n\n    const { ApiError, ErrorCode } = api_error;\n    const { Stats, FileType }  = node_fs_stats;\n    const { SynchronousFileSystem }  = file_system;\n    const { ActionType }  = file_flag;\n    const { NoSyncFile }  = preload_file;\n    const { copyingSlice, bufferValidator }  = util;\n\n    /**\n     * @hidden\n     */\n    const rockRidgeIdentifier = \"IEEE_P1282\";\n    /**\n     * @hidden\n     */\n    function getASCIIString(data, startIndex, length) {\n        return data.toString('ascii', startIndex, startIndex + length).trim();\n    }\n    /**\n     * @hidden\n     */\n    function getJolietString(data, startIndex, length) {\n        if (length === 1) {\n            // Special: Root, parent, current directory are still a single byte.\n            return String.fromCharCode(data[startIndex]);\n        }\n        // UTF16-BE, which isn't natively supported by NodeJS Buffers.\n        // Length should be even, but pessimistically floor just in case.\n        const pairs = Math.floor(length / 2);\n        const chars = new Array(pairs);\n        for (let i = 0; i < pairs; i++) {\n            const pos = startIndex + (i << 1);\n            chars[i] = String.fromCharCode(data[pos + 1] | (data[pos] << 8));\n        }\n        return chars.join('');\n    }\n    /**\n     * @hidden\n     */\n    function getDate(data, startIndex) {\n        const year = parseInt(getASCIIString(data, startIndex, 4), 10);\n        const mon = parseInt(getASCIIString(data, startIndex + 4, 2), 10);\n        const day = parseInt(getASCIIString(data, startIndex + 6, 2), 10);\n        const hour = parseInt(getASCIIString(data, startIndex + 8, 2), 10);\n        const min = parseInt(getASCIIString(data, startIndex + 10, 2), 10);\n        const sec = parseInt(getASCIIString(data, startIndex + 12, 2), 10);\n        const hundrethsSec = parseInt(getASCIIString(data, startIndex + 14, 2), 10);\n        // Last is a time-zone offset, but JavaScript dates don't support time zones well.\n        return new Date(year, mon, day, hour, min, sec, hundrethsSec * 100);\n    }\n    /**\n     * @hidden\n     */\n    function getShortFormDate(data, startIndex) {\n        const yearsSince1900 = data[startIndex];\n        const month = data[startIndex + 1];\n        const day = data[startIndex + 2];\n        const hour = data[startIndex + 3];\n        const minute = data[startIndex + 4];\n        const second = data[startIndex + 5];\n        // JavaScript's Date support isn't so great; ignore timezone.\n        // const offsetFromGMT = this._data[24];\n        return new Date(yearsSince1900, month - 1, day, hour, minute, second);\n    }\n    /**\n     * @hidden\n     */\n    function constructSystemUseEntry(bigData, i) {\n        const data = bigData.slice(i);\n        const sue = new SystemUseEntry(data);\n        switch (sue.signatureWord()) {\n            case 17221 /* CE */:\n                return new CEEntry(data);\n            case 20548 /* PD */:\n                return new PDEntry(data);\n            case 21328 /* SP */:\n                return new SPEntry(data);\n            case 21332 /* ST */:\n                return new STEntry(data);\n            case 17746 /* ER */:\n                return new EREntry(data);\n            case 17747 /* ES */:\n                return new ESEntry(data);\n            case 20568 /* PX */:\n                return new PXEntry(data);\n            case 20558 /* PN */:\n                return new PNEntry(data);\n            case 21324 /* SL */:\n                return new SLEntry(data);\n            case 20045 /* NM */:\n                return new NMEntry(data);\n            case 17228 /* CL */:\n                return new CLEntry(data);\n            case 20556 /* PL */:\n                return new PLEntry(data);\n            case 21061 /* RE */:\n                return new REEntry(data);\n            case 21574 /* TF */:\n                return new TFEntry(data);\n            case 21318 /* SF */:\n                return new SFEntry(data);\n            case 21074 /* RR */:\n                return new RREntry(data);\n            default:\n                return sue;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function constructSystemUseEntries(data, i, len, isoData) {\n        // If the remaining allocated space following the last recorded System Use Entry in a System\n        // Use field or Continuation Area is less than four bytes long, it cannot contain a System\n        // Use Entry and shall be ignored\n        len = len - 4;\n        let entries = new Array();\n        while (i < len) {\n            const entry = constructSystemUseEntry(data, i);\n            const length = entry.length();\n            if (length === 0) {\n                // Invalid SU section; prevent infinite loop.\n                return entries;\n            }\n            i += length;\n            if (entry instanceof STEntry) {\n                // ST indicates the end of entries.\n                break;\n            }\n            if (entry instanceof CEEntry) {\n                entries = entries.concat(entry.getEntries(isoData));\n            }\n            else {\n                entries.push(entry);\n            }\n        }\n        return entries;\n    }\n    /**\n     * @hidden\n     */\n    class VolumeDescriptor {\n        constructor(data) {\n            this._data = data;\n        }\n        type() {\n            return this._data[0];\n        }\n        standardIdentifier() {\n            return getASCIIString(this._data, 1, 5);\n        }\n        version() {\n            return this._data[6];\n        }\n        data() {\n            return this._data.slice(7, 2048);\n        }\n    }\n    /**\n     * @hidden\n     */\n    class PrimaryOrSupplementaryVolumeDescriptor extends VolumeDescriptor {\n        constructor(data) {\n            super(data);\n            this._root = null;\n        }\n        systemIdentifier() {\n            return this._getString32(8);\n        }\n        volumeIdentifier() {\n            return this._getString32(40);\n        }\n        volumeSpaceSize() {\n            return this._data.readUInt32LE(80);\n        }\n        volumeSetSize() {\n            return this._data.readUInt16LE(120);\n        }\n        volumeSequenceNumber() {\n            return this._data.readUInt16LE(124);\n        }\n        logicalBlockSize() {\n            return this._data.readUInt16LE(128);\n        }\n        pathTableSize() {\n            return this._data.readUInt32LE(132);\n        }\n        locationOfTypeLPathTable() {\n            return this._data.readUInt32LE(140);\n        }\n        locationOfOptionalTypeLPathTable() {\n            return this._data.readUInt32LE(144);\n        }\n        locationOfTypeMPathTable() {\n            return this._data.readUInt32BE(148);\n        }\n        locationOfOptionalTypeMPathTable() {\n            return this._data.readUInt32BE(152);\n        }\n        rootDirectoryEntry(isoData) {\n            if (this._root === null) {\n                this._root = this._constructRootDirectoryRecord(this._data.slice(156));\n                this._root.rootCheckForRockRidge(isoData);\n            }\n            return this._root;\n        }\n        volumeSetIdentifier() {\n            return this._getString(190, 128);\n        }\n        publisherIdentifier() {\n            return this._getString(318, 128);\n        }\n        dataPreparerIdentifier() {\n            return this._getString(446, 128);\n        }\n        applicationIdentifier() {\n            return this._getString(574, 128);\n        }\n        copyrightFileIdentifier() {\n            return this._getString(702, 38);\n        }\n        abstractFileIdentifier() {\n            return this._getString(740, 36);\n        }\n        bibliographicFileIdentifier() {\n            return this._getString(776, 37);\n        }\n        volumeCreationDate() {\n            return getDate(this._data, 813);\n        }\n        volumeModificationDate() {\n            return getDate(this._data, 830);\n        }\n        volumeExpirationDate() {\n            return getDate(this._data, 847);\n        }\n        volumeEffectiveDate() {\n            return getDate(this._data, 864);\n        }\n        fileStructureVersion() {\n            return this._data[881];\n        }\n        applicationUsed() {\n            return this._data.slice(883, 883 + 512);\n        }\n        reserved() {\n            return this._data.slice(1395, 1395 + 653);\n        }\n        _getString32(idx) {\n            return this._getString(idx, 32);\n        }\n    }\n    /**\n     * @hidden\n     */\n    class PrimaryVolumeDescriptor extends PrimaryOrSupplementaryVolumeDescriptor {\n        constructor(data) {\n            super(data);\n            if (this.type() !== 1 /* PrimaryVolumeDescriptor */) {\n                throw new ApiError(ErrorCode.EIO, `Invalid primary volume descriptor.`);\n            }\n        }\n        name() {\n            return \"ISO9660\";\n        }\n        _constructRootDirectoryRecord(data) {\n            return new ISODirectoryRecord(data, -1);\n        }\n        _getString(idx, len) {\n            return this._getString(idx, len);\n        }\n    }\n    /**\n     * @hidden\n     */\n    class SupplementaryVolumeDescriptor extends PrimaryOrSupplementaryVolumeDescriptor {\n        constructor(data) {\n            super(data);\n            if (this.type() !== 2 /* SupplementaryVolumeDescriptor */) {\n                throw new ApiError(ErrorCode.EIO, `Invalid supplementary volume descriptor.`);\n            }\n            const escapeSequence = this.escapeSequence();\n            const third = escapeSequence[2];\n            // Third character identifies what 'level' of the UCS specification to follow.\n            // We ignore it.\n            if (escapeSequence[0] !== 0x25 || escapeSequence[1] !== 0x2F ||\n                (third !== 0x40 && third !== 0x43 && third !== 0x45)) {\n                throw new ApiError(ErrorCode.EIO, `Unrecognized escape sequence for SupplementaryVolumeDescriptor: ${escapeSequence.toString()}`);\n            }\n        }\n        name() {\n            return \"Joliet\";\n        }\n        escapeSequence() {\n            return this._data.slice(88, 120);\n        }\n        _constructRootDirectoryRecord(data) {\n            return new JolietDirectoryRecord(data, -1);\n        }\n        _getString(idx, len) {\n            return getJolietString(this._data, idx, len);\n        }\n    }\n    /**\n     * @hidden\n     */\n    class DirectoryRecord {\n        constructor(data, rockRidgeOffset) {\n            this._suEntries = null;\n            this._fileOrDir = null;\n            this._data = data;\n            this._rockRidgeOffset = rockRidgeOffset;\n        }\n        hasRockRidge() {\n            return this._rockRidgeOffset > -1;\n        }\n        getRockRidgeOffset() {\n            return this._rockRidgeOffset;\n        }\n        /**\n         * !!ONLY VALID ON ROOT NODE!!\n         * Checks if Rock Ridge is enabled, and sets the offset.\n         */\n        rootCheckForRockRidge(isoData) {\n            const dir = this.getDirectory(isoData);\n            this._rockRidgeOffset = dir.getDotEntry(isoData)._getRockRidgeOffset(isoData);\n            if (this._rockRidgeOffset > -1) {\n                // Wipe out directory. Start over with RR knowledge.\n                this._fileOrDir = null;\n            }\n        }\n        length() {\n            return this._data[0];\n        }\n        extendedAttributeRecordLength() {\n            return this._data[1];\n        }\n        lba() {\n            return this._data.readUInt32LE(2) * 2048;\n        }\n        dataLength() {\n            return this._data.readUInt32LE(10);\n        }\n        recordingDate() {\n            return getShortFormDate(this._data, 18);\n        }\n        fileFlags() {\n            return this._data[25];\n        }\n        fileUnitSize() {\n            return this._data[26];\n        }\n        interleaveGapSize() {\n            return this._data[27];\n        }\n        volumeSequenceNumber() {\n            return this._data.readUInt16LE(28);\n        }\n        identifier() {\n            return this._getString(33, this._data[32]);\n        }\n        fileName(isoData) {\n            if (this.hasRockRidge()) {\n                const fn = this._rockRidgeFilename(isoData);\n                if (fn !== null) {\n                    return fn;\n                }\n            }\n            const ident = this.identifier();\n            if (this.isDirectory(isoData)) {\n                return ident;\n            }\n            // Files:\n            // - MUST have 0x2E (.) separating the name from the extension\n            // - MUST have 0x3B (;) separating the file name and extension from the version\n            // Gets expanded to two-byte char in Unicode directory records.\n            const versionSeparator = ident.indexOf(';');\n            if (versionSeparator === -1) {\n                // Some Joliet filenames lack the version separator, despite the standard\n                // specifying that it should be there.\n                return ident;\n            }\n            else if (ident[versionSeparator - 1] === '.') {\n                // Empty extension. Do not include '.' in the filename.\n                return ident.slice(0, versionSeparator - 1);\n            }\n            else {\n                // Include up to version separator.\n                return ident.slice(0, versionSeparator);\n            }\n        }\n        isDirectory(isoData) {\n            let rv = !!(this.fileFlags() & 2 /* Directory */);\n            // If it lacks the Directory flag, it may still be a directory if we've exceeded the directory\n            // depth limit. Rock Ridge marks these as files and adds a special attribute.\n            if (!rv && this.hasRockRidge()) {\n                rv = this.getSUEntries(isoData).filter((e) => e instanceof CLEntry).length > 0;\n            }\n            return rv;\n        }\n        isSymlink(isoData) {\n            return this.hasRockRidge() && this.getSUEntries(isoData).filter((e) => e instanceof SLEntry).length > 0;\n        }\n        getSymlinkPath(isoData) {\n            let p = \"\";\n            const entries = this.getSUEntries(isoData);\n            const getStr = this._getGetString();\n            for (const entry of entries) {\n                if (entry instanceof SLEntry) {\n                    const components = entry.componentRecords();\n                    for (const component of components) {\n                        const flags = component.flags();\n                        if (flags & 2 /* CURRENT */) {\n                            p += \"./\";\n                        }\n                        else if (flags & 4 /* PARENT */) {\n                            p += \"../\";\n                        }\n                        else if (flags & 8 /* ROOT */) {\n                            p += \"/\";\n                        }\n                        else {\n                            p += component.content(getStr);\n                            if (!(flags & 1 /* CONTINUE */)) {\n                                p += '/';\n                            }\n                        }\n                    }\n                    if (!entry.continueFlag()) {\n                        // We are done with this link.\n                        break;\n                    }\n                }\n            }\n            if (p.length > 1 && p[p.length - 1] === '/') {\n                // Trim trailing '/'.\n                return p.slice(0, p.length - 1);\n            }\n            else {\n                return p;\n            }\n        }\n        getFile(isoData) {\n            if (this.isDirectory(isoData)) {\n                throw new Error(`Tried to get a File from a directory.`);\n            }\n            if (this._fileOrDir === null) {\n                this._fileOrDir = isoData.slice(this.lba(), this.lba() + this.dataLength());\n            }\n            return this._fileOrDir;\n        }\n        getDirectory(isoData) {\n            if (!this.isDirectory(isoData)) {\n                throw new Error(`Tried to get a Directory from a file.`);\n            }\n            if (this._fileOrDir === null) {\n                this._fileOrDir = this._constructDirectory(isoData);\n            }\n            return this._fileOrDir;\n        }\n        getSUEntries(isoData) {\n            if (!this._suEntries) {\n                this._constructSUEntries(isoData);\n            }\n            return this._suEntries;\n        }\n        _rockRidgeFilename(isoData) {\n            const nmEntries = this.getSUEntries(isoData).filter((e) => e instanceof NMEntry);\n            if (nmEntries.length === 0 || nmEntries[0].flags() & (2 /* CURRENT */ | 4 /* PARENT */)) {\n                return null;\n            }\n            let str = '';\n            const getString = this._getGetString();\n            for (const e of nmEntries) {\n                str += e.name(getString);\n                if (!(e.flags() & 1 /* CONTINUE */)) {\n                    break;\n                }\n            }\n            return str;\n        }\n        _constructSUEntries(isoData) {\n            let i = 33 + this._data[32];\n            if (i % 2 === 1) {\n                // Skip padding field.\n                i++;\n            }\n            i += this._rockRidgeOffset;\n            this._suEntries = constructSystemUseEntries(this._data, i, this.length(), isoData);\n        }\n        /**\n         * !!ONLY VALID ON FIRST ENTRY OF ROOT DIRECTORY!!\n         * Returns -1 if rock ridge is not enabled. Otherwise, returns the offset\n         * at which system use fields begin.\n         */\n        _getRockRidgeOffset(isoData) {\n            // In the worst case, we get some garbage SU entries.\n            // Fudge offset to 0 before proceeding.\n            this._rockRidgeOffset = 0;\n            const suEntries = this.getSUEntries(isoData);\n            if (suEntries.length > 0) {\n                const spEntry = suEntries[0];\n                if (spEntry instanceof SPEntry && spEntry.checkBytesPass()) {\n                    // SUSP is in use.\n                    for (let i = 1; i < suEntries.length; i++) {\n                        const entry = suEntries[i];\n                        if (entry instanceof RREntry || (entry instanceof EREntry && entry.extensionIdentifier() === rockRidgeIdentifier)) {\n                            // Rock Ridge is in use!\n                            return spEntry.bytesSkipped();\n                        }\n                    }\n                }\n            }\n            // Failed.\n            this._rockRidgeOffset = -1;\n            return -1;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class ISODirectoryRecord extends DirectoryRecord {\n        constructor(data, rockRidgeOffset) {\n            super(data, rockRidgeOffset);\n        }\n        _getString(i, len) {\n            return getASCIIString(this._data, i, len);\n        }\n        _constructDirectory(isoData) {\n            return new ISODirectory(this, isoData);\n        }\n        _getGetString() {\n            return getASCIIString;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class JolietDirectoryRecord extends DirectoryRecord {\n        constructor(data, rockRidgeOffset) {\n            super(data, rockRidgeOffset);\n        }\n        _getString(i, len) {\n            return getJolietString(this._data, i, len);\n        }\n        _constructDirectory(isoData) {\n            return new JolietDirectory(this, isoData);\n        }\n        _getGetString() {\n            return getJolietString;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class SystemUseEntry {\n        constructor(data) {\n            this._data = data;\n        }\n        signatureWord() {\n            return this._data.readUInt16BE(0);\n        }\n        signatureWordString() {\n            return getASCIIString(this._data, 0, 2);\n        }\n        length() {\n            return this._data[2];\n        }\n        suVersion() {\n            return this._data[3];\n        }\n    }\n    /**\n     * Continuation entry.\n     * @hidden\n     */\n    class CEEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n            this._entries = null;\n        }\n        /**\n         * Logical block address of the continuation area.\n         */\n        continuationLba() {\n            return this._data.readUInt32LE(4);\n        }\n        /**\n         * Offset into the logical block.\n         */\n        continuationLbaOffset() {\n            return this._data.readUInt32LE(12);\n        }\n        /**\n         * Length of the continuation area.\n         */\n        continuationLength() {\n            return this._data.readUInt32LE(20);\n        }\n        getEntries(isoData) {\n            if (!this._entries) {\n                const start = this.continuationLba() * 2048 + this.continuationLbaOffset();\n                this._entries = constructSystemUseEntries(isoData, start, this.continuationLength(), isoData);\n            }\n            return this._entries;\n        }\n    }\n    /**\n     * Padding entry.\n     * @hidden\n     */\n    class PDEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n    }\n    /**\n     * Identifies that SUSP is in-use.\n     * @hidden\n     */\n    class SPEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        checkBytesPass() {\n            return this._data[4] === 0xBE && this._data[5] === 0xEF;\n        }\n        bytesSkipped() {\n            return this._data[6];\n        }\n    }\n    /**\n     * Identifies the end of the SUSP entries.\n     * @hidden\n     */\n    class STEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n    }\n    /**\n     * Specifies system-specific extensions to SUSP.\n     * @hidden\n     */\n    class EREntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        identifierLength() {\n            return this._data[4];\n        }\n        descriptorLength() {\n            return this._data[5];\n        }\n        sourceLength() {\n            return this._data[6];\n        }\n        extensionVersion() {\n            return this._data[7];\n        }\n        extensionIdentifier() {\n            return getASCIIString(this._data, 8, this.identifierLength());\n        }\n        extensionDescriptor() {\n            return getASCIIString(this._data, 8 + this.identifierLength(), this.descriptorLength());\n        }\n        extensionSource() {\n            return getASCIIString(this._data, 8 + this.identifierLength() + this.descriptorLength(), this.sourceLength());\n        }\n    }\n    /**\n     * @hidden\n     */\n    class ESEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        extensionSequence() {\n            return this._data[4];\n        }\n    }\n    /**\n     * RockRidge: Marks that RockRidge is in use [deprecated]\n     * @hidden\n     */\n    class RREntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n    }\n    /**\n     * RockRidge: Records POSIX file attributes.\n     * @hidden\n     */\n    class PXEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        mode() {\n            return this._data.readUInt32LE(4);\n        }\n        fileLinks() {\n            return this._data.readUInt32LE(12);\n        }\n        uid() {\n            return this._data.readUInt32LE(20);\n        }\n        gid() {\n            return this._data.readUInt32LE(28);\n        }\n        inode() {\n            return this._data.readUInt32LE(36);\n        }\n    }\n    /**\n     * RockRidge: Records POSIX device number.\n     * @hidden\n     */\n    class PNEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        devTHigh() {\n            return this._data.readUInt32LE(4);\n        }\n        devTLow() {\n            return this._data.readUInt32LE(12);\n        }\n    }\n    /**\n     * RockRidge: Records symbolic link\n     * @hidden\n     */\n    class SLEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        flags() {\n            return this._data[4];\n        }\n        continueFlag() {\n            return this.flags() & 0x1;\n        }\n        componentRecords() {\n            const records = new Array();\n            let i = 5;\n            while (i < this.length()) {\n                const record = new SLComponentRecord(this._data.slice(i));\n                records.push(record);\n                i += record.length();\n            }\n            return records;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class SLComponentRecord {\n        constructor(data) {\n            this._data = data;\n        }\n        flags() {\n            return this._data[0];\n        }\n        length() {\n            return 2 + this.componentLength();\n        }\n        componentLength() {\n            return this._data[1];\n        }\n        content(getString) {\n            return getString(this._data, 2, this.componentLength());\n        }\n    }\n    /**\n     * RockRidge: Records alternate file name\n     * @hidden\n     */\n    class NMEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        flags() {\n            return this._data[4];\n        }\n        name(getString) {\n            return getString(this._data, 5, this.length() - 5);\n        }\n    }\n    /**\n     * RockRidge: Records child link\n     * @hidden\n     */\n    class CLEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        childDirectoryLba() {\n            return this._data.readUInt32LE(4);\n        }\n    }\n    /**\n     * RockRidge: Records parent link.\n     * @hidden\n     */\n    class PLEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        parentDirectoryLba() {\n            return this._data.readUInt32LE(4);\n        }\n    }\n    /**\n     * RockRidge: Records relocated directory.\n     * @hidden\n     */\n    class REEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n    }\n    /**\n     * RockRidge: Records file timestamps\n     * @hidden\n     */\n    class TFEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        flags() {\n            return this._data[4];\n        }\n        creation() {\n            if (this.flags() & 1 /* CREATION */) {\n                if (this._longFormDates()) {\n                    return getDate(this._data, 5);\n                }\n                else {\n                    return getShortFormDate(this._data, 5);\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        modify() {\n            if (this.flags() & 2 /* MODIFY */) {\n                const previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;\n                if (this._longFormDates) {\n                    return getDate(this._data, 5 + (previousDates * 17));\n                }\n                else {\n                    return getShortFormDate(this._data, 5 + (previousDates * 7));\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        access() {\n            if (this.flags() & 4 /* ACCESS */) {\n                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;\n                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;\n                if (this._longFormDates) {\n                    return getDate(this._data, 5 + (previousDates * 17));\n                }\n                else {\n                    return getShortFormDate(this._data, 5 + (previousDates * 7));\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        backup() {\n            if (this.flags() & 16 /* BACKUP */) {\n                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;\n                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;\n                previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;\n                if (this._longFormDates) {\n                    return getDate(this._data, 5 + (previousDates * 17));\n                }\n                else {\n                    return getShortFormDate(this._data, 5 + (previousDates * 7));\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        expiration() {\n            if (this.flags() & 32 /* EXPIRATION */) {\n                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;\n                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;\n                previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;\n                previousDates += (this.flags() & 16 /* BACKUP */) ? 1 : 0;\n                if (this._longFormDates) {\n                    return getDate(this._data, 5 + (previousDates * 17));\n                }\n                else {\n                    return getShortFormDate(this._data, 5 + (previousDates * 7));\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        effective() {\n            if (this.flags() & 64 /* EFFECTIVE */) {\n                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;\n                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;\n                previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;\n                previousDates += (this.flags() & 16 /* BACKUP */) ? 1 : 0;\n                previousDates += (this.flags() & 32 /* EXPIRATION */) ? 1 : 0;\n                if (this._longFormDates) {\n                    return getDate(this._data, 5 + (previousDates * 17));\n                }\n                else {\n                    return getShortFormDate(this._data, 5 + (previousDates * 7));\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        _longFormDates() {\n            return !!(this.flags() && 128 /* LONG_FORM */);\n        }\n    }\n    /**\n     * RockRidge: File data in sparse format.\n     * @hidden\n     */\n    class SFEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        virtualSizeHigh() {\n            return this._data.readUInt32LE(4);\n        }\n        virtualSizeLow() {\n            return this._data.readUInt32LE(12);\n        }\n        tableDepth() {\n            return this._data[20];\n        }\n    }\n    /**\n     * @hidden\n     */\n    class Directory {\n        constructor(record, isoData) {\n            this._fileList = [];\n            this._fileMap = {};\n            this._record = record;\n            let i = record.lba();\n            let iLimit = i + record.dataLength();\n            if (!(record.fileFlags() & 2 /* Directory */)) {\n                // Must have a CL entry.\n                const cl = record.getSUEntries(isoData).filter((e) => e instanceof CLEntry)[0];\n                i = cl.childDirectoryLba() * 2048;\n                iLimit = Infinity;\n            }\n            while (i < iLimit) {\n                const len = isoData[i];\n                // Zero-padding between sectors.\n                // TODO: Could optimize this to seek to nearest-sector upon\n                // seeing a 0.\n                if (len === 0) {\n                    i++;\n                    continue;\n                }\n                const r = this._constructDirectoryRecord(isoData.slice(i));\n                const fname = r.fileName(isoData);\n                // Skip '.' and '..' entries.\n                if (fname !== '\\u0000' && fname !== '\\u0001') {\n                    // Skip relocated entries.\n                    if (!r.hasRockRidge() || r.getSUEntries(isoData).filter((e) => e instanceof REEntry).length === 0) {\n                        this._fileMap[fname] = r;\n                        this._fileList.push(fname);\n                    }\n                }\n                else if (iLimit === Infinity) {\n                    // First entry contains needed data.\n                    iLimit = i + r.dataLength();\n                }\n                i += r.length();\n            }\n        }\n        /**\n         * Get the record with the given name.\n         * Returns undefined if not present.\n         */\n        getRecord(name) {\n            return this._fileMap[name];\n        }\n        getFileList() {\n            return this._fileList;\n        }\n        getDotEntry(isoData) {\n            return this._constructDirectoryRecord(isoData.slice(this._record.lba()));\n        }\n    }\n    /**\n     * @hidden\n     */\n    class ISODirectory extends Directory {\n        constructor(record, isoData) {\n            super(record, isoData);\n        }\n        _constructDirectoryRecord(data) {\n            return new ISODirectoryRecord(data, this._record.getRockRidgeOffset());\n        }\n    }\n    /**\n     * @hidden\n     */\n    class JolietDirectory extends Directory {\n        constructor(record, isoData) {\n            super(record, isoData);\n        }\n        _constructDirectoryRecord(data) {\n            return new JolietDirectoryRecord(data, this._record.getRockRidgeOffset());\n        }\n    }\n    /**\n     * Mounts an ISO file as a read-only file system.\n     *\n     * Supports:\n     * * Vanilla ISO9660 ISOs\n     * * Microsoft Joliet and Rock Ridge extensions to the ISO9660 standard\n     */\n    class IsoFS extends SynchronousFileSystem {\n        /**\n         * **Deprecated. Please use IsoFS.Create() method instead.**\n         *\n         * Constructs a read-only file system from the given ISO.\n         * @param data The ISO file in a buffer.\n         * @param name The name of the ISO (optional; used for debug messages / identification via getName()).\n         */\n        constructor(data, name = \"\") {\n            super();\n            this._data = data;\n            // Skip first 16 sectors.\n            let vdTerminatorFound = false;\n            let i = 16 * 2048;\n            const candidateVDs = new Array();\n            while (!vdTerminatorFound) {\n                const slice = data.slice(i);\n                const vd = new VolumeDescriptor(slice);\n                switch (vd.type()) {\n                    case 1 /* PrimaryVolumeDescriptor */:\n                        candidateVDs.push(new PrimaryVolumeDescriptor(slice));\n                        break;\n                    case 2 /* SupplementaryVolumeDescriptor */:\n                        candidateVDs.push(new SupplementaryVolumeDescriptor(slice));\n                        break;\n                    case 255 /* VolumeDescriptorSetTerminator */:\n                        vdTerminatorFound = true;\n                        break;\n                }\n                i += 2048;\n            }\n            if (candidateVDs.length === 0) {\n                throw new ApiError(ErrorCode.EIO, `Unable to find a suitable volume descriptor.`);\n            }\n            candidateVDs.forEach((v) => {\n                // Take an SVD over a PVD.\n                if (!this._pvd || this._pvd.type() !== 2 /* SupplementaryVolumeDescriptor */) {\n                    this._pvd = v;\n                }\n            });\n            this._root = this._pvd.rootDirectoryEntry(data);\n            this._name = name;\n        }\n        /**\n         * Creates an IsoFS instance with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                cb(null, new IsoFS(opts.data, opts.name));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() {\n            return true;\n        }\n        getName() {\n            let name = `IsoFS${this._name}${this._pvd ? `-${this._pvd.name()}` : ''}`;\n            if (this._root && this._root.hasRockRidge()) {\n                name += `-RockRidge`;\n            }\n            return name;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system.\n            cb(this._data.length, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return true;\n        }\n        statSync(p, isLstat) {\n            const record = this._getDirectoryRecord(p);\n            if (record === null) {\n                throw ApiError.ENOENT(p);\n            }\n            return this._getStats(p, record);\n        }\n        openSync(p, flags, mode) {\n            // INVARIANT: Cannot write to RO file systems.\n            if (flags.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, p);\n            }\n            // Check if the path exists, and is a file.\n            const record = this._getDirectoryRecord(p);\n            if (!record) {\n                throw ApiError.ENOENT(p);\n            }\n            else if (record.isSymlink(this._data)) {\n                return this.openSync(path.resolve(p, record.getSymlinkPath(this._data)), flags, mode);\n            }\n            else if (!record.isDirectory(this._data)) {\n                const data = record.getFile(this._data);\n                const stats = this._getStats(p, record);\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw ApiError.EEXIST(p);\n                    case ActionType.NOP:\n                        return new NoSyncFile(this, p, flags, stats, data);\n                    default:\n                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw ApiError.EISDIR(p);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const record = this._getDirectoryRecord(path);\n            if (!record) {\n                throw ApiError.ENOENT(path);\n            }\n            else if (record.isDirectory(this._data)) {\n                return record.getDirectory(this._data).getFileList().slice(0);\n            }\n            else {\n                throw ApiError.ENOTDIR(path);\n            }\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        _getDirectoryRecord(path) {\n            // Special case.\n            if (path === '/') {\n                return this._root;\n            }\n            const components = path.split('/').slice(1);\n            let dir = this._root;\n            for (const component of components) {\n                if (dir.isDirectory(this._data)) {\n                    dir = dir.getDirectory(this._data).getRecord(component);\n                    if (!dir) {\n                        return null;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n            return dir;\n        }\n        _getStats(p, record) {\n            if (record.isSymlink(this._data)) {\n                const newP = path.resolve(p, record.getSymlinkPath(this._data));\n                const dirRec = this._getDirectoryRecord(newP);\n                if (!dirRec) {\n                    return null;\n                }\n                return this._getStats(newP, dirRec);\n            }\n            else {\n                const len = record.dataLength();\n                let mode = 0x16D;\n                const date = record.recordingDate().getTime();\n                let atime = date;\n                let mtime = date;\n                let ctime = date;\n                if (record.hasRockRidge()) {\n                    const entries = record.getSUEntries(this._data);\n                    for (const entry of entries) {\n                        if (entry instanceof PXEntry) {\n                            mode = entry.mode();\n                        }\n                        else if (entry instanceof TFEntry) {\n                            const flags = entry.flags();\n                            if (flags & 4 /* ACCESS */) {\n                                atime = entry.access().getTime();\n                            }\n                            if (flags & 2 /* MODIFY */) {\n                                mtime = entry.modify().getTime();\n                            }\n                            if (flags & 1 /* CREATION */) {\n                                ctime = entry.creation().getTime();\n                            }\n                        }\n                    }\n                }\n                // Mask out writeable flags. This is a RO file system.\n                mode = mode & 0x16D;\n                return new Stats(record.isDirectory(this._data) ? FileType.DIRECTORY : FileType.FILE, len, mode, atime, mtime, ctime);\n            }\n        }\n    }\n    IsoFS.Name = \"IsoFS\";\n    IsoFS.Options = {\n        data: {\n            type: \"object\",\n            description: \"The ISO file in a buffer\",\n            validator: bufferValidator\n        }\n    };\n\n\n    return IsoFS;\n});\ndefine('skylark-browserfs/core/backends',[\n    './util',\n    '../backend/AsyncMirror',\n    '../backend/Dropbox',\n    '../backend/Emscripten',\n    '../backend/FolderAdapter',\n    '../backend/HTML5FS',\n    '../backend/InMemory',\n    '../backend/IndexedDB',\n    '../backend/LocalStorage',\n    '../backend/MountableFileSystem',\n    '../backend/OverlayFS',\n    '../backend/WorkerFS',\n    '../backend/HTTPRequest',\n    '../backend/ZipFS',\n    '../backend/IsoFS'\n], function (util, AsyncMirror, Dropbox, Emscripten, FolderAdapter, HTML5FS, InMemory, IndexedDB, LocalStorage, MountableFileSystem, OverlayFS, WorkerFS, HTTPRequest, ZipFS, IsoFS) {\n    'use strict';\n    const { checkOptions } = util;\n\n    \n\n    // Monkey-patch `Create` functions to check options before file system initialization.\n    [AsyncMirror, Dropbox, Emscripten, FolderAdapter, HTML5FS, InMemory, IndexedDB, IsoFS, LocalStorage, MountableFileSystem, OverlayFS, WorkerFS, HTTPRequest, ZipFS].forEach((fsType) => {\n        const create = fsType.Create;\n        fsType.Create = function (opts, cb) {\n            const oneArg = typeof (opts) === \"function\";\n            const normalizedCb = oneArg ? opts : cb;\n            const normalizedOpts = oneArg ? {} : opts;\n            function wrappedCb(e) {\n                if (e) {\n                    normalizedCb(e);\n                }\n                else {\n                    create.call(fsType, normalizedOpts, normalizedCb);\n                }\n            }\n            checkOptions(fsType, normalizedOpts, wrappedCb);\n        };\n    });\n    /**\n     * @hidden\n     */\n    const Backends = { AsyncMirror, Dropbox, Emscripten, FolderAdapter, HTML5FS, InMemory, IndexedDB, IsoFS, LocalStorage, MountableFileSystem, OverlayFS, WorkerFS, HTTPRequest, XmlHttpRequest: HTTPRequest, ZipFS };\n    // Make sure all backends cast to FileSystemConstructor (for type checking)\n    const _ = Backends;\n    // tslint:disable-next-line:no-unused-expression\n    _;\n    // tslint:enable-next-line:no-unused-expression\n    return Backends;\n});\ndefine('skylark-browserfs/core/browserfs',[\n    \"skylark-langx-ns\",\n    '../libs/process',\n    '../libs/buffers',\n    './node_fs',\n    '../libs/path',\n    '../generic/emscripten_fs',\n    './backends',\n    './util',\n    './api_error',\n    '../generic/setImmediate'\n], function (skylark,process,buffers, fs, path, EmscriptenFS, Backends, BFSUtils, Errors, setImmediate) {\n    'use strict';\n\n    const {Buffer} = buffers;\n    \n    /**\n     * BrowserFS's main module. This is exposed in the browser via the BrowserFS global.\n     * Due to limitations in typedoc, we document these functions in ./typedoc.ts.\n     */\n    if (process['initializeTTYs']) {\n        process['initializeTTYs']();\n    }\n    /**\n     * Installs BFSRequire as global `require`, a Node Buffer polyfill as the global `Buffer` variable,\n     * and a Node process polyfill as the global `process` variable.\n     */\n    function install(obj) {\n        obj.Buffer = Buffer;\n        obj.process = process;\n        const oldRequire = obj.require ? obj.require : null;\n        // Monkey-patch require for Node-style code.\n        obj.require = function (arg) {\n            const rv = BFSRequire(arg);\n            if (!rv) {\n                return oldRequire.apply(null, Array.prototype.slice.call(arguments, 0));\n            }\n            else {\n                return rv;\n            }\n        };\n    }\n    /**\n     * @hidden\n     */\n    function registerFileSystem(name, fs) {\n        Backends[name] = fs;\n    }\n    function BFSRequire(module) {\n        switch (module) {\n            case 'fs':\n                return fs;\n            case 'path':\n                return path;\n            case 'buffer':\n                // The 'buffer' module has 'Buffer' as a property.\n                return buffer;\n            case 'process':\n                return process;\n            case 'bfs_utils':\n                return BFSUtils;\n            default:\n                return Backends[module];\n        }\n    }\n    /**\n     * Initializes BrowserFS with the given root file system.\n     */\n    function initialize(rootfs) {\n        return fs.initialize(rootfs);\n    }\n    /**\n     * Creates a file system with the given configuration, and initializes BrowserFS with it.\n     * See the FileSystemConfiguration type for more info on the configuration object.\n     */\n    function configure(config, cb) {\n        getFileSystem(config, (e, fs) => {\n            if (fs) {\n                initialize(fs);\n                cb();\n            }\n            else {\n                cb(e);\n            }\n        });\n    }\n    /**\n     * Retrieve a file system with the given configuration.\n     * @param config A FileSystemConfiguration object. See FileSystemConfiguration for details.\n     * @param cb Called when the file system is constructed, or when an error occurs.\n     */\n    function getFileSystem(config, cb) {\n        const fsName = config['fs'];\n        if (!fsName) {\n            return cb(new Errors.ApiError(Errors.ErrorCode.EPERM, 'Missing \"fs\" property on configuration object.'));\n        }\n        const options = config['options'];\n        let waitCount = 0;\n        let called = false;\n        function finish() {\n            if (!called) {\n                called = true;\n                const fsc = Backends[fsName];\n                if (!fsc) {\n                    cb(new Errors.ApiError(Errors.ErrorCode.EPERM, `File system ${fsName} is not available in BrowserFS.`));\n                }\n                else {\n                    fsc.Create(options, cb);\n                }\n            }\n        }\n        if (options !== null && typeof (options) === \"object\") {\n            let finishedIterating = false;\n            const props = Object.keys(options).filter((k) => k !== 'fs');\n            // Check recursively if other fields have 'fs' properties.\n            props.forEach((p) => {\n                const d = options[p];\n                if (d !== null && typeof (d) === \"object\" && d['fs']) {\n                    waitCount++;\n                    getFileSystem(d, function (e, fs) {\n                        waitCount--;\n                        if (e) {\n                            if (called) {\n                                return;\n                            }\n                            called = true;\n                            cb(e);\n                        }\n                        else {\n                            options[p] = fs;\n                            if (waitCount === 0 && finishedIterating) {\n                                finish();\n                            }\n                        }\n                    });\n                }\n            });\n            finishedIterating = true;\n        }\n        if (waitCount === 0) {\n            finish();\n        }\n    }\n\n    return skylark.attach(\"intg.BrowserFS\",{\n        install: install,\n        registerFileSystem: registerFileSystem,\n        BFSRequire: BFSRequire,\n        initialize: initialize,\n        configure: configure,\n        getFileSystem: getFileSystem,\n        EmscriptenFS,\n        \"FileSystem\" : Backends,\n        Errors,\n        setImmediate\n    });\n});\ndefine('skylark-browserfs/main',[\n    \"./core/browserfs\"\n],function(browserfs){\n    return browserfs;\n});\ndefine('skylark-browserfs', ['skylark-browserfs/main'], function (main) { return main; });\n\n"]}